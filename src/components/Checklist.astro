---
import UIString from "./UIString.astro";

export interface Props {
	key?: string;
}

const { key = 'default' } = Astro.props as Props;
---

<check-list data-key={key}>
	<div class="checklist"><slot /></div>
	{Astro.slots.has('alternative') && (
		<p class="or"><UIString key="checklist.or" /></p>
		<div class="checklist alternative"><slot name="alternative" /></div>
	)}
</check-list>

<style>
	check-list > * + * {
		margin-top: 1rem;
	}

	.checklist > :global(ul) {
		list-style: none;
		padding-inline-start: 0;
	}
	
	check-list :global(label) {
		display: block;
		position: relative;
		margin: 0 -1rem;
		border-radius: 1rem;
		padding: .5rem .5rem .5rem 4rem;
		cursor: pointer;
		/* Compensate for space between checkbox and text. */
		text-indent: -.4ch;
	}
	
	check-list :global(label:hover) {
		background-color: var(--theme-bg-hover);
	}

	check-list :global(input[type="checkbox"]) {
		-webkit-appearance: none;
		appearance: none;
	}

	check-list :global(input[type="checkbox"]:focus) {
		outline: none;
	}

	check-list :global(input[type="checkbox"]::after) {
		content: '✔︎';
		position: absolute;
		left: 1rem;
		top: 50%;
		transform: translateY(-50%);
		text-align: center;
		line-height: 2;
		width: 2em;
		height: 2em;
		font-size: 1.25em;
		border-radius: 50%;
		background-color: var(--theme-divider);
		color: var(--theme-divider);
		cursor: pointer;
	}

	check-list :global(input[type="checkbox"]:focus::after) {
		outline: 3px solid var(--theme-text);
		outline-offset: .5rem;
	}

	check-list :global(input[type="checkbox"]:not(:focus-visible)::after) {
		outline: none;
	}
	
	check-list :global(input[type="checkbox"]:checked::after) {
		content: '✔︎';
		color: hsl(var(--color-base-white), 100%);
		background-color: hsl(var(--color-green));
	}

	check-list :global(input[type='checkbox']:checked ~ *),
	check-list :global(input[type='checkbox']:checked ~ * *) {
		text-decoration: line-through 3px;
		text-decoration-color: hsl(var(--color-green));
		color: var(--theme-text-lighter);
	}

	.or {
		display: grid;
		grid-template-columns: 1fr auto 1fr;
		gap: 1em;
		text-transform: uppercase;
		font-weight: bold;
		color: var(--theme-text-lighter);
	}

	.or::before, .or::after {
		--divider-width: 4px;
		content: '';
		background-image: linear-gradient(
			to bottom,
			transparent calc(50% - var(--divider-width) / 2),
			var(--theme-divider) calc(50% - var(--divider-width) / 2) calc(50% + var(--divider-width) / 2),
			transparent calc(50% + var(--divider-width) / 2) 100%
		);
	}
</style>

<script>
	import { ProgressStore, SubListType } from "./tutorial/ProgressStore";

	class CheckList extends HTMLElement {
		key: string;

		constructor() {
			super();
			this.key = this.dataset['key']!;
			ProgressStore.initialiseList(this.key);
			this.upgradeSubList(this.querySelector('.checklist ul'), 'primary');
			this.upgradeSubList(this.querySelector('.checklist.alternative ul'), 'secondary');
		}

		/** Upgrade the primary or secondary check lists. */
		upgradeSubList(ul: Element | null, type: SubListType) {
			if (!ul) return;
			const items = Array.from(ul.children);
			ProgressStore.initaliseSubList(this.key, type, items.length);
			items.forEach((li, index) => this.upgradeTaskItem(li, type, index));
		}

		/** Upgrade an item in a GitHub-Flavoured Markdown task list. */
		upgradeTaskItem(li: Element, type: SubListType, index: number) {
			// Re-enable checkboxes, hydrate state & listen for changes.
			const checkbox = li.querySelector('input[type="checkbox"]') as HTMLInputElement;
			checkbox.removeAttribute('disabled');
			checkbox.checked = ProgressStore.getSubListItem(this.key, type, index);
			checkbox.addEventListener('change', (e) => {
				ProgressStore.setSubListItem(this.key, type, index, (e.currentTarget as HTMLInputElement).checked);
			});
		}
	}

	customElements.define('check-list', CheckList);
</script>
