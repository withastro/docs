---
title: Nâng cấp lên Astro v5
description: Cách nâng cấp dự án của bạn lên Astro v5.0.
sidebar:
  label: v5.0
i18nReady: true
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'
import { Steps } from '@astrojs/starlight/components';
import ReadMore from '~/components/ReadMore.astro'
import SourcePR from '~/components/SourcePR.astro'

Hướng dẫn này sẽ giúp bạn di chuyển từ Astro v4 sang Astro v5.

Cần nâng cấp dự án cũ hơn lên v4 trước? Xem [hướng dẫn di chuyển cũ hơn](/vi/guides/upgrade-to/v4/) của chúng tôi.

Cần xem tài liệu v4? Truy cập [phiên bản cũ hơn của trang tài liệu này (bản snapshot v4.16 không được duy trì)](https://v4.docs.astro.build/).

## Nâng cấp Astro

Cập nhật phiên bản Astro của dự án bạn lên phiên bản mới nhất bằng trình quản lý gói:

<PackageManagerTabs>
  <Fragment slot="npm">
  ```shell
  # Nâng cấp Astro và các integration chính thức cùng nhau
  npx @astrojs/upgrade
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```shell
  # Nâng cấp Astro và các integration chính thức cùng nhau
  pnpm dlx @astrojs/upgrade
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```shell
  # Nâng cấp Astro và các integration chính thức cùng nhau
  yarn dlx @astrojs/upgrade
  ```
  </Fragment>
</PackageManagerTabs>

Bạn cũng có thể [nâng cấp các integration Astro thủ công](/vi/guides/integrations-guide/#manual-upgrading) nếu cần, và bạn cũng có thể cần nâng cấp các dependency khác trong dự án.

:::note[Cần tiếp tục?]
Sau khi nâng cấp Astro, bạn có thể không cần thay đổi gì trong dự án của mình!

Nhưng nếu bạn gặp lỗi hoặc hành vi bất thường, vui lòng kiểm tra bên dưới những gì đã thay đổi có thể cần cập nhật trong dự án của bạn.
:::

Astro v5.0 bao gồm [những thay đổi có thể phá vỡ tương thích](#breaking-changes), cũng như việc xóa bỏ và deprecated một số tính năng.

Nếu dự án của bạn không hoạt động như mong đợi sau khi nâng cấp lên v5.0, hãy kiểm tra hướng dẫn này để biết tổng quan về tất cả các thay đổi phá vỡ tương thích và hướng dẫn cách cập nhật codebase của bạn.

Xem [changelog của Astro](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) để biết ghi chú phát hành đầy đủ.

## Nâng cấp Dependencies

Bất kỳ nâng cấp lớn nào đối với dependencies của Astro đều có thể gây ra thay đổi phá vỡ tương thích trong dự án của bạn.

### Vite 6.0

Astro v5.0 nâng cấp lên Vite v6.0 làm development server và production bundler.

#### Tôi nên làm gì?

Nếu bạn đang sử dụng Shiki transformers được truyền cho `markdown.shikiConfig.transformers`, bạn phải đảm bảo rằng chúng không sử dụng hook `postprocess`. Hook này không còn chạy trên code blocks trong file `.md` và `.mdx`. (Xem [tài liệu Shiki về transformer hooks](https://shiki.style/guide/transformers#transformer-hooks) để biết thêm thông tin).

Code blocks trong file `.mdoc` và component `<Code />` tích hợp của Astro không sử dụng plugin rehype Shiki nội bộ và không bị ảnh hưởng.

<ReadMore>Đọc thêm về [syntax highlighting trong Astro](/vi/guides/syntax-highlighting/).</ReadMore>

### Thay đổi: Hành vi `charset=utf-8` tự động cho các trang Markdown và MDX

<SourcePR number="12231" title="Unset charset=utf-8 content-type for md/mdx pages"/>

Trong Astro 4.0, các trang Markdown và MDX (nằm trong `src/pages/`) tự động phản hồi với `charset=utf-8` trong header `Content-Type`, cho phép render các ký tự không phải ASCII trong trang của bạn.

Astro 5.0 cập nhật hành vi để thêm thẻ `<meta charset="utf-8">` thay vào đó, và chỉ cho các trang không sử dụng thuộc tính frontmatter `layout` đặc biệt của Astro. Tương tự cho các trang MDX, Astro sẽ chỉ thêm thẻ nếu nội dung MDX không import component `Layout` bao bọc.

Nếu các trang Markdown hoặc MDX của bạn sử dụng thuộc tính frontmatter `layout`, hoặc nếu nội dung trang MDX import component `Layout` bao bọc, thì HTML encoding sẽ được xử lý bởi component layout được chỉ định thay vào đó, và thẻ `<meta charset="utf-8">` sẽ không được thêm vào trang của bạn theo mặc định.

#### Tôi nên làm gì?

Nếu bạn yêu cầu `charset=utf-8` để render trang của mình một cách chính xác, hãy đảm bảo rằng các component layout của bạn chứa thẻ `<meta charset="utf-8">`. Bạn có thể cần thêm điều này nếu bạn chưa làm như vậy.

<ReadMore>Đọc thêm về [Markdown layouts](/vi/basics/layouts/#markdown-layouts).</ReadMore>

### Thay đổi: Metadata cụ thể của Astro được đính kèm trong các plugin remark và rehype

<SourcePR number="11861" title="Clean up Astro metadata in vfile.data"/>

Trong Astro 4.x, metadata cụ thể của Astro được đính kèm vào `vfile.data` trong các plugin remark và rehype được đính kèm ở các vị trí khác nhau với tên không nhất quán.

Astro 5 dọn dẹp API và metadata giờ đây được đổi tên như bên dưới:

 - `vfile.data.__astroHeadings` -> `vfile.data.astro.headings`
 - `vfile.data.imagePaths` -> `vfile.data.astro.imagePaths`

Kiểu của `imagePaths` cũng đã được cập nhật từ `Set<string>` thành `string[]`. Metadata `vfile.data.astro.frontmatter` được giữ nguyên.

#### Tôi nên làm gì?

Mặc dù chúng tôi không coi những API này là công khai, chúng có thể được truy cập bởi các plugin remark và rehype muốn tái sử dụng metadata của Astro. Nếu bạn đang sử dụng những API này, hãy đảm bảo truy cập chúng ở các vị trí mới.

<ReadMore>Đọc thêm về [sử dụng Markdown plugins trong Astro](/vi/guides/markdown-content/#markdown-plugins).</ReadMore>

### Thay đổi: cấu hình image endpoint

<SourcePR number="11908" title="Allow customising the route of the image endpoint"/>

Trong Astro 4.x, bạn có thể thiết lập một endpoint trong cấu hình `image` để sử dụng cho tối ưu hóa hình ảnh.

Astro 5.0 cho phép bạn tùy chỉnh `route` và `entrypoint` của config `image.endpoint`. Điều này có thể hữu ích trong các tình huống ngách nơi route mặc định `/_image` xung đột với route hiện có hoặc thiết lập local server của bạn.

#### Tôi nên làm gì?

Nếu bạn đã tùy chỉnh `image.endpoint` trước đây, hãy di chuyển endpoint này sang thuộc tính `endpoint.entrypoint` mới. Tùy chọn, bạn có thể tùy chỉnh một `route`:

```js title="astro.config.mjs" del={5} ins={6-9}
import { defineConfig } from "astro/config";

defineConfig({
  image: {
    endpoint: './src/image-endpoint.ts',
    endpoint: {
      route: "/image",
      entrypoint: "./src/image_endpoint.ts"
    }
  },
})
```

<ReadMore>Đọc thêm về [thiết lập endpoint để sử dụng cho tối ưu hóa hình ảnh](/vi/reference/configuration-reference/#imageendpoint).</ReadMore>

### Thay đổi: hành vi resolve `build.client` và `build.server`

<SourcePR number="11916" title="Fix build.client and build.server resolve behaviour" />

Trong Astro v4.x, các tùy chọn `build.client` và `build.server` được ghi chép để resolve tương đối từ tùy chọn `outDir`, nhưng nó không luôn hoạt động như mong đợi.

Astro 5.0 sửa hành vi để resolve chính xác từ tùy chọn `outDir`. Ví dụ, nếu `outDir` được thiết lập thành `./dist/nested/`, thì theo mặc định:

- `build.client` sẽ resolve thành `<root>/dist/nested/client/`
- `build.server` sẽ resolve thành `<root>/dist/nested/server/`

Trước đây các giá trị được resolve không chính xác:

- `build.client` được resolve thành `<root>/dist/nested/dist/client/`
- `build.server` được resolve thành `<root>/dist/nested/dist/server/`

#### Tôi nên làm gì?

Nếu bạn đang dựa vào các build paths trước đây, hãy đảm bảo rằng code dự án của bạn được cập nhật cho các build paths mới.

<ReadMore>Đọc thêm về [tùy chọn cấu hình `build` trong Astro](/vi/reference/configuration-reference/#build-options).</ReadMore>

### Thay đổi: JS dependencies trong config file không còn được xử lý bởi Vite

<SourcePR number="11819" title="Set external: true when loading astro config"/>

Trong Astro 4.x, các JS dependencies được liên kết cục bộ (ví dụ: `npm link`, trong monorepo, v.v.) có thể sử dụng các tính năng Vite như `import.meta.glob` khi được import bởi file config Astro.

Astro 5 cập nhật luồng loading config Astro để bỏ qua việc xử lý các JS dependencies được liên kết cục bộ với Vite. Các dependencies export raw TypeScript files không bị ảnh hưởng. Thay vào đó, những JS dependencies này sẽ được import bình thường bởi Node.js runtime giống như các dependencies khác từ `node_modules`.

Thay đổi này được thực hiện vì hành vi trước đây gây ra nhầm lẫn giữa các tác giả integration người đã test với một gói hoạt động cục bộ, nhưng không hoạt động khi được published. Nó cũng hạn chế việc sử dụng các CJS-only dependencies vì Vite yêu cầu code phải là ESM. Mặc dù thay đổi này chỉ ảnh hưởng đến JS dependencies, cũng được khuyến nghị cho các gói export JavaScript thay vì raw TypeScript khi có thể để ngăn việc sử dụng Vite-specific tình cờ vì nó là chi tiết triển khai của luồng loading config của Astro.

#### Tôi nên làm gì?

Đảm bảo các JS dependencies được liên kết cục bộ của bạn được build trước khi chạy dự án Astro. Sau đó, việc loading config sẽ hoạt động như trước.

<ReadMore>Đọc thêm về [cài đặt cấu hình Vite trong Astro](/vi/reference/configuration-reference/#vite).</ReadMore>

### Thay đổi: URLs được trả về bởi `paginate()`

<SourcePR number="11253" title="Add base to paginate"/>

Trong Astro v4.x, URL được trả về bởi `paginate()` (ví dụ: `page.url.next`, `page.url.first`, v.v.) không bao gồm giá trị được thiết lập cho `base` trong config Astro của bạn. Bạn phải thêm thủ công giá trị đã cấu hình cho `base` vào URL path.

Astro 5.0 tự động bao gồm giá trị `base` trong `page.url`.

#### Tôi nên làm gì?

Nếu bạn đang sử dụng function `paginate()` cho những URLs này, hãy xóa bất kỳ giá trị `base` hiện có nào vì giờ đây nó được thêm cho bạn:

```astro del={16} ins={17}
---
export async function getStaticPaths({ paginate }) {
  const astronautPages = [{
    astronaut: 'Neil Armstrong',
  }, {
    astronaut: 'Buzz Aldrin',
  }, {
    astronaut: 'Sally Ride',
  }, {
    astronaut: 'John Glenn',
  }];
  return paginate(astronautPages, { pageSize: 1 });
}
const { page } = Astro.props;
// `base: /'docs'` được cấu hình trong `astro.config.mjs`
const prev = "/docs" + page.url.prev;
const prev = page.url.prev;
---
<a id="prev" href={prev}>Back</a>
```

<ReadMore>Đọc thêm về [pagination trong Astro](/vi/guides/routing/#pagination).</ReadMore>

### Thay đổi: giá trị thuộc tính HTML không boolean

<SourcePR number="11660" title="Fix attribute rendering for boolean values (take 2)"/>

Trong Astro v4.x, [thuộc tính HTML không boolean](https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML) có thể không bao gồm giá trị của chúng khi được render thành HTML.

Astro v5.0 render các giá trị một cách rõ ràng như `="true"` hoặc `="false"`, khớp với xử lý thuộc tính thích hợp trong browsers.

Trong các ví dụ `.astro` sau, chỉ `allowfullscreen` là thuộc tính boolean:

```astro
<!-- src/pages/index.astro -->
<!-- `allowfullscreen` là thuộc tính boolean -->
<p allowfullscreen={true}></p>
<p allowfullscreen={false}></p>
<!-- `inherit` *không* là thuộc tính boolean -->
<p inherit={true}></p>
<p inherit={false}></p>
<!-- Thuộc tính `data-*` không phải là thuộc tính boolean -->
<p data-light={true}></p>
<p data-light={false}></p>
```

Astro v5.0 giờ đây bảo tồn thuộc tính data đầy đủ với giá trị của nó khi render HTML của các thuộc tính không boolean:

```astro del={5,8,10} ins={6,9,11}
<p allowfullscreen></p>
<p></p>

<p inherit="true"></p>
<p inherit></p>
<p inherit="false"></p>

<p data-light></p>
<p data-light="true"></p>
<p></p>
<p data-light="false"></p>
```

#### Tôi nên làm gì?

Nếu bạn dựa vào giá trị thuộc tính, ví dụ, để định vị elements hoặc để render có điều kiện, hãy cập nhật code của bạn để khớp với giá trị thuộc tính không boolean mới:

```js del={1,4} ins={2,5}
el.getAttribute('inherit') === ''
el.getAttribute('inherit') === 'false'

el.hasAttribute('data-light')
el.dataset.light === 'true'
```

<ReadMore>Đọc thêm về [sử dụng HTML attributes trong Astro](/vi/reference/astro-syntax/#dynamic-attributes).</ReadMore>

### Thay đổi: thêm giá trị vào `context.locals`

<SourcePR number="11987" title="TODOs"/>

Trong Astro 4.x, có thể thay thế hoàn toàn object `locals` trong middleware, API endpoints, và pages khi thêm giá trị mới.

Astro 5.0 yêu cầu bạn append giá trị vào object `locals` hiện có mà không xóa nó. Locals trong middleware, API endpoints, và pages, không thể bị ghi đè hoàn toàn nữa.

#### Tôi nên làm gì?

Nơi bạn trước đây đang ghi đè object, bây giờ bạn phải thay vào đó assign giá trị cho nó:

```js title="src/middleware.js" del={1,5} ins={2,6}
ctx.locals = {
Object.assign(ctx.locals, {
  one: 1,
  two: 2
}
})
```

<ReadMore>Xem thêm về [lưu trữ dữ liệu trong `context.locals`](/vi/guides/middleware/#storing-data-in-contextlocals).</ReadMore>

### Thay đổi: `params` không còn được decoded

<SourcePR number="12079" title="decode pathname early, don't decode params"/>

Trong Astro v4.x, `params` được truyền cho `getStaticPath()` tự động được decoded bằng `decodeURIComponent`.

Astro v5.0 không còn decode giá trị của `params` được truyền cho `getStaticPaths`. Bạn phải decode chúng thủ công nếu cần.

#### Tôi nên làm gì?

Nếu bạn trước đây dựa vào việc decoding tự động, hãy sử dụng `decodeURI` khi truyền `params`.

```astro title="src/pages/[id].astro" del={4} ins={5}
---
export function getStaticPaths() {
  return [
    { params: { id: "%5Bpage%5D" } },
    { params: { id: decodeURI("%5Bpage%5D") } },
  ]
}

const { id } = Astro.params;
---
```

Lưu ý rằng việc sử dụng [`decodeURIComponent`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent) không được khuyến nghị cho `getStaticPaths` vì nó decode nhiều ký tự hơn mức cần thiết, ví dụ `/`, `?`, `#` và nhiều hơn nữa.

<ReadMore>Đọc thêm về [tạo dynamic routes với `params`](/vi/guides/routing/#static-ssg-mode).</ReadMore>

### Thay đổi: Type `RouteData` được thay thế bởi `IntegrationsRouteData` (Integrations API)

<SourcePR number="11864" title="send `IntegrationRouteData` to integrations"/>

Trong Astro v4.x, kiểu `entryPoints` bên trong hooks `astro:build:ssr` và `astro:build:done` là `RouteData`.

Astro v5.0 kiểu `entryPoints` giờ đây là `IntegrationRouteData`, chứa một tập con của kiểu `RouteData`. Các trường `isIndex` và `fallbackRoutes` đã được xóa.

#### Tôi nên làm gì?

Cập nhật adapter của bạn để thay đổi kiểu của `entryPoints` từ `RouteData` thành `IntegrationRouteData`.

```js del={1,4} ins={2,5}
import type {RouteData} from 'astro';
import type {IntegrationRouteData} from "astro"

function useRoute(route: RouteData) {
function useRoute(route: IntegrationRouteData) {
}
```

<ReadMore>Xem [API reference cho `IntegrationRouteData`](/vi/reference/integrations-reference/#integrationroutedata-type-reference).</ReadMore>

### Thay đổi: `distURL` giờ đây là một mảng (Integrations API)

<SourcePR number="11864" title="send `IntegrationRouteData` to integrations"/>

Trong Astro v4.x, `RouteData.distURL` là `undefined` hoặc một `URL`.

Astro v5.0 cập nhật hình dạng của `IntegrationRouteData.distURL` thành `undefined` hoặc một mảng `URL`s. Điều này sửa lỗi trước đó vì một route có thể tạo nhiều file trên disk, đặc biệt khi sử dụng dynamic routes như `[slug]` hoặc `[...slug]`.

#### Tôi nên làm gì?

Cập nhật code của bạn để xử lý `IntegrationRouteData.distURL` như một mảng.

```js del={2-4} ins={5-9}
if (route.distURL) {
  if (route.distURL.endsWith('index.html')) {
    // làm gì đó
  }
  for (const url of route.distURL) {
    if (url.endsWith('index.html')) {
      // làm gì đó
    }
  }
}
```

<ReadMore>Xem [API reference cho `IntegrationRouteData`](/vi/reference/integrations-reference/#integrationroutedata-type-reference).</ReadMore>

### Thay đổi: Đối số được truyền cho `app.render()` (Adapter API)

<SourcePR number="11987" title="TODOs"/>

Trong Astro 4.x, phương thức Adapter API `app.render()` có thể nhận ba đối số: một `request` bắt buộc, một object tùy chọn hoặc object `routeData`, và `locals`.

Astro 5.0 kết hợp hai đối số cuối này thành một đối số tùy chọn duy nhất có tên `renderOptions`.

#### Tôi nên làm gì?

Truyền một object làm đối số thứ hai cho `app.render()`, có thể bao gồm `routeData` và `locals` như các thuộc tính.

```js del={1} ins={2}
const response = await app.render(request, routeData, locals);
const response = await app.render(request, {routeData, locals});
```

<ReadMore>Xem [Adapter API reference cho `renderOptions`](/vi/reference/adapter-reference/#renderoptions).</ReadMore>

### Thay đổi: Thuộc tính trên `supportedAstroFeatures` (Adapter API)

<SourcePR number="11806" title="rework supportedAstroFeatures"/>

Trong Astro 4.x, `supportedAstroFeatures`, cho phép các tác giả adapter chỉ định những tính năng mà integration của họ hỗ trợ, bao gồm thuộc tính `assets` để chỉ định những dịch vụ hình ảnh nào của Astro được hỗ trợ.

Astro 5.0 thay thế thuộc tính này bằng thuộc tính `sharpImageService` chuyên dụng, được sử dụng để xác định liệu adapter có tương thích với dịch vụ hình ảnh sharp tích hợp hay không.

v5.0 cũng thêm giá trị `limited` mới cho các thuộc tính khác nhau của `supportedAstroFeatures` cho adapters, cho biết adapter tương thích với tính năng, nhưng với một số hạn chế. Điều này hữu ích cho các adapters hỗ trợ một tính năng, nhưng không trong tất cả các trường hợp hoặc với tất cả các tùy chọn.

Ngoài ra, giá trị của các thuộc tính khác nhau trên `supportedAstroFeatures` cho adapters giờ đây có thể là objects, với thuộc tính `support` và `message`. Nội dung của thuộc tính `message` sẽ hiển thị thông báo hữu ích trong Astro CLI khi adapter không tương thích với một tính năng. Điều này đặc biệt hữu ích với giá trị `limited` mới, để giải thích cho người dùng tại sao support bị hạn chế.

#### Tôi nên làm gì?

Nếu bạn đang sử dụng thuộc tính `assets`, hãy xóa nó vì nó không còn khả dụng. Để chỉ định rằng adapter của bạn hỗ trợ dịch vụ hình ảnh sharp tích hợp, hãy thay thế điều này bằng `sharpImageService`.

Bạn cũng có thể muốn cập nhật các tính năng được hỗ trợ với tùy chọn `limited` mới và bao gồm thông báo về support của adapter.

```ts title="my-adapter.mjs" del={2-6} ins={7-10}
supportedAstroFeatures: {
  assets: {
    supportKind: "stable",
    isSharpCompatible: true,
    isSquooshCompatible: true,
  },
  sharpImageService: {
    support: "limited",
    message: 'Adapter này hỗ trợ dịch vụ hình ảnh sharp tích hợp, nhưng với một số hạn chế.'
  }
}
```

<ReadMore>Đọc thêm về [chỉ định các tính năng Astro được hỗ trợ trong adapter](/vi/reference/adapter-reference/#astro-features).</ReadMore>

### Đã xóa: Hình dạng định nghĩa deprecated cho dev toolbar apps (Dev Toolbar API)

<SourcePR number="11987" title="Remove deprecated dev toolbar app shape"/>

Trong Astro 4.x, khi xây dựng dev toolbar app, vẫn có thể sử dụng signature `addDevToolbarApp(string);` đã deprecated trước đây. Các thuộc tính `id`, `title`, và `icon` để định nghĩa app sau đó được cung cấp thông qua default export của `entrypoint` của app.

Astro 5.0 xóa hoàn toàn tùy chọn này ủng hộ hình dạng object hiện tại khi định nghĩa dev toolbar app trong integration trực quan hơn và cho phép Astro cung cấp lỗi tốt hơn khi toolbar apps không load chính xác.

#### Tôi nên làm gì?

Nếu bạn đang sử dụng hình dạng deprecated, hãy cập nhật dev toolbar app để sử dụng hình dạng mới:

```js title="my-integration.mjs" del={1-2} ins={4-10}
// Hình dạng cũ
addDevToolbarApp("./my-dev-toolbar-app.mjs");

// Hình dạng mới
addDevToolbarApp({
  id: "my-app",
  name: "My App",
  icon: "<svg>...</svg>",
  entrypoint: "./my-dev-toolbar-app.mjs",
});
```

```js title="my-dev-toolbar-app.mjs" del={2-4}
export default {
  id: 'my-dev-toolbar-app',
  title: 'My Dev Toolbar App',
  icon: '🚀',
  init() {
    // ...
  }
}
```

<ReadMore>Đọc thêm về [phát triển dev toolbar app cho Astro bằng Dev Toolbar API](/vi/reference/dev-toolbar-app-reference/).</ReadMore>

### Đã xóa: cấu hình Typescript trong `create-astro`

<SourcePR number="12083" title="create-astro updates"/>

Trong Astro v4.x, có thể chọn giữa ba cài đặt TypeScript của Astro khi tạo dự án mới bằng `create astro`, bằng cách trả lời câu hỏi hoặc bằng cách truyền flag `--typescript` liên quan với cài đặt TypeScript mong muốn.

Astro 5.0 cập nhật lệnh CLI `create astro` để xóa câu hỏi TypeScript và flag `--typescript` liên quan. Preset "strict" giờ đây là mặc định cho tất cả các dự án mới được tạo với command line và không còn có thể tùy chỉnh điều này vào thời điểm đó. Tuy nhiên, template TypeScript vẫn có thể được thay đổi thủ công trong `tsconfig.json`.

#### Tôi nên làm gì?

Nếu bạn đang sử dụng flag `--typescript` với `create-astro`, hãy xóa nó khỏi lệnh của bạn.

<PackageManagerTabs>
  <Fragment slot="npm">
  ```diff lang=shell
  -npm create astro@latest -- --template <example-name> --typescript strict
  +npm create astro@latest -- --template <example-name>
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```diff lang=shell
  -pnpm create astro@latest --template <example-name> --typescript strict
  +pnpm create astro@latest --template <example-name>
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```diff lang=shell
  -yarn create astro --template <example-name> --typescript strict
  +yarn create astro --template <example-name>
  ```
  </Fragment>
</PackageManagerTabs>

<ReadMore>Xem [tất cả các flag lệnh `create astro` khả dụng](https://github.com/withastro/astro/blob/main/packages/create-astro/README.md)</ReadMore>

## Tài nguyên cộng đồng

Biết một tài nguyên tốt cho Astro v5.0? [Chỉnh sửa trang này](https://github.com/withastro/docs/edit/main/src/content/docs/vi/guides/upgrade-to/v5.mdx) và thêm link bên dưới!

## Vấn đề đã biết

Vui lòng kiểm tra [issues của Astro trên GitHub](https://github.com/withastro/astro/issues/) để biết bất kỳ vấn đề nào được báo cáo, hoặc để tự mình file issue.

Nếu bạn đang sử dụng các plugin, cấu hình hoặc API cụ thể của Vite, hãy kiểm tra [hướng dẫn di chuyển Vite](https://vite.dev/guide/migration.html) để biết các thay đổi phá vỡ tương thích và nâng cấp dự án của bạn khi cần.

### `@astrojs/mdx`

<SourcePR number="11741" title="Cleanup unused JSX code"/>

Trong Astro v4.x, Astro thực hiện xử lý JSX nội bộ cho integration `@astrojs/mdx`.

Astro v5.0 chuyển trách nhiệm xử lý và render JSX và MDX trực tiếp cho gói `@astrojs/mdx`. Điều này có nghĩa là Astro 5.0 không còn tương thích với các phiên bản cũ hơn của integration MDX.

#### Tôi nên làm gì?

Nếu dự án của bạn bao gồm các file `.mdx`, bạn phải nâng cấp `@astrojs/mdx` lên phiên bản mới nhất (v4.0.0) để JSX của bạn có thể được xử lý đúng cách bởi integration.

Nếu bạn đang sử dụng MDX server renderer với [Astro Container API](/vi/reference/container-reference/) thử nghiệm, bạn phải cập nhật import để phản ánh vị trí mới:

```ts del={1} ins={2}
import mdxRenderer from "astro/jsx/server.js";
import mdxRenderer from "@astrojs/mdx/server.js";
```

<ReadMore>Tìm hiểu thêm về [sử dụng MDX trong dự án của bạn](/vi/guides/integrations-guide/mdx/).</ReadMore>

## Legacy

Các tính năng sau đây hiện được coi là tính năng legacy. Chúng sẽ hoạt động bình thường nhưng không còn được khuyến nghị và đang ở chế độ bảo trì. Chúng sẽ không có cải tiến trong tương lai và tài liệu sẽ không được cập nhật. Những tính năng này cuối cùng sẽ bị deprecated, rồi bị xóa hoàn toàn.

### Legacy: Content Collections API v2.0

Trong Astro 4.x, content collections được định nghĩa, truy vấn và render bằng [Content Collections API được giới thiệu lần đầu trong Astro v2.0](https://astro.build/blog/introducing-content-collections/). Tất cả các collection entry đều là file cục bộ trong thư mục `src/content/` được dành riêng. Ngoài ra, [quy ước tên file của Astro để loại trừ việc xây dựng các trang riêng lẻ](/vi/guides/routing/#excluding-pages) đã được tích hợp vào Content Collections API.

Astro 5.0 giới thiệu phiên bản mới của content collections sử dụng Content Layer API mang lại một số cải tiến hiệu suất và khả năng bổ sung. Trong khi collections cũ (legacy) và mới (Content Layer API) có thể tiếp tục tồn tại cùng nhau trong bản phát hành này, có những thay đổi có thể phá vỡ tương thích đối với các legacy collections hiện có.

Bản phát hành này cũng xóa tùy chọn để thêm tiền tố tên file collection entry bằng dấu gạch dưới (`_`) để ngăn chặn việc xây dựng route.

#### Tôi nên làm gì?

Chúng tôi khuyến nghị [chuyển đổi bất kỳ collections hiện có nào sang Content Layer API mới](#updating-existing-collections) càng sớm càng tốt và tạo bất kỳ collections mới nào bằng Content Layer API.

Nếu bạn không thể chuyển đổi collections của mình, vui lòng tham khảo [thay đổi phá vỡ tương thích của legacy collections](#breaking-changes-to-legacy-content-and-data-collections) để xem liệu các collections hiện có của bạn có bị ảnh hưởng và yêu cầu cập nhật không.

Nếu bạn không thể thực hiện bất kỳ thay đổi nào đối với collections của mình vào thời điểm này, bạn có thể [bật flag `legacy.collections`](#enabling-the-legacycollections-flag) sẽ cho phép bạn giữ collections ở trạng thái hiện tại cho đến khi legacy flag không còn được hỗ trợ.

<ReadMore>Tìm hiểu thêm về [content collections](/vi/guides/content-collections/) được cập nhật.</ReadMore>

##### Cập nhật collections hiện có

Xem hướng dẫn bên dưới để cập nhật content collection hiện có (`type: 'content'` hoặc `type: 'data'`) để sử dụng Content Layer API.

<details>
<summary>Hướng dẫn từng bước để cập nhật collection</summary>

<Steps>

1. **Di chuyển file config nội dung**. File này không còn nằm trong thư mục `src/content/`. File này giờ đây nên tồn tại tại `src/content.config.ts`.

2. **Chỉnh sửa định nghĩa collection**. Collection cập nhật của bạn yêu cầu một `loader` cho biết cả thư mục cho vị trí collection (`base`) và một `pattern` xác định tên file và phần mở rộng của collection entry để khớp. (Bạn có thể cần cập nhật ví dụ bên dưới cho phù hợp. Bạn có thể sử dụng [globster.xyz](https://globster.xyz/) để kiểm tra glob pattern của mình.) Tùy chọn chọn collection `type` không còn khả dụng.

    ```ts ins={3,8} del={7}
    // src/content.config.ts
    import { defineCollection, z } from 'astro:content';
    import { glob } from 'astro/loaders';

    const blog = defineCollection({
      // Đối với content layer, bạn không còn định nghĩa `type`
      type: 'content',
      loader: glob({ pattern: '**/[^_]*.{md,mdx}', base: "./src/data/blog" }),
      schema: z.object({
        title: z.string(),
        description: z.string(),
        pubDate: z.coerce.date(),
        updatedDate: z.coerce.date().optional(),
      }),
    });
    ```

3. **Thay đổi tham chiếu từ `slug` sang `id`**. Content layer collections không có trường `slug` được dành riêng. Thay vào đó, tất cả các collections được cập nhật sẽ có một `id`:

    ```astro ins={7} del={6}
    // src/pages/[slug].astro
    ---
    export async function getStaticPaths() {
      const posts = await getCollection('blog');
      return posts.map((post) => ({
        params: { slug: post.slug },
        params: { slug: post.id },
        props: post,
      }));
    }
    ---
    ```
    Bạn cũng có thể cập nhật tên file định tuyến động để khớp với giá trị của tham số `getStaticPaths()` đã thay đổi.

4. **Chuyển sang function `render()` mới**. Các entry không còn có method `render()`, vì chúng giờ đây là các plain objects có thể serialize. Thay vào đó, import function `render()` từ `astro:content`.

    ```astro title="src/pages/index.astro" ins=", render" del={6} ins={7}
    ---
    import { getEntry, render } from 'astro:content';

    const post = await getEntry('blog', params.slug);

    const { Content, headings } = await post.render();
    const { Content, headings } = await render(post);
    ---
    <Content />
    ```
</Steps>

</details>

##### Thay đổi phá vỡ tương thích đối với legacy `content` và `data` collections

<SourcePR number="11976" title="Implement legacy collections using glob" />

Theo mặc định, các collections sử dụng thuộc tính `type` cũ (`content` hoặc `data`) và không định nghĩa `loader` giờ đây được triển khai bên dưới bằng cách sử dụng `glob()` loader tích hợp của Content Layer API, với xử lý tương thích ngược bổ sung.

Ngoài ra, tương thích ngược tạm thời tồn tại để giữ file config nội dung ở vị trí ban đầu của `src/content/config.ts`.

Việc triển khai tương thích ngược này có thể mô phỏng hầu hết các tính năng của legacy collections và sẽ cho phép nhiều legacy collections tiếp tục hoạt động ngay cả khi không cập nhật code của bạn. Tuy nhiên, **có một số khác biệt và hạn chế có thể gây ra thay đổi phá vỡ tương thích đối với các collections hiện có**:

  - Trong các phiên bản trước của Astro, collections sẽ được tạo cho tất cả thư mục trong `src/content/`, ngay cả khi chúng không được định nghĩa trong `src/content/config.ts`. Hành vi này hiện đã deprecated, và collections phải luôn được định nghĩa trong `src/content.config.ts`. Đối với các collections hiện có, chúng có thể chỉ là các khai báo trống (ví dụ: `const blog = defineCollection({})`) và Astro sẽ ngầm định nghĩa legacy collection của bạn theo cách tương thích với hành vi loading mới.
  - Trường `layout` đặc biệt không được hỗ trợ trong các collection entry Markdown. Thuộc tính này chỉ dành cho các file trang độc lập nằm trong `src/pages/` và không có khả năng nằm trong collection entries của bạn. Tuy nhiên, nếu bạn đang sử dụng thuộc tính này, bây giờ bạn phải tạo các routes động bao gồm styling trang của bạn.
  - Thứ tự sắp xếp của các collections được tạo là không xác định và phụ thuộc vào nền tảng. Điều này có nghĩa là nếu bạn đang gọi `getCollection()`, thứ tự trả về các entries có thể khác so với trước. Nếu bạn cần một thứ tự cụ thể, bạn phải tự sắp xếp các collection entries.
  - `image().refine()` không được hỗ trợ. Nếu bạn cần xác thực các thuộc tính của hình ảnh, bạn sẽ cần thực hiện điều này tại runtime trong trang hoặc component của mình.
  - Đối số `key` của `getEntry(collection, key)` được typed là `string`, thay vì có types cho mọi entry.
  - Trước đây khi gọi `getEntry(collection, key)` với một chuỗi tĩnh làm key, kiểu trả về không thể nullable. Kiểu giờ đây bao gồm `undefined` nên bạn phải kiểm tra xem entry có được định nghĩa trước khi sử dụng kết quả hay không hoặc bạn sẽ gặp lỗi type.

##### Bật flag `legacy.collections`

<SourcePR number="11976" title="Implement legacy collections using glob" />

Nếu bạn chưa sẵn sàng cập nhật các collections hiện có, bạn có thể bật flag [`legacy.collections`](/vi/reference/legacy-flags/) và các collections hiện có của bạn sẽ tiếp tục hoạt động như trước.

## Deprecated

Các tính năng deprecated sau đây không còn được hỗ trợ và không còn được ghi chép. Vui lòng cập nhật dự án của bạn cho phù hợp.

Một số tính năng deprecated có thể tạm thời tiếp tục hoạt động cho đến khi chúng bị xóa hoàn toàn. Những tính năng khác có thể âm thầm không có tác dụng, hoặc ném ra lỗi nhắc bạn cập nhật code.

### Deprecated: `Astro.glob()`

<SourcePR number="11826" title="Deprecate glob"/>

Trong Astro v4.x, bạn có thể sử dụng `Astro.glob()` trong các component `.astro` để truy vấn nhiều file trong dự án. Điều này có một số hạn chế (nơi có thể sử dụng, hiệu suất, v.v.), và việc sử dụng các function truy vấn từ Content Collections API hoặc `import.meta.glob()` của chính Vite thường cung cấp nhiều function và tính linh hoạt hơn.

Astro 5.0 deprecated `Astro.glob()` ủng hộ việc sử dụng `getCollection()` để truy vấn collections và `import.meta.glob()` để truy vấn các file nguồn khác trong dự án.

#### Tôi nên làm gì?

Thay thế tất cả việc sử dụng `Astro.glob()` bằng `import.meta.glob()`. Lưu ý rằng `import.meta.glob()` không còn trả về `Promise`, vì vậy bạn có thể phải cập nhật code cho phù hợp. Bạn không cần cập nhật [glob patterns](/vi/guides/imports/#glob-patterns).

```astro title="src/pages/blog.astro" del={2} ins={3}
---
const posts = await Astro.glob('./posts/*.md');
const posts = Object.values(import.meta.glob('./posts/*.md', { eager: true }));
---

{posts.map((post) => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}
```

Khi thích hợp, hãy xem xét sử dụng [content collections](/vi/guides/content-collections/) để sắp xếp nội dung của bạn, có các function truy vấn mới hơn, hiệu suất cao hơn.

Bạn cũng có thể muốn xem xét sử dụng các gói glob từ NPM, chẳng hạn như [`fast-glob`](https://www.npmjs.com/package/fast-glob).

<ReadMore>Tìm hiểu thêm về [import files với `import.meta.glob`](/vi/guides/imports/#importmetaglob).</ReadMore>
 
### Deprecated: `functionPerRoute` (Adapter API)

<SourcePR number="11714" title="Remove functionPerRoute option"/>

Trong Astro v4.x, bạn có thể chọn tạo một file riêng cho mỗi route được định nghĩa trong dự án, phản ánh thư mục `src/pages/` của bạn trong thư mục build. Theo mặc định, Astro phát ra một file `entry.mjs` duy nhất, chịu trách nhiệm phát ra trang được render cho mỗi request.

Astro v5.0 xóa tùy chọn opt out khỏi hành vi mặc định. Hành vi này giờ đây là tiêu chuẩn và không thể cấu hình.

Xóa thuộc tính `functionPerRoute` khỏi cấu hình `adapterFeatures` của bạn. Nó không còn khả dụng.

```js title="my-adapter.mjs" del={10}
export default function createIntegration() {
  return {
    name: '@matthewp/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@matthewp/my-adapter',
          serverEntrypoint: '@matthewp/my-adapter/server.js',
          adapterFeatures: {
              functionPerRoute: true
          }
        });
      },
    },
  };
}

```

<ReadMore>Tìm hiểu thêm về [Adapter API](/vi/reference/adapter-reference/) để xây dựng adapter integrations.</ReadMore>

### Deprecated: `routes` trên hook `astro:build:done` (Integration API)

<SourcePR number="12329" title="feat(next): astro:routes:resolved"/>

Trong Astro v4.x, các integration truy cập routes từ hook `astro:build:done`.

Astro v5.0 deprecated mảng `routes` được truyền cho hook này. Thay vào đó, nó expose một hook `astro:routes:resolved` mới chạy trước `astro:config:done`, và bất cứ khi nào route thay đổi trong development. Nó có tất cả các thuộc tính giống như danh sách `routes` deprecated, ngoại trừ `distURL` chỉ khả dụng trong quá trình build.

#### Tôi nên làm gì?

Xóa bất kỳ instance nào của `routes` được truyền cho `astro:build:done` và thay thế bằng hook `astro:routes:resolved` mới. Truy cập `distURL` trên map `assets` mới được expose:

```js title="my-integration.mjs" ins={2,6-8,11,13-18} del={10}
const integration = () => {
    let routes
    return {
        name: 'my-integration',
        hooks: {
            'astro:routes:resolved': (params) => {
                routes = params.routes
            },
            'astro:build:done': ({
                routes
                assets
            }) => {
                for (const route of routes) {
                    const distURL = assets.get(route.pattern)
                    if (distURL) {
                        Object.assign(route, { distURL })
                    }
                }
                console.log(routes)
            }
        }
    }
}
```

<ReadMore>Tìm hiểu thêm về [Integration API hook `astro:routes:resolved`](/vi/reference/integrations-reference/#astroroutesresolved) để xây dựng integrations.</ReadMore>

## Đã xóa

Các tính năng sau đây giờ đây đã được xóa hoàn toàn khỏi codebase và không thể sử dụng được nữa. Một số tính năng này có thể đã tiếp tục hoạt động trong dự án của bạn ngay cả sau khi deprecated. Những tính năng khác có thể đã âm thầm không có tác dụng.

Các dự án hiện chứa những tính năng đã bị xóa này sẽ không thể build, và sẽ không còn có bất kỳ tài liệu hỗ trợ nào nhắc bạn xóa những tính năng này.

### Đã xóa: Integration Lit

<SourcePR number="11680" title="Remove `@astrojs/lit`"/>

Trong Astro v4.x, [Lit](https://lit.dev/) là thư viện framework được duy trì cốt lõi thông qua gói `@astrojs/lit`.

Astro v5.0 xóa integration và nó sẽ không nhận được cập nhật thêm cho tương thích với 5.x trở lên.

#### Tôi nên làm gì?

Bạn có thể tiếp tục sử dụng Lit cho client components bằng cách thêm thẻ script phía client. Ví dụ:

```astro
<script>
  import "../components/MyTabs";
</script>

<my-tabs title="These are my tabs">...</my-tabs>
```

Nếu bạn quan tâm đến việc duy trì integration Lit tự mình, bạn có thể muốn sử dụng [phiên bản được published cuối cùng của `@astrojs/lit`](https://github.com/withastro/astro/tree/astro%404.13.0/packages/integrations/lit) làm điểm khởi đầu và nâng cấp các gói liên quan.

<ReadMore>Tìm hiểu thêm về [integrations chính thức của Astro](/vi/guides/integrations-guide/).</ReadMore>

### Đã xóa: chế độ rendering `hybrid`

<SourcePR number="11824" title="Merge output:hybrid and output:static" />

Trong Astro v4.x, Astro cung cấp ba chế độ rendering `output`: `'static'`, `'hybrid'`, và `'server'`

Astro v5.0 hợp nhất cấu hình `output: 'hybrid'` và `output: 'static'` thành một cấu hình duy nhất (giờ được gọi là `'static'`) hoạt động giống như tùy chọn hybrid trước đây.

Không còn cần thiết phải chỉ định `output: 'hybrid'` trong config Astro để sử dụng các trang server-rendered. `output: 'static'` mới có khả năng này được bao gồm.

Astro giờ đây sẽ tự động cho phép bạn opt out khỏi prerendering trong trang web tĩnh mà không cần thay đổi cấu hình output. Bất kỳ route trang hoặc endpoint nào đều có thể bao gồm `export const prerender = false` để được server-rendered theo yêu cầu, trong khi phần còn lại của trang web được tạo tĩnh.

#### Tôi nên làm gì?

Nếu dự án của bạn sử dụng hybrid rendering, bây giờ bạn phải xóa tùy chọn `output: 'hybrid'` khỏi config Astro vì nó không còn tồn tại. Tuy nhiên, không cần thay đổi khác nào đối với dự án của bạn, và bạn không nên có thay đổi phá vỡ tương thích. Hành vi `'hybrid'` trước đây giờ đây là mặc định, dưới tên mới `'static'`.

```js title="astro.config.mjs" del={4}
import { defineConfig } from "astro/config";

export default defineConfig({
  output: 'hybrid',
});
```

Nếu bạn đang sử dụng tùy chọn `output: 'static'` (mặc định), bạn có thể tiếp tục sử dụng như trước. Theo mặc định, tất cả các trang của bạn sẽ tiếp tục được prerendered và bạn sẽ có một trang web hoàn toàn tĩnh. Bạn không nên có thay đổi phá vỡ tương thích nào đối với dự án của bạn.

Một adapter vẫn được yêu cầu để deploy dự án Astro với bất kỳ trang server-rendered nào, bất kể chế độ `output` nào mà dự án của bạn sử dụng. Việc không bao gồm adapter sẽ dẫn đến cảnh báo trong development và lỗi tại thời điểm build.

<ReadMore>Tìm hiểu thêm về [on-demand rendering trong Astro](/vi/guides/on-demand-rendering/).</ReadMore>

### Đã xóa: hỗ trợ cho giá trị `prerender` động trong routes

<SourcePR number="11824" title="Merge output:hybrid and output:static" />

Trong Astro 4.x, các biến môi trường có thể được sử dụng để thiết lập động giá trị của export `prerender` trong routes, ví dụ `export const prerender = import.meta.env.SOME_VAR`.

Astro v5.0 xóa hỗ trợ cho giá trị động trong export `prerender`. Chỉ các giá trị tĩnh `true` và `false` được hỗ trợ.

#### Tôi nên làm gì?

<Steps>

1. Xóa bất kỳ export `prerender` động nào trong routes của bạn:

    ```astro title="src/pages/blog/[slug].astro" del={2}
    ---
    export const prerender = import.meta.env.SOME_VAR;
    ---
    ```

2. Sử dụng integration Astro trong file `astro.config.mjs` để thiết lập giá trị `prerender` cần động trong hook `"astro:route:setup"`:

    ```js title="astro.config.mjs" {6-19}
    import { defineConfig } from 'astro/config';
    import { loadEnv } from 'vite';

    export default defineConfig({
      integrations: [
        {
          name: 'set-prerender',
          hooks: {
            'astro:route:setup': ({ route }) => {
              // Load environment variables từ file .env (nếu cần)
              const { PRERENDER } = loadEnv(process.env.NODE_ENV, process.cwd(), '');
              // Tìm routes khớp với tên file mong đợi.
              if (route.component.endsWith('/blog/[slug].astro')) {
                // Thiết lập giá trị prerender trên routes khi cần.
                route.prerender = PRERENDER;
              }
            },
          },
        }
      ],
    });
    ```

</Steps>

### Đã xóa: Dịch vụ hình ảnh Squoosh

<SourcePR number="11770" title="remove the squoosh image service"/>

Trong Astro 4.x, bạn có thể cấu hình `image.service: squooshImageService()` để sử dụng Squoosh để biến đổi hình ảnh thay vì Sharp. Tuy nhiên, thư viện cơ bản `libsquoosh` không còn được duy trì và có vấn đề về memory và hiệu suất.

Astro 5.0 xóa hoàn toàn dịch vụ tối ưu hóa hình ảnh Squoosh.

#### Tôi nên làm gì?

Để chuyển sang dịch vụ hình ảnh Sharp tích hợp, hãy xóa import `squooshImageService` khỏi config Astro của bạn. Theo mặc định, bạn sẽ sử dụng Sharp cho `astro:assets`.

```ts title="astro.config.mjs" del={1, 5-7}
import { squooshImageService } from "astro/config";
import { defineConfig } from "astro/config";

export default defineConfig({
 image: {
   service: squooshImageService()
 }
});
```

Nếu bạn đang sử dụng trình quản lý gói nghiêm ngặt như `pnpm`, bạn có thể cần cài đặt gói `sharp` thủ công để sử dụng dịch vụ hình ảnh Sharp, mặc dù nó được tích hợp trong Astro theo mặc định.

Nếu adapter của bạn không hỗ trợ tối ưu hóa hình ảnh Sharp tích hợp của Astro, bạn có thể [cấu hình dịch vụ hình ảnh no-op passthrough](/vi/guides/images/#configure-no-op-passthrough-service) để cho phép bạn sử dụng các component `<Image />` và `<Picture />`.

Ngoài ra, bạn có thể muốn xem xét [dịch vụ hình ảnh Squoosh được duy trì bởi cộng đồng](https://github.com/Princesseuh/astro-image-service-squoosh) nếu bạn không thể sử dụng dịch vụ hình ảnh Sharp.

##### Đối với adapters

Nếu adapter của bạn trước đây chỉ định trạng thái tương thích với Squoosh, bây giờ bạn nên xóa thông tin này khỏi cấu hình adapter.

```js title="my-adapter.mjs" del={2-4}
supportedAstroFeatures: {
  assets: {
    isSquooshCompatible: true
  }
}
```

<ReadMore>Đọc thêm về [cấu hình dịch vụ hình ảnh mặc định](/vi/guides/images/#default-image-service).</ReadMore>

### Đã xóa: một số types công khai

<SourcePR number="11715" title="Refactor/types"/>

Trong Astro v4.x, `@types/astro.ts` expose tất cả types công khai cho người dùng, cho dù chúng có còn được sử dụng tích cực hay chỉ dành cho sử dụng nội bộ.

Astro v5.0 refactor file này để xóa các types lỗi thời và nội bộ. Việc refactor này mang lại cải tiến cho editor của bạn (ví dụ: completions nhanh hơn, sử dụng memory thấp hơn và các tùy chọn completion phù hợp hơn). Tuy nhiên, việc refactor này có thể gây ra lỗi trong một số dự án đã dựa vào các types không còn khả dụng cho công chúng.

#### Tôi nên làm gì?

Xóa bất kỳ types nào hiện gây ra lỗi trong dự án của bạn vì bạn không còn quyền truy cập vào chúng. Đây chủ yếu là các API đã bị deprecated và xóa trước đó, nhưng cũng có thể bao gồm các types hiện là nội bộ.

<ReadMore>Xem [types công khai được expose để sử dụng](https://github.com/withastro/astro/tree/main/packages/astro/src/types/public).</ReadMore>

### Experimental Flags

Các experimental flags sau đây đã được xóa trong Astro v5.0 và những tính năng này có sẵn để sử dụng:

- `env`
- `serverIslands`

Ngoài ra, các experimental flags sau đây đã được xóa và **giờ đây là hành vi mặc định hoặc được khuyến nghị trong Astro v5.0**.

- `directRenderScript` (Xem bên dưới để biết thay đổi phá vỡ tương thích đối với [hành vi `<script>` mặc định](#script-tags-are-rendered-directly-as-declared).)
- `globalRoutePriority` (Xem bên dưới để biết thay đổi phá vỡ tương thích đối với [thứ tự ưu tiên route mặc định](#route-priority-order-for-injected-routes-and-redirects).)
- `contentLayer` (Xem hướng dẫn để [nâng cấp content collections hiện có](#legacy-v20-content-collections-api) sang Content Layer API mới, được ưa thích.)

Các experimental flags sau đây đã được xóa và **các tính năng tương ứng không phải là một phần của Astro v5.0**.

- `contentCollectionsCache`

Xóa những experimental flags này nếu bạn đã sử dụng chúng trước đây, và di chuyển cấu hình `env` của bạn đến root của config Astro:

```js del={5-12} ins={14-16} title="astro.config.mjs"
import { defineConfig } from 'astro/config';

export default defineConfig({
  experimental: {
    directRenderScript: true,
    globalRoutePriority: true,
    contentLayer: true,
    serverIslands: true,
    contentCollectionsCache: true,
    env: {
      schema: {...}
    }
  },
  env: {
      schema: {...}
  }
})
```

Tất cả những tính năng này đều có sẵn theo mặc định trong Astro v5.0.

<ReadMore>Đọc về những tính năng thú vị này và nhiều hơn nữa trong [bài đăng Blog v5.0](https://astro.build/blog/astro-5/).</ReadMore>

## Thay đổi mặc định

Một số hành vi mặc định đã thay đổi trong Astro v5.0 và code dự án của bạn có thể cần cập nhật để phù hợp với những thay đổi này.

Trong hầu hết các trường hợp, hành động duy nhất cần thiết là xem xét deployment dự án hiện có của bạn và đảm bảo rằng nó tiếp tục hoạt động như bạn mong đợi, thực hiện cập nhật code khi cần. Trong một số trường hợp, có thể có cài đặt cấu hình để cho phép bạn tiếp tục sử dụng hành vi mặc định trước đó.

### Bảo vệ CSRF hiện được thiết lập theo mặc định

<SourcePR number="11788" title="change default value of checkOrigin"/>

Trong Astro v4.x, Giá trị mặc định của `security.checkOrigin` là `false`. Trước đây, bạn phải thiết lập rõ ràng giá trị này thành `true` để kích hoạt bảo vệ Cross-Site Request Forgery (CSRF).

Astro v5.0 thay đổi giá trị mặc định của tùy chọn này thành `true`, và sẽ tự động kiểm tra rằng header "origin" khớp với URL được gửi bởi mỗi request trong các trang rendered theo yêu cầu.

#### Tôi nên làm gì?

Nếu bạn đã cấu hình `security.checkOrigin: true` trước đây, bạn không còn cần dòng này trong config Astro. Đây giờ đây là mặc định.

Để vô hiệu hóa hành vi này, bạn phải thiết lập rõ ràng `security.checkOrigin: false`.

```js title="astro.config.mjs" ins={3-5}
export default defineConfig({
  output: "server",
  security: {
    checkOrigin: false
  }
})
```

<ReadMore>Đọc thêm về [tùy chọn cấu hình bảo mật](/vi/reference/configuration-reference/#security)</ReadMore>

### Thứ tự ưu tiên route cho injected routes và redirects

<SourcePR number="11798" title="Remove legacy route prioritization"/>

Trong Astro v4.x, `experimental.globalRoutePriority` là một flag tùy chọn đảm bảo rằng injected routes, file-based routes và redirects đều được ưu tiên bằng cách sử dụng [quy tắc thứ tự ưu tiên route cho tất cả routes](/vi/guides/routing/#route-priority-order). Điều này cho phép kiểm soát nhiều hơn việc định tuyến trong dự án của bạn bằng cách không tự động ưu tiên các loại routes nhất định và tiêu chuẩn hóa thứ tự ưu tiên route.

Astro v5.0 xóa experimental flag này và làm đây là hành vi mặc định mới trong Astro: redirects và injected routes giờ đây được ưu tiên bằng nhau cùng với file-based project routes.

Lưu ý rằng đây đã là hành vi mặc định trong Starlight, và không nên ảnh hưởng đến các dự án Starlight đã cập nhật.

#### Tôi nên làm gì?

Nếu dự án của bạn bao gồm injected routes hoặc redirects, vui lòng kiểm tra rằng routes của bạn đang xây dựng URL trang như mong đợi. Một ví dụ về hành vi mới mong đợi được hiển thị bên dưới.

Trong một dự án chứa các routes sau:

- File-based route: `/blog/post/[pid]`
- File-based route: `/[page]`
- Injected route: `/blog/[...slug]`
- Redirect: `/blog/tags/[tag] -> /[tag]`
- Redirect: `/posts -> /blog`

Các URL sau sẽ được xây dựng (thay vì theo thứ tự ưu tiên route của Astro v4.x):

- `/blog/tags/astro` được xây dựng bởi redirect đến `/tags/[tag]` (thay vì injected route `/blog/[...slug]`)
- `/blog/post/0` được xây dựng bởi file-based route `/blog/post/[pid]` (thay vì injected route `/blog/[...slug]`)
- `/posts` được xây dựng bởi redirect đến `/blog` (thay vì file-based route `/[page]`)

Trong trường hợp route conflicts, nơi hai routes có thứ tự ưu tiên bằng nhau cố gắng xây dựng cùng một URL, Astro sẽ log cảnh báo xác định các routes xung đột.

<ReadMore>Đọc thêm về [quy tắc thứ tự ưu tiên route](/vi/guides/routing/#route-priority-order).</ReadMore>

### Thẻ `<script>` được render trực tiếp như đã khai báo

<SourcePR number="11791" title="Make directRenderScript the default"/>

Trong Astro v4.x, `experimental.directRenderScript` là một flag tùy chọn để render trực tiếp `<scripts>` như đã khai báo trong file `.astro` (bao gồm các tính năng hiện có như TypeScript, import `node_modules`, và deduplicate scripts). Chiến lược này ngăn các scripts được thực thi ở những nơi chúng không được sử dụng. Ngoài ra, các scripts được render có điều kiện trước đây được ngầm inlined, như thể một directive `is:inline` được tự động thêm vào chúng.

Astro 5.0 xóa experimental flag này và làm đây là hành vi mặc định mới trong Astro: scripts không còn được hoisted lên `<head>`, nhiều scripts trên một trang không còn được bundle cùng nhau, và thẻ `<script>` có thể can thiệp vào CSS styling. Ngoài ra, các scripts được render có điều kiện không còn được ngầm inlined.

#### Tôi nên làm gì?

Vui lòng xem xét các thẻ `<script>` của bạn và đảm bảo chúng hoạt động như mong muốn.

Nếu bạn trước đây có các thẻ `<script>` được render có điều kiện, bạn sẽ cần thêm thuộc tính `is:inline` để bảo tồn hành vi giống như trước:

```astro title="src/components/MyComponent.astro" ins="is:inline"
---
type Props = {
  showAlert: boolean
}

const { showAlert } = Astro.props;
---
{
  showAlert && <script is:inline>alert("Some very important code!!")</script>
}
```

<ReadMore>Đọc thêm về [sử dụng thẻ `script` trong Astro](/vi/guides/client-side-scripts/#using-script-in-astro).</ReadMore>

## Thay đổi phá vỡ tương thích

Các thay đổi sau đây được coi là thay đổi phá vỡ tương thích trong Astro v5.0. Thay đổi phá vỡ tương thích có thể hoặc không cung cấp tương thích ngược tạm thời. Nếu bạn đang sử dụng những tính năng này, bạn có thể phải cập nhật code như được khuyến nghị trong mỗi mục.

### Đổi tên: Component `<ViewTransitions />`

<SourcePR number="11980" title="Rename the ViewTransitions component to ClientRouter"/>

Trong Astro 4.x, View Transitions API của Astro bao gồm một component router `<ViewTransitions />` để kích hoạt client-side routing, page transitions, và nhiều hơn nữa.

Astro 5.0 đổi tên component này thành `<ClientRouter />` để làm rõ vai trò của component trong API. Điều này làm cho rõ ràng hơn rằng các tính năng bạn nhận được từ component routing `<ClientRouter />` của Astro hơi khác so với native CSS-based MPA router.

Không có chức năng nào thay đổi. Component này chỉ thay đổi tên.

#### Tôi nên làm gì?

Thay thế tất cả các lần xuất hiện của import và component `ViewTransitions` bằng `ClientRouter`:

```astro title="src/layouts/MyLayout.astro" del={1,7} ins={2,8}
import { ViewTransitions } from 'astro:transitions';
import { ClientRouter } from 'astro:transitions';

<html>
  <head>
    ...
   <ViewTransitions />
   <ClientRouter />
  </head>
</html>
```

<ReadMore>Đọc thêm về [view transitions và client-side routing trong Astro](/vi/guides/view-transitions/).</ReadMore>

### Thay đổi: Cấu hình TypeScript

<SourcePR number="11859" title="better tsconfig"/>

Trong Astro v4.x, Astro dựa vào file `src/env.d.ts` cho type inferencing và định nghĩa modules cho các tính năng dựa vào generated types.

Astro 5.0 thay vào đó sử dụng file `.astro/types.d.ts` cho type inferencing, và giờ đây khuyến nghị thiết lập `include` và `exclude` trong `tsconfig.json` để hưởng lợi từ các types Astro và tránh kiểm tra các file đã build.

Chạy `astro sync` không còn tạo, cũng không cập nhật, `src/env.d.ts` vì nó không được yêu cầu để type-checking các dự án Astro tiêu chuẩn.

#### Tôi nên làm gì?

Để cập nhật dự án của bạn lên cài đặt TypeScript được khuyến nghị của Astro, hãy thêm các thuộc tính `include` và `exclude` sau vào `tsconfig.json` hiện có của bạn:

```ts ins={3,4} title="tsconfig.json"
{
  "extends": "astro/tsconfigs/base",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"]
}
```

Lưu ý rằng `src/env.d.ts` chỉ cần thiết nếu bạn đã thêm cấu hình tùy chỉnh, hoặc nếu bạn không sử dụng file `tsconfig.json`.

<ReadMore>Đọc thêm về [cấu hình TypeScript trong Astro](/vi/guides/typescript/#setup).</ReadMore>

### Thay đổi: Actions được submit bởi HTML forms không còn sử dụng cookie redirects

<SourcePR number="12373" title="Actions middleware"/>

Trong Astro 4.x, actions được gọi từ HTML form sẽ kích hoạt redirect với kết quả được chuyển tiếp bằng cookies. Điều này gây ra vấn đề cho các form errors lớn và return values vượt quá giới hạn 4 KB của cookie-based storage.

Astro 5.0 giờ đây render kết quả của action như một kết quả POST mà không có bất kỳ forwarding nào. Điều này sẽ giới thiệu hộp thoại "confirm form resubmission?" khi người dùng cố gắng refresh trang, mặc dù nó không còn áp đặt giới hạn 4 KB trên action return value.

#### Tôi nên làm gì?

Bạn nên cập nhật xử lý cho kết quả action dựa vào redirects, và tùy chọn giải quyết hộp thoại "confirm form resubmission?" với middleware.

##### Để redirect đến route trước đó khi có lỗi

Nếu HTML form action của bạn được hướng đến một route khác (tức là `action={"/success-page" + actions.name}`), Astro sẽ không còn redirect đến route trước đó khi có lỗi. Bạn có thể triển khai hành vi này thủ công bằng cách sử dụng redirects từ component Astro của bạn. Ví dụ này thay vào đó redirect đến một route mới khi thành công, và xử lý errors trên trang hiện tại nếu không:

```astro title="src/pages/newsletter.astro" ins={4-9} del="'/confirmation' + "
---
import { actions } from 'astro:actions';

const result = Astro.getActionResult(actions.newsletter);
if (!result?.error) {
  // Nhúng dữ liệu kết quả liên quan vào URL nếu cần
  // ví dụ: redirect(`/confirmation?email=${result.data.email}`);
  return redirect('/confirmation');
}
---

<form method="POST" action={'/confirmation' + actions.newsletter}>
  <label>E-mail <input required type="email" name="email" /></label>
  <button>Sign up</button>
</form>
```

##### (Tùy chọn) Để xóa confirm dialog khi refresh

Để giải quyết hộp thoại "confirm form resubmission?" khi refresh, hoặc để bảo tồn kết quả action qua các sessions, bây giờ bạn có thể [tùy chỉnh xử lý kết quả action từ middleware](/vi/guides/actions/#advanced-persist-action-results-with-a-session).

Chúng tôi khuyến nghị sử dụng session storage provider [như được mô tả trong ví dụ Netlify Blob của chúng tôi](/vi/guides/actions/#advanced-persist-action-results-with-a-session). Tuy nhiên, nếu bạn thích hành vi cookie forwarding từ 4.X và chấp nhận giới hạn kích thước 4 KB, bạn có thể triển khai pattern như được hiển thị trong đoạn mã mẫu này:

```ts title="src/middleware.ts"
import { defineMiddleware } from 'astro:middleware';
import { getActionContext } from 'astro:actions';

export const onRequest = defineMiddleware(async (context, next) => {
  // Bỏ qua requests cho các trang prerendered
  if (context.isPrerendered) return next();

	const { action, setActionResult, serializeActionResult } = getActionContext(context);

	// Nếu kết quả action được chuyển tiếp như một cookie, thiết lập kết quả
	// để có thể truy cập từ `Astro.getActionResult()`
	const payload = context.cookies.get('ACTION_PAYLOAD');
	if (payload) {
		const { actionName, actionResult } = payload.json();
		setActionResult(actionName, actionResult);
		context.cookies.delete('ACTION_PAYLOAD');
		return next();
	}

	// Nếu action được gọi từ HTML form action,
	// gọi action handler và redirect với kết quả như một cookie.
	if (action?.calledFrom === 'form') {
		const actionResult = await action.handler();

		context.cookies.set('ACTION_PAYLOAD', {
			actionName: action.name,
			actionResult: serializeActionResult(actionResult),
		});

		if (actionResult.error) {
		// Redirect về trang trước đó khi có lỗi
			const referer = context.request.headers.get('Referer');
			if (!referer) {
				throw new Error('Internal: Referer unexpectedly missing from Action POST request.');
			}
			return context.redirect(referer);
		}
		// Redirect đến trang đích khi thành công
		return context.redirect(context.originPathname);
	}

	return next();
})
```

### Thay đổi: `compiledContent()` giờ đây là một async function

<SourcePR number="11782" title="Remove TLA by making compiledContent async"/>

Trong Astro 4.x, top level await được bao gồm trong các Markdown modules. Điều này gây ra một số vấn đề với custom image services và images bên trong Markdown, khiến Node đột ngột thoát mà không có thông báo lỗi.

Astro 5.0 làm cho thuộc tính `compiledContent()` trên Markdown import trở thành một async function, yêu cầu một `await` để resolve nội dung.

#### Tôi nên làm gì?

Cập nhật code của bạn để sử dụng `await` khi gọi `compiledContent()`.

```astro title="src/pages/post.astro" del={4} ins={5}
---
import * as myPost from "../blog/post.md";

const content = myPost.compiledContent();
const content = await myPost.compiledContent();
---

<Fragment set:html={content} />
```

<ReadMore>Đọc thêm về [function `compiledContent()`](/vi/guides/markdown-content/#importing-markdown) để trả về compiled Markdown.</ReadMore>

### Thay đổi: `astro:content` không thể được sử dụng trên client nữa

<SourcePR number="11827" title="Prevent usage of `astro:content` in the client "/>

Trong Astro 4.x, có thể truy cập module `astro:content` trên client.

Astro 5.0 xóa quyền truy cập này vì nó không bao giờ được cố ý expose để sử dụng client. Sử dụng `astro:content` theo cách này có hạn chế và làm phình to client bundles.

#### Tôi nên làm gì?

Nếu bạn hiện đang sử dụng `astro:content` trong client, hãy truyền dữ liệu bạn cần thông qua props cho client components của bạn thay vào đó:

```astro title="src/pages/blog.astro"
---
import { getCollection } from 'astro:content';
import ClientComponent from '../components/ClientComponent';

const posts = await getCollection('blog');
const postsData = posts.map(post => post.data);
---

<ClientComponent posts={postsData} />
```

<ReadMore>Đọc thêm về [API `astro:content`](/vi/reference/modules/astro-content/).</ReadMore>

### Đổi tên: Tên token màu theme Shiki `css-variables`

<SourcePR number="11661" title="Update to new shiki token names"/>

Trong Astro v4.x, theme Shiki `css-variables` sử dụng các tokens `--astro-code-color-text` và `--astro-code-color-background` để styling foreground và background colors của code blocks tương ứng.

Astro v5.0 đổi tên chúng thành `--astro-code-foreground` và `--astro-code-background` tương ứng để căn chỉnh tốt hơn với các mặc định Shiki v1.

#### Tôi nên làm gì?

Bạn có thể thực hiện tìm và thay thế toàn cục trong dự án của mình để di chuyển sang tên token mới.

```css title="src/styles/global.css" del={2,3} ins={4,5}
:root {
  --astro-code-color-text: #000;
  --astro-code-color-background: #fff;
  --astro-code-foreground: #000;
  --astro-code-background: #fff;
}
```

<ReadMore>Đọc thêm về [syntax highlighting trong Astro](/vi/guides/syntax-highlighting/).</ReadMore>

### Thay đổi: plugin rehype Shiki nội bộ để highlighting code blocks

<SourcePR number="11825" title="Refactor createShikiHighlighter"/>

Trong Astro 4.x, plugin rehype Shiki nội bộ của Astro highlighted code blocks như HTML.

Astro 5.0 cập nhật plugin này để highlight code blocks như hast. Điều này cho phép xử lý Markdown và MDX trực tiếp hơn và cải thiện hiệu suất khi building dự án. Tuy nhiên, điều này có thể gây ra vấn đề với các Shiki transformers hiện có.

## Các Issues đã biết

Vui lòng kiểm tra [Các vấn đề của Astro trên GitHub](https://github.com/withastro/astro/issues/) các vấn đề đã được báo cáo, hoặc bạn cũng có thể tự gửi.
