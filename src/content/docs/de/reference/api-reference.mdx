---
title: API-Referenz
i18nReady: true
---
import Since from '~/components/Since.astro'
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'



## `Astro` Global

Das Global `Astro` ist in allen Kontexten in `.astro`-Dateien verf√ºgbar. Es hat die folgenden Funktionen:

### `Astro.glob()`

mit `Astro.glob()` kannst du lokale Dateien in dein statisches Website-Setup laden.

```astro
---
// ./src/components/my-component.astro
const posts = await Astro.glob('../pages/post/*.md'); // gibt ein Array von Posts zur√ºck, die sich unter ./src/pages/post/*.md befinden
themes---

<div>
{posts.slice(0, 3).map((post) => (
  <article>
    <h2>{post.frontmatter.title}</h2>
    <p>{post.frontmatter.description}</p>
    <a href={post.url}>Read more</a>
  </article>
))}
</div>
```

`glob()` ben√∂tigt nur einen Parameter: einen relativen URL-Glob der lokalen Dateien, die du importieren m√∂chtest. Die Funktion arbeitet asynchron und gibt ein Array mit den Exporten der passenden Dateien zur√ºck.

`.glob()` kann keine Variablen oder Strings annehmen, die sie interpolieren, da sie nicht statisch analysierbar sind. (Siehe [die Anleitung zur Fehlerbehebung](/de/guides/troubleshooting/#unterst√ºtzte-werte) f√ºr einen Workaround) Das liegt daran, dass `Astro.glob()` ein Wrapper von Vite's [`import.meta.glob()`](https://vitejs.dev/guide/features.html#glob-import) ist.

:::note
Du kannst auch `import.meta.glob()` selbst in deinem Astro-Projekt verwenden. Du solltest dies tun, wenn:
- Du brauchst diese Funktion in einer Datei, die nicht `.astro` ist, wie zum Beispiel eine API-Route. astro.glob() ist nur in Astro-Dateien verf√ºgbar, w√§hrend import.meta.glob() √ºberall im Projekt verf√ºgbar ist.
- Du willst nicht jede Datei sofort laden. Die Funktion `import.meta.glob()` kann Funktionen zur√ºckgeben, die den Inhalt der Datei importieren, anstatt den Inhalt selbst zur√ºckzugeben.
- Du willst Zugriff auf den Pfad jeder Datei. Die Funktion `import.meta.glob()` gibt eine Abbildung des Dateipfads auf den Inhalt zur√ºck, w√§hrend `Astro.glob()` eine Liste des Inhalts zur√ºckgibt.
- Du m√∂chtest mehrere Pattern √ºbergeben; zum Beispiel m√∂chtest du ein "negatives Muster" hinzuf√ºgen, das bestimmte Dateien herausfiltert. die Funktion `import.meta.glob()` kann optional ein Array von glob-Zeichenfolgen entgegennehmen, anstatt einer einzelnen Zeichenfolge.

Mehr dazu findest du in der [Vite-Dokumentation] (https://vitejs.dev/guide/features.html#glob-import).
:::
#### Markdown-Dateien

Markdown-Dateien haben die folgende Schnittstelle:

```ts
export interface MarkdownInstance<T extends Record<string, any>> {
  /* Alle Daten, die im YAML-Frontmatter dieser Datei angegeben sind */
	frontmatter: T;
  /* Der Dateipfad f√ºr diese Datei */
	file: string;
  /* Der gerenderte Pfad zu dieser Datei */
	url: string | undefined;
  /* Astro-Komponente, die den Inhalt dieser Datei wiedergibt */
	Content: AstroComponent;
  /* Funktion, die ein Array mit den h1...h6-Elementen in dieser Datei zur√ºckgibt */
	getHeadings(): Promise<{ depth: number; slug: string; text: string }[]>;
}
```

Du kannst optional einen Typ f√ºr die Variable "frontmatter" angeben, indem du eine TypeScript-Generik verwendest.

```astro
---
interface Frontmatter {
  title: string;
  description?: string;
}
const posts = await Astro.glob<Frontmatter>('../pages/post/*.md');
---

<ul>
  {posts.map(post => <li>{post.frontmatter.title}</li>)}
</ul>
```

#### Astro-Dateien

Astro-Dateien haben die folgende Schnittstelle:

```ts
export interface AstroInstance {
  /* Der Dateipfad f√ºr diese Datei */
  file: string;
  /* Die URL f√ºr diese Datei (wenn sie sich im Seitenverzeichnis befindet) */
	url: string | undefined;
	default: AstroComponent;
}
```

#### Andere Dateien

Andere Dateien k√∂nnen verschiedene Schnittstellen haben, aber `Astro.glob()` akzeptiert eine TypeScript-Generik, wenn du genau wei√üt, was ein nicht erkannter Dateityp enth√§lt.

```ts
---
interface CustomDataFile {
  default: Record<string, any>;
}
const data = await Astro.glob<CustomDataFile>('../data/**/*.js');
---
```

### `Astro.props`

`Astro.props` ist ein Objekt, das alle Werte enth√§lt, die als [Komponentenattribute] √ºbergeben wurden (/de/core-concepts/astro-components/#component-props). Layoutkomponenten f√ºr `.md` und `.mdx`-Dateien erhalten Frontmatter-Werte als Props.

```astro {3}
---
// ./src/components/Heading.astro
const { title, date } = Astro.props;
---
<div>
  <h1>{title}</h1>
  <p>{date}</p>
</div>
```

```astro /title=".+"/ /date=".+"/
---
// ./src/pages/index.astro
import Heading from '../components/Heading.astro';
---
<Heading title="Mein erster Beitrag" date="09 Aug 2022" />
```

üìö Erfahre mehr dar√ºber, wie [Markdown und MDX Layouts](/de/guides/markdown-content/#frontmatter) mit Eigenschaften umgehen.

üìö Lerne, wie du [TypeScript-Typdefinitionen f√ºr deine Eigenschaften](/de/guides/typescript/#komponenten-eigenschaften) hinzuf√ºgst.

### `Astro.params`

`Astro.params` ist ein Objekt, das die Werte der dynamischen Routensegmente enth√§lt, die f√ºr diese Anfrage angepasst wurden.

Bei statischen Builds sind dies die `Parameter`, die von `getStaticPaths()` zur√ºckgegeben und f√ºr das Prerendering von [dynamischen Routen](/de/core-concepts/routing/#dynamische-routen) verwendet werden.

Bei SSR-Builds kann dies ein beliebiger Wert sein, der den Pfadsegmenten im dynamischen Routenmuster entspricht.

```astro title="src/pages/posts/[id].astro"
---
export function getStaticPaths() {
  return [
    { params: { id: '1' } },
    { params: { id: '2' } },
    { params: { id: '3' } }
  ];
}

const { id } = Astro.params;
---
<h1>{id}</h1>
```

Siehe auch: [`params`](#params)

### `Astro.request`

`Astro.request` ist ein Standard-[Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) Objekt. Es kann verwendet werden, um die `url`, den `header`, die `method` und sogar den Body der Anfrage zu erhalten.

```astro
<p>Empfang einer {Astro.request.method} Anfrage an "{Astro.request.url}".</p>
<p>Empfangene Anfrage-Header:<code>{JSON.stringify(Object.fromEntries(Astro.request.headers))}</code>
```

Siehe auch: [`Astro.url`](#astrourl)

:::note
Mit der Standardoption `output: 'static'`-Option enth√§lt `Astro.request.url` keine Suchparameter, wie z.B. `?foo=bar`, da es nicht m√∂glich ist, diese bei statischen Builds im Voraus zu bestimmen. Im Modus `output: 'server'`-Modus enth√§lt die Option `Astro.request.url` Suchparameter, da sie aus einer Serveranfrage ermittelt werden k√∂nnen.
:::

### `Astro.response`

`Astro.response` ist ein Standard-[ResponseInit](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#init)-Objekt. Es wird verwendet, um den `status`, den `statusText` und die `heading` f√ºr die Antwort einer Seite zu setzen.

```astro
---
if(condition) {
  Astro.response.status = 404;
  Astro.response.statusText = 'Not found';
}
---
```

Oder um einen Header zu setzen:

```astro
---
Astro.response.headers.set('Set-Cookie', 'a=b; Path=/;');
---
```

### `Astro.cookies`

<Since v="1.4.0" />

`Astro.cookies` enth√§lt Helfer zum Lesen und Bearbeiten von Cookies im Modus [Server-Side-Rendering](/de/guides/server-side-rendering/).

| Name | Typ | Beschreibung |
| :------------- | :------------------------------------------------ | :------------------------------------------------- |
| `get`          | `(key: string) => AstroCookie`                       | Holt das Cookie als [`AstroCookie`](#astrocookie)-Objekt, das den `Wert` und Hilfsfunktionen zur Umwandlung des Cookies in Nicht-String-Typen enth√§lt.          |
| `has`          | `(key: string) => boolean`                       | Ob dieses Cookie existiert. Wenn das Cookie √ºber `Astro.cookies.set()` gesetzt wurde, wird hier true zur√ºckgegeben, andernfalls werden die Cookies in `Astro.request` √ºberpr√ºft.          |
| `set`       | `(key: string, value: string \| number \| boolean \| object, options?: CookieOptions) => void` | Setzt den Cookie `key` auf den angegebenen Wert. Dabei wird versucht, den Cookie-Wert in eine Zeichenkette umzuwandeln. Optionen bieten M√∂glichkeiten, [Cookie-Funktionen](https://www.npmjs.com/package/cookie#options-1) zu setzen, wie z. B. `maxAge` oder `htpOnly`.   |
| `delete`       | `(key: string, options?: CookieDeleteOptions) => void` | Markiert das Cookie als gel√∂scht. Sobald ein Cookie gel√∂scht ist, gibt `Astro.cookies.has()` den Wert `false` und `Astro.cookies.get()` einen [`AstroCookie`](#astrocookie) mit einem `Wert` von `undefined` zur√ºck. Mit den Optionen k√∂nnen die `Domain` und der `Pfad` des zu l√∂schenden Cookies festgelegt werden. |
| `headers`       | `() => Iterator<string>` | ermittelt die header-Werte f√ºr "Set-Cookie", die mit der Antwort gesendet werden.   |


#### `AstroCookie`

Das Abrufen eines Cookies √ºber `Astro.cookies.get()` liefert einen Typ `AstroCookie`. Er hat die folgende Struktur.

| Name           | Type                                              | Description                                        |
| :------------- | :------------------------------------------------ | :------------------------------------------------- |
| `value`          | `string`                       | Der eigentliche String-Wert des Cookies.          |
| `json`          | `() => Record<string, any>`                       | Analysiert den Cookie-Wert mit `JSON.parse()` und gibt ein Objekt zur√ºck. Wirft einen Fehler, wenn der Cookie-Wert kein g√ºltiges JSON ist.         |
| `number`       | `() => number` | Analysiert den Cookie-Wert als Zahl. Gibt NaN zur√ºck, wenn es sich nicht um eine g√ºltige Zahl handelt.   |
| `boolean`       | `() => boolean` | Wandelt den Cookie-Wert in einen booleschen Wert um.   |

### `Astro.redirect()`
Im Modus [server-side-rendering](/de/guides/server-side-rendering/) kannst du mit `Astro.redirect()` zu einer anderen Seite umleiten.
Eine Seite (und nicht eine untergeordnete Komponente) muss das Ergebnis von `Astro.redirect()" zur√ºckgeben, damit die Umleitung erfolgt.

```astro title="src/pages/account.astro" {8}
---
import { isLoggedIn } from '../utils';

const cookie = Astro.request.headers.get('cookie');

// Wenn der Benutzer nicht eingeloggt ist, leite ihn zur Anmeldeseite um
if (!isLoggedIn(cookie)) {
  return Astro.redirect('/login');
}
---
```

### `Astro.canonicalURL`

:::caution[Deprecated]
Verwende [`Astro.url`](#astrourl), um deine eigene kanonische URL zu erstellen.
:::

Die [kanonische URL][canonical] der aktuellen Seite.

### `Astro.url`

<Since v="1.0.0-rc" />

Ein [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL)-Objekt, das aus dem aktuellen `Astro.request.url`-URL-String-Wert erstellt wird. N√ºtzlich f√ºr die Interaktion mit einzelnen Eigenschaften der Anfrage-URL, wie Pfadname und Herkunft.

Das ist gleichbedeutend mit `neue URL(Astro.request.url)`.

```astro
<h1>Die aktuelle URL ist: {Astro.url}</h1>
<h1>Der aktuelle URL-Pfadname ist: {Astro.url.pathname}</h1>
<h1>Der aktuelle URL-Ursprung ist: {Astro.url.origin}</h1>
```

Du kannst auch `Astro.url` verwenden, um neue URLs zu erstellen, indem du es als Argument an [`neue URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL) √ºbergibst.

```astro
---
// Beispiel: Erstelle eine kanonische URL mit deiner Produktionsdomain
const canonicalURL = new URL(Astro.url.pathname, Astro.site);
// Beispiel: Konstruiere eine URL f√ºr SEO-Meta-Tags unter Verwendung deiner aktuellen Domain
const socialImageURL = new URL('/images/preview.png', Astro.url);
---
<link rel="canonical" href={canonicalURL} />
<meta property="og:image" content={socialImageURL} />
```

### `Astro.clientAddress`

<Since v="1.0.0-rc" />

Gibt die [IP-Adresse](https://en.wikipedia.org/wiki/IP_address) der Anfrage an. Diese Eigenschaft ist nur bei der Erstellung f√ºr SSR (Server-seitiges Rendering) verf√ºgbar und sollte nicht f√ºr statische Websites verwendet werden.

```astro
---
const ip = Astro.clientAddress;
---

<div>Deine IP-Adresse lautet: <span class="address">{ ip }</span></div>
```

### `Astro.site`

`Astro.site` gibt eine URL zur√ºck, die aus `site` in deiner Astro-Konfiguration stammt. Wenn `site` in deiner Astro-Konfiguration nicht definiert ist, wird `Astro.site` auch nicht definiert.

### `Astro.generator`

<Since v="1.0.0" />

Mit `Astro.generator` kannst du bequem ein [`<meta name="generator">`](https://html.spec.whatwg.org/multipage/semantics.html#meta-generator)-Tag mit deiner aktuellen Astro-Version hinzuf√ºgen. Es hat das Format "Astro v1.x.x".

```astro mark="Astro.generator"
<html>
  <head>
    <meta name="generator" content={Astro.generator} />
  </head>
  <body>
    <footer>
      <p>Built with <a href="https://astro.build">{Astro.generator}</a></p>
    </footer>
  </body>
</html>
```

### `Astro.slots`

`Astro.slots` enth√§lt Funktionen, mit denen du die Slot-Kinder einer Astro-Komponente √§ndern kannst.

#### `Astro.slots.has()`

**Type:** `(slotName: string) => boolean`

Mit `Astro.slots.has()` kannst du pr√ºfen, ob Inhalte f√ºr einen bestimmten Slot-Namen existieren. Das kann n√ºtzlich sein, wenn du Slot-Inhalte wrappen willst, aber die Wrapper-Elemente nur dann darstellen willst, wenn der Slot verwendet wird.

```astro
---
---
<slot />

{Astro.slots.has('more') && (
  <aside>
    <h2>More</h2>
    <slot name="more" />
  </aside>
)}
```

#### `Astro.slots.render()`

**Type:** `(slotName: string, args?: any[]) => Promise<string>`

Du kannst den Inhalt eines Slots asynchron mit `Astro.slots.render()` in eine HTML-Zeichenkette umwandeln.

```astro
---
const html = await Astro.slots.render('default');
---
<Fragment set:html={html} />
```

:::note
Dies ist f√ºr fortgeschrittene Anwendungsf√§lle! In den meisten F√§llen ist es einfacher, Slot-Inhalte mit dem [Element `<Slot />`](/de/core-concepts/astro-components/#slots) darzustellen.
:::

`Astro.slots.render()` akzeptiert optional ein zweites Argument: ein Array von Parametern, die an alle untergeordneten Funktionen weitergeleitet werden. Dies kann f√ºr benutzerdefinierte Hilfskomponenten n√ºtzlich sein.

Zum Beispiel wandelt diese `<Shout />`-Komponente ihre `Nachricht` in Gro√übuchstaben um und √ºbergibt sie an den Standard-Slot:

```astro title="src/components/Shout.astro" "await Astro.slots.render('default', [message])"
---
const message = Astro.props.message.toUpperCase();
let html = '';
if (Astro.slots.has('default')) {
  html = await Astro.slots.render('default', [message]);
}
---
<Fragment set:html={html} />
```

Eine Callback-Funktion, die als Kind von `<Shout />` √ºbergeben wird, erh√§lt den Parameter `Nachricht` in Gro√übuchstaben:

```astro title="src/pages/index.astro"
---
import Shout from "../components/Shout.astro";
---
<Shout message="slots!">
  {(message) => <div>{message}</div>}
</Shout>

<!-- renders as <div>SLOTS!</div> -->
```

### `Astro.self`

Mit `Astro.self` k√∂nnen Astro-Komponenten rekursiv aufgerufen werden. Mit diesem Verhalten kannst du eine Astro-Komponente aus sich selbst heraus rendern, indem du `<Astro.self>` in der Komponentenvorlage verwendest. Dies kann bei der Iteration √ºber gro√üe Datenspeicher und verschachtelte Datenstrukturen hilfreich sein.

```astro
---
// NestedList.astro
const { items } = Astro.props;
---
<ul class="nested-list">
  {items.map((item) => (
    <li>
      <!-- Wenn es eine verschachtelte Datenstruktur gibt, rendern wir `<Astro.self>` -->
      <!-- und k√∂nnen Eigenschaften mit dem rekursiven Aufruf durchreichen -->
      {Array.isArray(item) ? (
        <Astro.self items={item} />
      ) : (
        item
      )}
    </li>
  ))}
</ul>
```

Diese Komponente k√∂nnte dann wie folgt verwendet werden:

```astro
---
import NestedList from './NestedList.astro';
---
<NestedList items={['A', ['B', 'C'], 'D']} />
```

Und w√ºrde HTML wie folgt darstellen werden:

```html
<ul class="nested-list">
  <li>A</li>
  <li>
    <ul class="nested-list">
      <li>B</li>
      <li>C</li>
    </ul>
  </li>
  <li>D</li>
</ul>
```

## Endpunkt-Kontext

Die [Endpunktfunktionen](/de/core-concepts/endpoints/) erhalten ein Kontextobjekt als ersten Parameter. Es spiegelt viele der globalen Eigenschaften von `Astro` wider.

```ts title="endpoint.json.ts"
import type { APIContext } from 'astro';

export function get(context: APIContext) {
  // ...
}
```

### `context.params`

`context.params` ist ein Objekt, das die Werte der dynamischen Routensegmente enth√§lt, die f√ºr diese Anfrage angepasst wurden.

Bei statischen Builds sind dies die `Parameter`, die von `getStaticPaths()` zur√ºckgegeben und f√ºr das Prerendering von [dynamischen Routen](/de/core-concepts/routing/#dynamische-routen) verwendet werden.

Bei SSR-Builds kann dies ein beliebiger Wert sein, der den Pfadsegmenten im dynamischen Route-Pattern entspricht.

```ts title="src/pages/posts/[id].json.ts"
import type { APIContext } from 'astro';

export function getStaticPaths() {
  return [
    { params: { id: '1' } },
    { params: { id: '2' } },
    { params: { id: '3' } }
  ];
}

export function get({ params }: APIContext) {
	return {
		body: JSON.stringify({ id: params.id })
	};
}
```

Siehe auch: [`params`](#params)

### `context.props`

`context.props` ist ein Objekt, das alle `props` enth√§lt, die von `getStaticPaths()` √ºbergeben werden. Da `getStaticPaths()` bei der Erstellung f√ºr SSR (Server-seitiges Rendering) nicht verwendet wird, ist `context.props` nur bei statischen Builds verf√ºgbar.

```ts title="src/pages/posts/[id].json.ts"
import type { APIContext } from 'astro';

export function getStaticPaths() {
  return [
    { params: { id: '1' }, props: { author: 'Blu' } },
    { params: { id: '2' }, props: { author: 'Erika' } },
    { params: { id: '3' }, props: { author: 'Matthew' } }
  ];
}

export function get({ props }: APIContext) {
	return {
		body: JSON.stringify({ author: props.author }),
	};
}
```

Siehe auch: [Daten√ºbergabe mit `props`](#daten√ºbergabe-mit-props)

### `context.request`

Ein Standard [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request)-Objekt. Es kann verwendet werden, um die `url`, `headers`, `method` und sogar den Body der Anfrage zu erhalten.

```ts
import type { APIContext } from 'astro';

export function get({ request }: APIContext) {
  return {
    body: `Hello ${request.url}`
  }
}
```

Siehe auch: [Astro.request](#astrorequest)

### `context.cookies`

`context.cookies` enth√§lt Helfer zum Lesen und Bearbeiten von Cookies.

Siehe auch: [Astro.cookies](#astrocookies)

### `context.url`

Ein [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL)-Objekt, das aus dem aktuellen `context.request.url`-URL-String-Wert konstruiert wird.

Siehe auch: [Astro.url](#astrourl)

### `context.clientAddress`

Gibt die [IP-Adresse](https://en.wikipedia.org/wiki/IP_address) der Anfrage an. Diese Eigenschaft ist nur bei der Erstellung f√ºr SSR (Server-seitiges Rendering) verf√ºgbar und sollte nicht f√ºr statische Websites verwendet werden.

```ts
import type { APIContext } from 'astro';

export function get({ clientAddress }: APIContext) {
  return {
    body: `Deine IP-Adresse lautet: ${clientAddress}`
  }
}
```

Siehe auch: [Astro.clientAddress](#astroclientaddress)


### `context.site`

`context.site` gibt eine `URL` zur√ºck, die aus `site` in deiner Astro-Konfiguration erstellt wurde. Wenn sie nicht definiert ist, wird eine URL von `localhost` zur√ºckgegeben.

Siehe auch: [Astro.site](#astrosite)

### `context.generator`

`context.generator` ist ein praktischer Weg, um die Version von Astro anzugeben, die in deinem Projekt l√§uft. Es hat das Format "Astro v1.x.x".

```ts title="src/pages/site-info.json.ts"
import type { APIContext } from 'astro';

export function get({ generator, site }: APIContext) {
  const body = JSON.stringify({ generator, site });
  return new Response(body);
}
```

Siehe auch: [Astro.generator](#astrogenerator)

### `context.redirect()`

Die Funktion `context.redirect()` gibt ein [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)-Objekt zur√ºck, mit dem du auf eine andere Seite umleiten kannst. Diese Funktion ist nur verf√ºgbar, wenn du f√ºr SSR (server-side rendering) baust und sollte nicht f√ºr statische Seiten verwendet werden.

```ts
import type { APIContext } from 'astro';

export function get({ redirect }: APIContext) {
  return redirect('/login', 302);
}
```

Siehe auch: [`Astro.redirect()`](#astroredirect)

## `getStaticPaths()`

Wenn eine Seite dynamische Parameter im Dateinamen verwendet, muss diese Komponente eine Funktion `getStaticPaths()` exportieren.

Diese Funktion ist erforderlich, weil Astro ein statischer Website-Builder ist. Das bedeutet, dass deine gesamte Website vor der Zeit erstellt wird. Wenn Astro nicht wei√ü, dass eine Seite zum Zeitpunkt der Erstellung generiert werden soll, werden deine Nutzer sie nicht sehen, wenn sie deine Website besuchen.

```astro
---
export async function getStaticPaths() {
  return [
    { params: { /* required */ }, props: { /* optional */ } },
    { params: { ... } },
    { params: { ... } },
    // ...
  ];
}
---
<!-- Deine HTML-Vorlage hier. -->
```

Die Funktion `getStaticPaths()` sollte ein Array von Objekten zur√ºckgeben, um zu bestimmen, welche Pfade von Astro vorgerendert werden.

Sie kann auch in statischen Datei-Endpunkten f√ºr [dynamisches Routing] verwendet werden (/de/core-concepts/endpoints/#params-und-dynamisches-routing).

:::caution
Die Funktion `getStaticPaths()` wird einmal in ihrem eigenen isolierten Bereich ausgef√ºhrt, bevor eine Seite geladen wird. Daher kannst du nichts aus ihrem √ºbergeordneten Bereich referenzieren, au√üer Datei-Importe. Der Compiler gibt eine Warnung aus, wenn du gegen diese Vorschrift verst√∂√üt.
:::

### `params`

Der Schl√ºssel `params` jedes zur√ºckgegebenen Objekts sagt Astro, welche Routen gebaut werden sollen. Die zur√ºckgegebenen Params m√ºssen den dynamischen Parametern und den Restparametern entsprechen, die in deinem Komponenten-Dateipfad definiert sind.

`params` werden in der URL kodiert, daher werden nur Strings als Werte unterst√ºtzt. Der Wert f√ºr jedes `params`-Objekt muss mit den im Seitennamen verwendeten Parametern √ºbereinstimmen.

Nehmen wir zum Beispiel an, du hast eine Seite unter `src/pages/posts/[id].astro`. Wenn du `getStaticPaths` von dieser Seite exportierst und folgendes f√ºr Pfade zur√ºckgibst:

```astro
---
export async function getStaticPaths() {
  return [
    { params: { id: '1' } },
    { params: { id: '2' } },
    { params: { id: '3' } }
  ];
}

const { id } = Astro.params;
---
<h1>{id}</h1>
```

Dann wird Astro statisch `Posts/1`, `Posts/2` und `Posts/3` zur Erstellungszeit erzeugen.

### Daten√ºbergabe mit `props`

Um zus√§tzliche Daten an jede generierte Seite zu √ºbergeben, kannst du auch einen `props`-Wert f√ºr jedes zur√ºckgegebene Pfadobjekt festlegen. Im Gegensatz zu `params` werden `props` nicht in der URL kodiert und sind daher nicht auf Strings beschr√§nkt.

Nehmen wir zum Beispiel an, du generierst Seiten auf der Grundlage von Daten, die du von einer entfernten API abrufst. Du kannst der Seitenkomponente innerhalb von `getStaticPaths` das vollst√§ndige Datenobjekt √ºbergeben:

```astro
---
export async function getStaticPaths() {
  const data = await fetch('...').then(response => response.json());

  return data.map((post) => {
    return {
      params: { id: post.id },
      props: { post },
    };
  });
}

const { id } = Astro.params;
const { post } = Astro.props;
---
<h1>{id}: {post.name}</h1>
```

Du kannst auch ein regul√§res Array √ºbergeben, was hilfreich sein kann, wenn du eine bekannte Liste von Routen generieren oder stubben willst.

```astro
---
export async function getStaticPaths() {
  const posts = [
    {id: '1', category: "astro", title: "API-Referenz"},
    {id: '2', category: "react", title: "Einen React-Counter erstellen!"}
  ];
  return posts.map((post) => {
    return {
      params: { id: post.id },
      props: { post }
    };
  });
}
const {id} = Astro.params;
const {post} = Astro.props;
---
<body>
  <h1>{id}: {post.title}</h1>
  <h2>Kategorie: {post.category}</h2>
</body>
```

Dann generiert Astro statisch `Posts/1` und `Posts/2` zur Erstellungszeit unter Verwendung der Seitenkomponente in `Pages/Posts/[id].astro`. Die Seite kann diese Daten mit `Astro.props` referenzieren:

### `paginate()`

Paginierung ist ein h√§ufiger Anwendungsfall f√ºr Websites, den Astro √ºber die Funktion `paginate()` unterst√ºtzt. die Funktion `paginate()` erzeugt automatisch ein Array, das von `getStaticPaths()` zur√ºckgegeben wird und eine URL f√ºr jede Seite der paginierten Sammlung erzeugt. Die Seitennummer wird als Parameter und die Seitendaten werden als `page`-Prop √ºbergeben.

```js
export async function getStaticPaths({ paginate }) {
  // Lade deine Daten mit fetch(), Astro.glob(), etc.
  const response = await fetch(`https://pokeapi.co/api/v2/pokemon?limit=150`);
  const result = await response.json();
  const allPokemon = result.results;

  // Gibt eine paginierte Sammlung von Pfaden f√ºr alle Beitr√§ge zur√ºck
  return paginate(allPokemon, { pageSize: 10 });
}

// Wenn sie richtig eingerichtet ist, hat die Seitenreferenz jetzt alles, was
// du brauchst um eine einzelne Seite zu rendern (siehe n√§chster Abschnitt).
const { page } = Astro.props;
```

`paginate()` nimmt den Dateinamen `[Seite].astro` oder `[...Seite].astro` an. Der Parameter `Seite` wird zur Seitennummer in deiner URL:

- `/posts/[page].astro` w√ºrde die URLs `/posts/1`, `/posts/2`, `/posts/3`, usw. erzeugen.
- `/posts/[...page].astro` w√ºrde die URLs `/posts`, `/posts/2`, `/posts/3`, usw. erzeugen.

#### Die `page` prop der Pagination

Die Pagination √ºbergibt jeder gerenderten Seite eine `page`-Eigenschaft, die eine einzelne Seite der Daten in der paginierten Sammlung darstellt. Dazu geh√∂ren die Daten, die du paginiert hast (`page.data`), sowie Metadaten f√ºr die Seite (`page.url`, `page.start`, `page.end`, `page.total`, etc). Diese Metadaten sind n√ºtzlich f√ºr Dinge wie die Schaltfl√§che "N√§chste Seite" oder die Meldung "Zeige 1-10 von 100".

| Name               |         Type          | Description                                                                                                                       |
| :----------------- | :-------------------: | :-------------------------------------------------------------------------------------------------------------------------------- |
| `page.data`        |        `Array`        | Array der Daten, die von `data()` f√ºr die aktuelle Seite zur√ºckgegeben werden.                                                                        |
| `page.start`       |       `number`        | Index of first item on current page, starting at `0` (e.g. if `pageSize: 25`, this would be `0` on page 1, `25` on page 2, etc.). |
| `page.end`         |       `number`        | Index des letzten Artikels auf der aktuellen Seite.                                                                                               |
| `page.size`        |       `number`        | Wie viele Artikel pro Seite.                                                                                                          |
| `page.total`       |       `number`        | Die Gesamtzahl der Eintr√§ge auf allen Seiten.                                                                                       |
| `page.currentpage` |       `number`        | die aktuelle Seitenzahl, beginnend mit `1`.                                                                                       |
| `page.lastPage`    |       `number`        | Die Gesamtzahl der Seiten.                                                                                                        |
| `page.url.current` |       `string`        | Ermittelt die URL der aktuellen Seite (n√ºtzlich f√ºr kanonische URLs) |
| `page.url.prev`    | `string \| undefined` | Ermittelt die URL der vorherigen Seite (wird `undefined` sein, wenn auf Seite 1).                                                              |
| `page.url.next`    | `string \| undefined` | Ermittelt die URL der n√§chsten Seite (wird `undefined`, wenn keine weiteren Seiten vorhanden sind).                                                              |

## Inhalts-Sammlungen

<p>
  <Since v="2.0.0" />
</p>

Inhaltssammlungen bieten APIs zur Konfiguration und Abfrage deiner Markdown- oder MDX-Dokumente in `src/content/`. Die Funktionen und Anwendungsbeispiele findest du in unserem Leitfaden f√ºr Inhaltssammlungen (/de/guides/content-collections/).

### `defineCollection()`

Mit `defineCollection()` kannst du eine Sammlung in einer `src/content/config.*`-Datei konfigurieren.

```ts
// src/content/config.ts
import { z, defineCollection } from 'astro:content';
const blog = defineCollection({
  schema: z.object({
    title: z.string(),
    permalink: z.string().optional(),
  }),
});

// Mache deine definierte Sammlung f√ºr Astro sichtbar
// mit dem `collections` Export
export const collections = { blog };
```

Diese Funktion akzeptiert die folgenden Eigenschaften:

#### `schema`

**Type:** `TSchema extends ZodType`

`schema` ist ein optionales Zod-Objekt, um den Typ und die Form des Frontmatter f√ºr eine Sammlung zu konfigurieren. Jeder Wert muss [einen Zod-Validator](https://github.com/colinhacks/zod) verwenden.

[Ein Beispiel f√ºr die Verwendung findest du in der Anleitung f√ºr `Inhaltssammlungen` (/de/guides/content-collections/#defining-a-collection-schema).

### `getCollection()`

**Type:** `(collection: string, filter?: (entry: CollectionEntry<collection>) => boolean) => CollectionEntry<collection>[]`

`getCollection()` ist eine Funktion, die eine Liste der Eintr√§ge einer Inhaltssammlung nach Sammlungsnamen abruft.

Sie gibt standardm√§√üig alle Eintr√§ge in der Sammlung zur√ºck und akzeptiert eine optionale Filterfunktion, um die Eintr√§ge nach Eigenschaften einzugrenzen. Damit kannst du √ºber das `data`-Objekt nur nach bestimmten Eintr√§gen in einer Sammlung auf der Basis von `id`-, `slug`- oder Frontmatter-Werten suchen.

```astro
---
import { getCollection } from 'astro:content';

// Get all `src/content/blog/` entries
const allBlogPosts = await getCollection('blog');

// Gib nur Beitr√§ge mit `draft: true` im Frontmatter zur√ºck
const draftBlogPosts = await getCollection('blog', ({ data }) => {
  return data.draft === true;
});
---
```

[Ein Beispiel f√ºr die Verwendung findest du in der Anleitung f√ºr `Inhaltssammlungen`](/de/guides/content-collections/#querying-collections).

### `getEntryBySlug()`

**Type:** `(collection: string, slug: string) => CollectionEntry<collection>`

`getEntryBySlug()` ist eine Funktion, die einen einzelnen Sammlungseintrag anhand des Sammlungsnamens und des Eintrags `slug` abruft.


```astro
---
import { getEntryBySlug } from 'astro:content';

const enterprise = await getEntryBySlug('blog', 'enterprise');
---
```

[Ein Beispiel f√ºr die Verwendung findest du in der Anleitung f√ºr `Inhaltssammlungen` (/de/guides/content-collections/#querying-collections).

### Collection-Eintragstyp

Die Funktionen [`getCollection()`](#getcollection) und [`getEntryBySlug()`](#getentrybyslug) geben jeweils Eintr√§ge vom Typ `CollectionEntry` zur√ºck. Dieser Typ ist als Helferfunktion von `astro:content` verf√ºgbar:

```ts
import type { CollectionEntry } from 'astro:content';
```

Der Typ `CollectionEntry<TCollectionName>` ist ein Objekt mit den folgenden Werten. `tCollectionName` ist der Name der Sammlung, die du abfragst (z. B. `CollectionEntry<'blog'>`).

#### `id`

**Example Type:** `'entry-1.md' | 'entry-2.md' | ...`

Eine eindeutige ID, die den Dateipfad relativ zu `src/content/[collection]` verwendet. Z√§hlt alle m√∂glichen String-Werte auf der Grundlage der Dateipfade der Sammlungseintr√§ge auf.

#### `slug`

**Example Type:** `'entry-1' | 'entry-2' | ...`

Ein URL-f√§higer Slug. Standardm√§√üig wird die `id` ohne die Dateierweiterung verwendet, kann aber durch Setzen der Eigenschaft [slug] (/de/guides/content-collections/#defining-custom-slugs) im Frontmatter einer Datei √ºberschrieben werden.

#### `data`

**Type:** `CollectionSchema<TCollectionName>`

Ein Objekt mit Frontmatter-Eigenschaften, die aus deinem Sammlungsschema abgeleitet werden ([siehe `defineCollection()` Referenz](#definecollection)). Der Standardwert ist `any`, wenn kein Schema konfiguriert ist.

#### `body`

**Type:** `string`

Ein String, der den einfachen, nicht kompilierten Textk√∂rper des Markdown- oder MDX-Dokuments enth√§lt.

#### `render()`

**Type:** `() => Promise<RenderedEntry>`

Eine Funktion, die ein gegebenes Markdown- oder MDX-Dokument f√ºr die Darstellung kompiliert. Sie gibt die folgenden Eigenschaften zur√ºck:

- `<Content />` - Eine Komponente, die verwendet wird, um den Inhalt des Dokuments in einer Astro-Datei darzustellen.
- `headings` - Eine generierte Liste von √úberschriften, die das [Astro-Werkzeug `getHeadings()`](/de/guides/markdown-content/#exportierte-eigenschaften) bei Markdown- und MDX-Importen widerspiegelt.
- `remarkPluginFrontmatter` - Das ge√§nderte Frontmatter-Objekt, nachdem ein [remark- oder rehype-Plugin angewendet wurde](/de/guides/markdown-content/#frontmatter). Wird auf den Typ `any` gesetzt.

```astro
---
import { getEntryBySlug } from 'astro:content';
const entry = await getEntryBySlug('blog', 'entry-1');

const { Content, headings, remarkPluginFrontmatter } = await entry.render();
---
```

[Siehe die Anleitungs f√ºr Inhaltssammlungen](/de/guides/content-collections/#rendering-content-to-html) f√ºr ein Anwendungsbeispiel.

## `import.meta`

Alle ESM-Module enthalten die Eigenschaft `import.meta`. Astro f√ºgt die Eigenschaft "import.meta.env" √ºber [Vite](https://vitejs.dev/guide/env-and-mode.html) hinzu.

**`import.meta.env.SSR`** kann verwendet werden, um zu wissen, wann auf dem Server gerendert wird. Manchmal willst du vielleicht eine andere Logik, zum Beispiel eine Komponente, die nur auf dem Client gerendert werden soll:

```jsx
import { h } from 'preact';

export default function () {
  return import.meta.env.SSR ? <div class="spinner"></div> : <FancyComponent />;
}
```

## Eingebaute Komponenten

Astro enth√§lt mehrere integrierte Komponenten, die du in deinen Projekten verwenden kannst. Alle eingebauten Komponenten sind in `.astro`-Dateien √ºber `import {} from 'astro/components';` verf√ºgbar.

### `<Markdown />`

Die Markdown-Komponente ist nicht mehr in Astro integriert. Wie du [Markdown in deine Astro-Dateien importierst](/de/guides/markdown-content/#importieren-von-markdown), findest du auf unserer Markdown-Seite.

### `<Code />`

```astro
---
import { Code } from 'astro/components';
---
<!-- Syntaxhervorhebung von JavaScript-Code. -->
<Code code={`const foo = 'bar';`} lang="js" />
<!-- Optional: passe dein Theme an. -->
<Code code={`const foo = 'bar';`} lang="js" theme="dark-plus" />
<!-- Optional: Aktiviere den Zeilenumbruch. -->
<Code code={`const foo = 'bar';`} lang="js" wrap />
```

Diese Komponente bietet Syntax-Highlighting f√ºr Codebl√∂cke zum Zeitpunkt der Erstellung (kein clientseitiges JavaScript enthalten). Die Komponente wird intern von Shiki betrieben und unterst√ºtzt alle g√§ngigen [Themen](https://github.com/shikijs/shiki/blob/main/docs/themes.md) und [Sprachen](https://github.com/shikijs/shiki/blob/main/docs/languages.md). Au√üerdem kannst du deine eigenen Themes und Sprachen hinzuf√ºgen, indem du sie an `theme` bzw. `lang` √ºbergibst.

:::note
Wenn du einen [strict package manager](https://pnpm.io/pnpm-vs-npm#npms-flat-tree) wie `pnpm` verwendest, musst du eventuell auch Shiki installieren, damit es w√§hrend des Builds funktioniert:

```bash
pnpm install shiki
```
:::

### `<Prism />`

Um die Textmarker-Komponente `Prism` zu verwenden, musst du zuerst das Paket `@astrojs/prism` **installieren**:

<PackageManagerTabs>
  <Fragment slot="npm">
  ```shell
  npm install @astrojs/prism
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```shell
  pnpm install @astrojs/prism
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```shell
  yarn add @astrojs/prism
  ```
  </Fragment>
</PackageManagerTabs>

```astro
---
import { Prism } from '@astrojs/prism';
---
<Prism lang="js" code={`const foo = 'bar';`} />
```

Diese Komponente bietet sprachspezifische Syntaxhervorhebung f√ºr Codebl√∂cke durch Anwendung der CSS-Klassen von Prism. Beachte, dass **du ein Prism-CSS-Stylesheet** bereitstellen (oder dein eigenes mitbringen) musst, damit die Syntaxhervorhebung angezeigt wird! Weitere Informationen findest du im Abschnitt [Prism-Konfiguration](/de/guides/markdown-content/#prism-konfiguration).

In der [Liste der von Prism unterst√ºtzten Sprachen](https://prismjs.com/#supported-languages) findest du den entsprechenden Alias f√ºr eine Sprache. Und du kannst deine Astro-Codebl√∂cke auch mit `lang="astro"` anzeigen!

### `<Debug />`

```astro
---
import { Debug } from 'astro/components';
const serverObject = {
  a: 0,
  b: "string",
  c: {
    nested: "object"
  }
}
---
<Debug {serverObject} />
```

Diese Komponente bietet eine M√∂glichkeit, Werte auf der Client-Seite zu √ºberpr√ºfen, ohne JavaScript.


[canonical]: https://en.wikipedia.org/wiki/Canonical_link_element
