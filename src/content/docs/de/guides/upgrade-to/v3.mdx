---
title: Auf Astro v3 aktualisieren
description: So aktualisierst du dein Projekt auf die neueste Version von Astro.
i18nReady: true
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'
import FileTree from '~/components/FileTree.astro'


Diese Anleitung hilft dir bei der Migration von Astro v2 zu Astro v3.

Du musst ein √§lteres Projekt auf v2 aktualisieren? Siehe unsere [√§ltere Anleitung zur Migration](/de/guides/upgrade-to/v2/).

## Astro-Aktualisierung

Aktualisiere die Astro-Version deines Projekts mit deinem Paketmanager auf die neueste Version. Wenn du Astro-Integrationen verwendest, aktualisiere bitte auch diese auf die neueste Version.

<PackageManagerTabs>
  <Fragment slot="npm">
  ```shell
  # Upgrade auf Astro v3.x
  npm install astro@latest

  # Beispiel: React- und Tailwind-Integrationen aktualisieren 
  npm install @astrojs/react@latest @astrojs/tailwind@latest
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```shell
  # Upgrade auf Astro v3.x
  pnpm install astro@latest

  # Beispiel: React- und Tailwind-Integrationen aktualisieren 
  pnpm install @astrojs/react@latest @astrojs/tailwind@latest
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```shell
  # Upgrade auf Astro v3.x
  yarn add astro@latest

  # Beispiel: React- und Tailwind-Integrationen aktualisieren 
  yarn add @astrojs/react@latest @astrojs/tailwind@latest
  ```
  </Fragment>
</PackageManagerTabs>

:::note[Du musst weitermachen?]
Nach dem Aktualisieren von Astro sollten keine √Ñnderungen an deinem Projekt n√∂tig sein!

Falls jedoch Fehler oder unerwartetes Verhalten auftreten, schau bitte weiter unten nach, was sich ge√§ndert hat und m√∂glicherweise in deinem Projekt aktualisiert werden muss.
:::

## Astro v3.0 Experimentale Optionen wurden entfernt 

Entferne die folgenden experimentellen Optionen aus `astro.config.mjs`:

```js del={5-8}
// astro.config.mjs
import { defineConfig } from 'astro/config';

export default defineConfig({
  experimental: {
    assets: true,
    viewTransitions: true,
  },
})
```

Diese Features sind jetzt standardm√§√üig verf√ºgbar:

- View Transitions f√ºr animierte Seiten√ºberg√§nge und persistente Astro-Inseln. Siehe [view transitions API breaking changes und Upgrade-Ratschl√§ge], wenn du diese experimentelle Option verwendet hast.
- Eine neue Bildservices-API `astro:assets` f√ºr das verwenden von Bildern in Astro, einschlie√ülich eines neuen `<Image />`-Komponent und der `getImage()`-Funktion. Bitte lies die detaillierten [Bild Upgrade-Ratschl√§ge](/de/guides/images/#upgrade-to-v30-from-v2x) **unabh√§ngig davon, ob du diese experimentelle Option verwendet hast**, um zu sehen, wie sich dies auf dein Projekt auswirken k√∂nnte.

Lies mehr √ºber diese zwei interessanten Features und mehr im [Astro 3.0 Blogbeitrag](https://astro.build/blog/astro-3/)!

## Astro v3.0 Breaking Changes

Astro v2.0 enth√§lt einige wichtige √Ñnderungen und einige veraltete Features wurden entfernt. Wenn dein Projekt nach dem Upgrade auf v2.0 nicht mehr wie erwartet funktioniert, findest du in dieser Anleitung eine √úbersicht √ºber alle √Ñnderungen und Anweisungen, wie du deine Codebasis aktualisieren kannst.

Siehe [das √Ñnderungsprotokoll](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) f√ºr die vollst√§ndigen Versionshinweise.

### Entfernt: Unterst√ºtzung f√ºr Node 16

Node 16 wird voraussichtlich im September 2023 sein Lebensende erreichen.

Astro v3.0 verzichtet komplett auf die Unterst√ºtzung von Node 16, damit alle Astro-Benutzer die Vorteile der moderneren Features von Node nutzen k√∂nnen.

#### Was soll ich tun?

Vergewissere dich, dass sowohl deine Entwicklungs- als auch dein Ver√∂ffentlichungs-Umgebung **Node `18.14.1` oder h√∂her** verwenden.

1. √úberpr√ºfe deine lokale Version von Node mit:
    ```sh
    node -v
    ```



2. √úberpr√ºfe die Dokumentation deiner [Ver√∂ffentlichungs-Umgebung](/de/guides/deploy/), um sicherzustellen, dass sie Node 18 unterst√ºtzt.

Du kannst Node `18.14.1` f√ºr dein Astro-Projekt entweder in einer Dashboard-Konfigurationseinstellung oder in einer `.nvmrc`-Datei angeben.

```bash title=".nvmrc"
18.14.1
```
### Entfernt: Unterst√ºtzung f√ºr TypeScript 4

Die `tsconfig.json`-Voreinstellungen in Astro v2.x Unterst√ºtzen TypeScript 4.x und 5.x. Astro geht jetzt davon aus, dass du TypeScript 5.0 (M√§rz 2023) verwendest oder das dein Editor diese Version einschlie√üt (wie z.B. VS Code 1.77).

#### Was soll ich tun?

Falls du TypeScript lokal installiert hast, aktualisiere es mindestens auf v5.0.

```bash
npm install typescript@latest --save-dev
```

### Entfernt: `@astrojs/image`

In Astro v2.x stellte Astro eine offizielle Bildintegration zur Verf√ºgung, die Astro `<Image />`- und `<Picture />`-Komponenten einschloss.

Mit Astro v3.0 wurde diese Integration komplett entfernt. Die neue L√∂sung f√ºr den umgang mit Bildern ist eine integrierte Bildservices-API: `astro:assets`.

#### Was soll ich tun?

Entferne die `@astrojs/image`-Integration aus deinem Projekt. Du musst nicht nur die Integration deinstallieren, sondern auch alle Import-Anweisungen sowie die vorhandenen `<Image />`- und `<Picture />`-Komponenten aktualisieren oder entfernen. M√∂glicherweise musst du auch einen bevorzugten Standardbildverarbeitungsdienst konfigurieren.

Du findest eine [Schritt f√ºr Schritt Anleitung zum Entfernen der alten Bildintegration](/de/guides/images/#remove-astrojsimage) in unserem Bilder-Guide.

Die Migration zu `astro:assets` bringt auch einige neue Bildoptionen und Features mit sich, die du vielleicht nutzen m√∂chtest. Bitte sieh dir den vollst√§ndigen [Upgrade-Ratgeber f√ºr Bilder in Version 3.0](/de/guides/images/#upgrade-to-v30-from-v2x) f√ºr alle Details an!

```js del={3,7}
// astro.config.mjs
import { defineConfig } from 'astro/config';
import image from '@astrojs/image';

export default defineConfig({
  integrations: [
    image(),
  ]
})
```

### Entfernt: `<Markdown />`-Komponente

In Astro v1.x wurde der `<Markdown />`-Komponent veraltet und in ein externes Paket verschoben.

In Astro v3.0 wurde das Paket `@astrojs/markdown-component` vollst√§ndig entfernt. Der `<Markdown />`-Komponente von Astro wird nicht mehr in deinem Projekt funktionieren.

#### Was soll ich tun?

Entferne alle Verwendungen von `@astrojs/markdown-component`.

```astro del={2} title="src/components/MyAstroComponent.astro"
---
import Markdown from '@astrojs/markdown-component';
---
```

Um eine √§hnliche `<Markdown />`-Komponente in deinem Code weiter zu verwenden, erw√§ge die Verwendung von [Community-Integrationen](https://astro.build/integrations/) wie [`astro-remote`](https://github.com/natemoo-re/astro-remote). Stelle sicher, dass du deine `<Markdown />`-Komponenten-Importe und Attribute, wie in der Dokumentation der Integration angegeben, aktualisierst.

Andernfalls l√∂sche alle Verweise auf den Import des Astro `<Markdown />`-Komponents und den Komponenten selbst in deinen `.astro`-Dateien. Du musst deinen Inhalt dann direkt als HTML umschreiben oder [Markdown importieren](/de/guides/markdown-content/#importieren-von-markdown) von einer `.md`-Datei.

### Entfernt: Veraltete 1.x APIs

Mit Astro v1.x wurden unsere urspr√ºnglichen Konfigurationseinstellungen sowie die Unterst√ºtzung von `<style global>` und `<script hoist>` veraltet. Diese wurden jedoch weiterhin f√ºr Abw√§rtskompatibilit√§t unterst√ºtzt.

Astro v3.0 entfernt diese veralteten APIs vollst√§ndig. Stattdessen sollten die offiziell unterst√ºtzten [Konfigurationseinstellungen](/de/reference/configuration-reference/) und die moderne Syntax `<style is:global>` und `<script>` verwendet werden.

#### Was soll ich tun?

Wenn du weiterhin v1.x APIs verwendest, nutze stattdessen die neuen APIs f√ºr die jeweiligen Features:
- Veraltete Konfigurationsoptionen: Siehe [die 0.26 Migrations-Anleitung](/de/guides/upgrade-to/v1/#new-configuration-api)
- Veraltete Skript-/Style-Attributtypen: Siehe [die 0.26 Migrations-Anleitung](/de/guides/upgrade-to/v1/#new-default-script-behavior)

### Entfernt: Partielle Shims f√ºr Web-APIs in Server Code

In Astro v2.x hat Astro teilweise Shims f√ºr Web-APIs wie `document` oder `localStorage` im serverseitig gerenderten Code bereitgestellt. Diese Shims waren oft unvollst√§ndig und unzuverl√§ssig.

Astro v3.0 entfernt diese teilweisen Shims vollst√§ndig. Web-APIs stehen nicht mehr im serverseitig gerenderten Code zur Verf√ºgung.

#### Was soll ich tun?

Wenn du Web-APIs in serverseitig gerenderten Komponenten verwendest, musst du entweder die Verwendung dieser APIs bedingt machen oder [`client:only`](/de/reference/directives-reference/#clientonly) verwenden.

### Entfernt: `image` aus `astro:content` im Schema von Inhalts-Sammlungen

In Astro v2.x veraltete die API f√ºr Inhalts-Sammlungen einen `image`-Export aus `astro:content`, der in den Inhalts-Sammlungen-Schemas verwendet wurde.

Astro v3.0 entfernt diesen Export vollst√§ndig.

#### Was soll ich tun?

Wenn du das veraltete `image()` aus `astro:content` verwendest, entferne es, da es nicht mehr existiert. √úberpr√ºfe Bilder stattdessen √ºber [den `image`-Helfer aus `schema`](/de/guides/images/#update-content-collections-schemas):

 ```ts title="src/content/config.ts" del={1} ins={2} "({ image })"
import { defineCollection, z, image } from "astro:content";
import { defineCollection, z } from "astro:content";

 defineCollection({
   schema: ({ image }) =>
     z.object({
       image: image(),
    }),
});
```

### Entfernt: Shiki-Theme-Namen vor Version 0.14
``

In Astro v2.x wurden einige Shiki-Theme-Namen umbenannt, aber die urspr√ºnglichen Namen wurden wegen der Abw√§rtskompatibilit√§t beibehalten.

Astro v3.0 entfernt die urspr√ºnglichen Namen zugunsten der umbenannten Theme-Namen.

#### Was soll ich tun?

Wenn dein Projekt eines der folgenden Themes verwendet, benenne es entsprechend seinem aktualisierten Namen um:

- `material-darker` -> `material-theme-darker`
- `material-default` -> `material-theme`
- `material-lighter` -> `material-theme-lighter`
- `material-ocean` -> `material-theme-ocean`
- `material-palenight` -> `material-theme-palenight`

### Entfernt: `class:list`-Features

In Astro v2.x verwendete die [`class:list`-Direktive](/de/reference/directives-reference/#classlist) eine benutzerdefinierte Implementierung, die von [`clsx`](https://github.com/lukeed/clsx) inspiriert war und einige zus√§tzliche Features wie Deduplizierung und Unterst√ºtzung f√ºr `Set` enthielt.

Astro v3.0 verwendet `clsx` jetzt direkt f√ºr `class:list`, was keine Deduplizierung oder Unterst√ºtzung f√ºr `Set`-Werte bietet.

#### Was soll ich tun?

Ersetze alle `Set`-Elemente, die der `class:list`-Direktive √ºbergeben werden, durch ein normales `Array`.

```astro title="src/components/MyAstroComponent.astro" del={4} ins={5}
<Component class:list={[
  'a',
  'b',
  new Set(['c', 'd'])
  ['c', 'd']
]} />
```

### Entfernt: `class:list` als Prop √úbergeben

In Astro v2.x wurden [`class:list`-Werte](/de/reference/directives-reference/#classlist) √ºber [`Astro.props['class:list']`](/de/reference/api-reference/#astroprops) an Komponenten √ºbermittelt.

Astro v3.0 normalisiert `class:list`-Werte zuerst zu einem String, bevor sie √ºber `Astro.props['class']` an Komponenten weitergegeben werden.

#### Was soll ich tun?

Entferne jeglichen Code, der den `class:list`-Prop erh√§lt.

```astro title="src/components/MyAstroComponent.astro" del={2,3,7} ins={4,8} "classList" "'class:list': classList"
---
import { clsx } from 'clsx';
const { class: className, 'class:list': classList } = Astro.props;
const { class: className } = Astro.props;
---
<div
  class:list={[className, classList]}
  class:list={[className]}
/>
```

### Entfernt: kebab-case Umwandlung f√ºr camelCase CSS-Variablen 

In Astro v2.x wurden camelCase [CSS-Variablen](/de/guides/styling/#css-variables), die dem `style`-Attribut √ºbergeben wurden, sowohl in camelCase (wie geschrieben) als auch im kebab-case (f√ºr Abw√§rtskompatibilit√§t beibehalten) gerendert.

Astro v3.0 entfernt die kebab-case Umwandlung f√ºr diese camelCase CSS-Variablennamen, und nur die urspr√ºngliche camelCase CSS-Variable wird gerendert.

```astro "my-value"
---
// src/components/MyAstroComponent.astro
const myValue = "red"
---
<!-- input -->
<div style={{ "--myValue": myValue }}></div>

<!-- output (Astro 2.x) -->
<div style="--my-value:var(--myValue);--myValue:red"></div>
<!-- output (Astro 3.0) -->
<div style="--myValue:red"></div>
```

#### Was soll ich tun?

Wenn du darauf vertraut hast, dass Astro kebab-case in deinen Styles umwandelt, aktualisiere deine bestehenden Styles zu camelCase, um fehlende Styles zu verhindern. Zum Beispiel:

```astro del={3} ins={4} title="src/components/MyAstroComponent.astro"
<style>
  div {
   color: var(--my-value);
   color: var(--myValue);
  }
</style>
```

### Entfernt: Automatisches Abflachen des R√ºckgabewerts von `getStaticPaths()`

In Astro v2.x wurde der R√ºckgabewert von [`getStaticPaths()`](/de/reference/api-reference/#getstaticpaths) automatisch abgeflacht, um es dir zu erm√∂glichen, ein Array aus Arrays ohne Fehler zur√ºckzugeben.

Astro v3.0 entfernt das automatische Abflachen des R√ºckgabewerts von `getStaticPaths()`.

#### Was soll ich tun?

Wenn du ein Array von Arrays statt eines Arrays von Objekten zur√ºckgibst (wie erwartet), sollten jetzt `.flatMap` und `.flat` verwendet werden, um sicherzustellen, dass du ein flaches Array zur√ºckgibst.

Eine [Fehlermeldung, die darauf hinweist, dass der R√ºckgabewert von `getStaticPaths()` ein Array aus Objekten sein muss](/de/reference/errors/invalid-get-static-paths-entry/#what-went-wrong), wird bereitgestellt, wenn du deinen Code aktualisieren musst.

### Verschoben: `astro check` erfordert jetzt ein externes Paket

In Astro v2.x war [`astro check`](/de/reference/cli-reference/#astro-check) standardm√§√üig in Astro enthalten, und seine Abh√§ngigkeiten waren in Astro geb√ºndelt. Dies f√ºhrte zu einem gr√∂√üeren Paket, unabh√§ngig davon, ob du jemals `astro check` verwendet hast. Dies hat auch verhindert, dass du die Version von TypeScript und den Astro Language Server kontrollieren konntest.

Astro v3.0 verschiebt den Befehl `astro check` aus Astro und erfordert jetzt ein externes Paket `@astrojs/check`. Zus√§tzlich musst du `typescript` in deinem Projekt installieren, um den Befehl `astro check` zu verwenden.

#### Was soll ich tun?

F√ºhre nach dem Upgrade auf Astro v3.0 den Befehl `astro check` aus und befolge die Anweisungen, um die erforderlichen Abh√§ngigkeiten zu installieren. Alternativ kannst du `@astrojs/check` und `typescript` manuell in dein Projekt installieren.

### Veraltet: `build.excludeMiddleware` und `build.split`

In Astro v2.x wurden `build.excludeMiddleware` und `build.split` verwendet, um zu √§ndern, wie bestimmte Dateien beim Verwenden eines Adapters im SSR-Modus ausgegeben wurden.

Astro v3.0 ersetzt diese Erzeugungs-Konfigurationsoptionen durch neue [SSR-Adapter-Konfigurationsoptionen](/de/guides/integrations-guide/#offizielle-integrationen), um die gleichen Aufgaben zu erledigen: `edgeMiddleware` und `functionPerRoute`.

#### Was soll ich tun?

Aktualisiere die Astro-Konfigurationsdatei, um die neuen Optionen nun direkt **in der Adapter-Konfiguration** zu verwenden.

```js title="astro.config.mjs" del={5-7} ins={9}
import { defineConfig } from "astro/config";
import vercel from "@astrojs/vercel/serverless";

export default defineConfig({
    build: {
      excludeMiddleware: true
    },
    adapter: vercel({
      edgeMiddleware: true
    }),
});
```

```js title="astro.config.mjs" del={5-7} ins={9}
import { defineConfig } from "astro/config";
import netlify from "@astrojs/netlify/functions";

export default defineConfig({
     build: {
        split: true
     },
     adapter: netlify({
        functionPerRoute: true
     }),
});
```

### Veraltet: `markdown.drafts`

In Astro v2.x erm√∂glichte die Konfiguration `markdown.drafts` das Vorhandensein von Entw√ºrfen f√ºr Seiten, die im Dev-Server verf√ºgbar waren, aber nicht f√ºr die Produktion erzeugt wurden.

Astro v3.0 veraltet dieses Feature zugunsten der Methode der Inhalts-Sammlungen zum Umgang mit Entwurfsseiten durch manuelle Filterung, was mehr Kontrolle √ºber das Feature erm√∂glicht.

#### Was soll ich tun?

Um weiterhin einige Seiten in deinem Projekt als Entw√ºrfe zu kennzeichnen, [verwende stattdessen Inhalts-Sammlungen](/de/guides/content-collections/#migrating-from-file-based-routing) und [filtere Seiten manuell aus](/de/guides/content-collections/#filtering-collection-queries) mit der `draft: true`-Frontmatter-Eigenschaft.

### Veraltet: R√ºckgabe eines einfachen Objekts an Endpunkten

In Astro v2.x konnten Endpunkte ein einfaches Objekt zur√ºckgeben, das in eine JSON-Antwort umgewandelt wurde.

Astro v3.0 veraltet dieses Verhalten zugunsten der direkten R√ºckgabe eines `Response`-Objekts.

#### Was soll ich tun?

Aktualisiere deine Endpunkte, um direkt ein `Response`-Objekt zur√ºckzugeben.

```ts title="endpoint.json.ts" del={2} ins={3}
export async function GET() {
  return { body: { "title": "Bob's blog" }};
  return new Response(JSON.stringify({ "title": "Bob's blog" }));
}
```

Wenn du wirklich das vorherige Format beibehalten musst, kannst du das `ResponseWithEncoding`-Objekt verwenden, aber beachte, dass es in Zukunft veraltet sein wird.

```ts title="endpoint.json.ts" del={2} ins={3}
export async function GET() {
  return { body: { "title": "Bob's blog" } };
  return new ResponseWithEncoding({ body: { "title": "Bob's blog" }});
}
```

### Standardwert Ge√§ndert: `verbatimModuleSyntax` in tsconfig.json-Voreinstellungen

In Astro v2.x war die Einstellung [`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax) standardm√§√üig deaktiviert, wobei ihr TypeScript 4.x-√Ñquivalent `importsNotUsedAsValues` in der `strict`-Voreinstellung aktiviert war.

In Astro v3.0 ist `verbatimModuleSyntax` in jeder Voreinstellung aktiviert.

#### Was soll ich tun?

Diese Option erfordert, dass Typen mit der Syntax `import type` importiert werden.

```astro title="src/components/MyAstroComponent.astro" "type"
---
import { type CollectionEntry, getEntry } from "astro:content";
---
```

Obwohl wir empfehlen, es aktiviert zu lassen und deine Typen-Importe ordnungsgem√§√ü mit `type` zu machen (wie oben gezeigt), kannst du es deaktivieren, indem du `verbatimModuleSyntax: false` in deiner `tsconfig.json`-Datei setzt, falls es Probleme verursacht.

```json title="tsconfig.json" "false"
{
  "compilerOptions": {
    "verbatimModuleSyntax": false
  }
}
```

### Standardwert Ge√§ndert: port `3000`

In Astro v2.x lief Astro standardm√§√üig auf Port `3000`.

Astro v3.0 √§ndert den [Standardport](/de/reference/cli-reference/#--port-number) zu `4321`. üöÄ

#### Was soll ich tun?

Aktualisiere alle vorhandenen Verweise auf `localhost:3000`, zum Beispiel in Tests oder in deiner `README`, um den neuen Port `localhost:4321` widerzuspiegeln.

### Standardwert Ge√§ndert: import.meta.env.BASE_URL `trailingSlash`

In Astro v2.x hat `import.meta.env.BASE_URL` standardm√§√üig deine [`base`](/de/reference/configuration-reference/#base)-Einstellung in Kombination mit einem [trailingSlash](/de/reference/configuration-reference/#trailingslash) um ein Schr√§gstrichsuffix erweitert. `trailingSlash: "ignore"` hat ebenfalls ein Schr√§gstrichsuffix hinzugef√ºgt.

Astro v3.0 f√ºgt `import.meta.env.BASE_URL` standardm√§√üig nicht mehr mit einem Schr√§gstrichsuffix hinzu, auch nicht wenn `trailingSlash: "ignore"` festgelegt ist. (Das bestehende Verhalten von `base` in Kombination mit `trailingSlash: "always"` oder `trailingSlash: "never"` bleibt unver√§ndert.)

#### Was soll ich tun?

Wenn deine `base` bereits ein Schr√§gstrichsuffix hat, ist keine √Ñnderung erforderlich.

Wenn deine `base` kein Schr√§gstrichsuffix hat, f√ºge einen hinzu, wenn du das vorherige Standardverhalten (oder `trailingSlash: "ignore"`) beibehalten m√∂chtest:

```js title="astro.config.mjs" del={4} ins={5}
import { defineConfig } from "astro/config";

export default defineConfig({
  base: 'my-base',
  base: 'my-base/',
});
```

### Standardwert Ge√§ndert: `compressHTML`

In Astro v2.x hat Astro dein ausgegebenes HTML nur komprimiert, wenn [`compressHTML`](/de/reference/configuration-reference/#compresshtml) explizit auf `true` gesetzt war. Der Standardwert war `false`.

Astro v3.0 komprimiert jetzt standardm√§√üig das ausgegebene HTML.

#### Was soll ich tun?

Du kannst jetzt `compressHTML: true` aus deiner Konfiguration entfernen, da dies das neue Standardverhalten ist.

```js title="astro.config.mjs" del={4}
import { defineConfig } from "astro/config";

export default defineConfig({
  compressHTML: true
})
```

Du musst nun `compressHTML: false` setzen, um die HTML-Komprimierung nicht zu verwenden.

### Standardwert Ge√§ndert: `scopedStyleStrategy`

In Astro v2.x war der Standardwert von [`scopedStyleStrategy`](/de/reference/configuration-reference/#scopedstylestrategy) `"where"`.

Astro v3.0 f√ºhrt einen neuen Standardwert ein: `"attribute"`. Standardm√§√üig werden Styles jetzt mit `data-*`-Attributen angewendet.

#### Was soll ich tun?

Um das aktuelle [Style-Scoping](/de/guides/styling/#scoped-styles) deines Projekts beizubehalten, aktualisiere die Konfigurationsdatei auf den vorherigen Standardwert:


```js title="astro.config.mjs" ins={4}
import { defineConfig } from "astro/config";

export default defineConfig({
  scopedStyleStrategy: "where"
})
```

### Standardwert Ge√§ndert: `inlineStyleSheets`

In Astro v2.x wurden standardm√§√üig alle Projekt-Styles als Link-Tags gesendet. Du konntest w√§hlen, sie jedes Mal in `<style>`-Tags einzuf√ºgen, indem du `"always"` verwendest, oder nur Styles unter einer bestimmten Gr√∂√üe mit `"auto"` inlining durch die Konfiguration [`build.inlineStylesheets`](/de/reference/configuration-reference/#buildinlinestylesheets). Die Standardvoreinstellung war `"never"`.

Astro v3.0 √§ndert den Standardwert von `inlineStylesheets` zu `"auto"`. Stylesheets kleiner als `ViteConfig.build.assetsInlineLimit` (Standard: 4 KB) werden standardm√§√üig eingef√ºgt. Andernfalls werden Projekt-Styles in externen Stylesheets gesendet.

#### Was soll ich tun?
Wenn du das aktuelle Verhalten deines Projekts beibehalten m√∂chtest, setze `build.inlineStylesheets` auf den vorherigen Standardwert `"never"`:


```js title="astro.config.mjs" ins={4-6}
import { defineConfig } from "astro/config";

export default defineConfig({
	 build: {
    inlineStylesheets: "never"
  }
})
```

### Standardwert Ge√§ndert: Bilderdienst

In Astro v2.x war Squoosh der [Standard-Bildverarbeitungsdienst](/de/guides/images/#default-image-service).

Astro v3.0 enth√§lt jetzt standardm√§√üig Sharp als Bildverarbeitungsdienst und bietet stattdessen eine Konfigurationsoption, um Squoosh zu verwenden.

#### Was soll ich tun?

:::note
Bei Verwendung eines [strikten Paketmanagers](https://pnpm.io/pnpm-vs-npm#npms-flat-tree) wie `pnpm` musst du m√∂glicherweise Sharp manuell in dein Projekt installieren, obwohl es eine Abh√§ngigkeit von Astro ist:

```bash
pnpm install sharp
```
:::

Wenn du Squoosh weiterhin f√ºr die Verarbeitung deiner Bilder verwenden m√∂chtest, aktualisiere deine Konfiguration wie folgt:

```ts title="astro.config.mjs" ins={4-6}
import { defineConfig, squooshImageService } from "astro/config";

export default defineConfig({
  image: {
    service: squooshImageService(),
  }
})
```

### Ge√§ndert: Gro√ü- und Kleinschreibung der HTTP-Anforderungsmethoden

In Astro v2.x wurden [HTTP-Anforderungsmethoden](/de/core-concepts/endpoints/#http-methods) mit Kleinbuchstaben verwendet: `get`, `post`, `put`, `all` und `del`.

Astro v3.0 verwendet Gro√übuchstaben, einschlie√ülich `DELETE` anstelle von `del`.

#### Was soll ich tun?

Benenne alle Funktionen in ihre Gro√übuchstaben-√Ñquivalente um:

- `get` to `GET`
- `post` to `POST`
- `put` to `PUT`
- `all` to `ALL`
- `del` to `DELETE`

```js title="endpoint.ts" del={1} ins={2}
export function get() {
export function GET() {
    return new Response(JSON.stringify({ "title": "Bob's blog" }));
}
```

### Ge√§ndert: Konfiguration f√ºr mehrere JSX-Frameworks

In Astro v2.x konntest du [mehrere JSX-Framework-Integrationen](/de/guides/integrations-guide/#offizielle-integrationen) (React, Solid, Preact) im selben Projekt verwenden, ohne angeben zu m√ºssen, welche Dateien zu welchem Framework geh√∂ren.

Astro v3.0 erfordert nun, dass du angibst, welches Framework f√ºr deine Dateien verwendet werden soll, indem du neue `include`- und `exclude`-Integrationskonfigurationsoptionen verwendest, wenn du mehrere JSX-Framework-Integrationen installiert hast. Dies erm√∂glicht es Astro, die Verwendung eines einzigen Frameworks besser zu unterst√ºtzen, sowie fortgeschrittene Funktionen wie React Fast Refresh.

#### Was soll ich tun?

Wenn du mehrere JSX-Frameworks im selben Projekt verwendest, setze `include` (und optional `exclude`) auf ein Array von Dateien und/oder Ordnern. Wildcards k√∂nnen verwendet werden, um mehrere Dateipfade einzuschlie√üen.

Wir empfehlen, gemeinsame Framework-Komponenten im selben Ordner zu speichern (z.B. `/components/react/` und `/components/solid/`), um die Angabe deiner Includes zu erleichtern, aber dies ist nicht erforderlich:

```js ins={13,16,19}
import { defineConfig } from 'astro/config';
import preact from '@astrojs/preact';
import react from '@astrojs/react';
import svelte from '@astrojs/svelte';
import vue from '@astrojs/vue';
import solid from '@astrojs/solid-js';

export default defineConfig({
  // Aktiviere viele Frameworks, um verschiedene Arten von Komponenten zu unterst√ºtzen.
  // `include` ist nicht erforderlich, wenn du nur ein Framework verwendest!
  integrations: [
    preact({
      include: ['**/preact/*']
    }),
    react({
      include: ['**/react/*']
    }),
    solid({
      include: ['**/solid/*'],
    }),
  ]
});
```

### Ge√§ndert: `Astro.cookies.get(key)` kann `undefined` zur√ºckgeben

In Astro v2.x w√ºrde [`Astro.cookies.get(key)`](/de/reference/api-reference/#astrocookies) immer ein [`AstroCookie`-Objekt](/de/reference/api-reference/#astrocookie) zur√ºckgeben, auch wenn kein Cookie existierte. Um auf dessen Existenz zu pr√ºfen, musstest du `Astro.cookies.has(key)` verwenden.

Astro v3.0 gibt f√ºr `Astro.cookies.get(key)` nun `undefined` zur√ºck, wenn kein Cookie existiert.

#### Was soll ich tun?

Diese √Ñnderung wird keinen Code unbrauchbar machen, der auf die Existenz des `Astro.cookie`-Objekts √ºberpr√ºft, bevor `Astro.cookies.get(key)` verwendet wird, ist jedoch jetzt nicht mehr erforderlich.

Du kannst ohne probleme jeglichen Code entfernen, der `has()` verwendet, um zu √ºberpr√ºfen, ob der Wert von `Astro.cookies` `undefined` ist:

```js del={1-3} ins={5-7}
if (Astro.cookies.has(id)) {
  const id = Astro.cookies.get(id)!;
}

const id = Astro.cookies.get(id);
if (id) {
}
```

### Ge√§ndert: Programmatisches Ausf√ºhren der Astro Kommandozeilen&shy;schnittstelle (CLI)

In Astro v2.x exportierte und startete der Eintrittspunkt des Pakets `"astro"` die Astro CLI direkt. Es wird nicht empfohlen, Astro auf diese Weise in der Praxis auszuf√ºhren.

Astro v3.0 entfernt die CLI aus dem Eintrittspunkt und exportiert einen neuen Satz experimenteller JavaScript-APIs, einschlie√ülich `dev()`, `build()`, `preview()` und `sync()`.

#### Was soll ich tun?

Um die Astro Kommandozeilenschnittstelle [programmatisch auszuf√ºhren](/de/reference/cli-reference/#advanced-apis-experimental), verwende die neuen experimentellen JavaScript-APIs:


```js
import { dev, build } from "astro";

// Starte den Astro-Entwicklungsserver
const devServer = await dev();
await devServer.stop();

// Erzeuge dein Astro-Projekt
await build();
```

### Ge√§ndert: Pfade f√ºr den Export von internen Astro-API-Einstiegspunkten

In Astro v2.x konntest du interne Astro-APIs aus `astro/internal/*` und `astro/runtime/server/*` importieren.

Astro v3.0 entfernt die beiden Einstiegspunkte zugunsten des vorhandenen Einstiegspunkts `astro/runtime/*`. Zus√§tzlich wurde ein neuer Export `astro/compiler-runtime` f√ºr compiler-spezifischen Laufzeitcode hinzugef√ºgt.

#### Was soll ich tun?

Diese sind Einstiegspunkte f√ºr Astro's interne API und sollten sich nicht auf dein Projekt auswirken. Aber wenn du diese Einstiegspunkte verwendest, aktualisiere sie wie unten gezeigt:


```js del={1,4,10} ins={2,5,11}
import 'astro/internal/index.js';
import 'astro/runtime/server/index.js';

import 'astro/server/index.js';
import 'astro/runtime/server/index.js';
```

```js ins={5} del={4}
import { transform } from '@astrojs/compiler';

const result = await transform(source, {
  internalURL: 'astro/runtime/server/index.js',
  internalURL: 'astro/compiler-runtime',
  // ...
});
```

## Community Ressourcen

Du kennst eine gute Ressource f√ºr Astro v3.0? [Bearbeite diese Seite](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/upgrade-to/v3.mdx) und f√ºge unten einen Link hinzu!

## Bekannte Probleme

Es gibt derzeit keine bekannten Probleme.
