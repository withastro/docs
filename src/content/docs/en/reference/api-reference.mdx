---
title: Astro render context
i18nReady: true
tableOfContents:
  minHeadingLevel: 2
  maxHeadingLevel: 4
---
import Since from '~/components/Since.astro';
import { Tabs, TabItem } from '@astrojs/starlight/components';
import ReadMore from '~/components/ReadMore.astro';

When rendering a page, Astro provides a runtime API specific to the current render. This includes useful information such as the current page URL as well as APIs to perform actions like redirecting to another page.

In `.astro` components, this context is available from the `Astro` global object. Endpoint functions are also called with this same context object as their first argument, whose properties mirror many of the Astro global properties.

Some properties are only available for pages rendered on demand, or may have limited functionality on prerendered pages.

The `Astro` global object is available to all `.astro` files. Use the `context` object in [endpoint functions](/en/guides/endpoints/) to serve static or live server endpoints and in [middleware](/en/guides/middleware/) to inject behavior when a page or end point is about to be rendered.

## The context object

The following items are available on the `Astro` global (e.g. `Astro.props`, `Astro.redirect()`) and most are also available on an endpoint context object (e.g. `context.props`, `context.redirect()`).

### `props`

`props` is an object containing any values that have been passed as [component attributes](/en/basics/astro-components/#component-props). Layout components for `.md` and `.mdx` files receive frontmatter values as props.

```astro {3}
---
// src/components/Heading.astro
const { title, date } = Astro.props;
---
<div>
  <h1>{title}</h1>
  <p>{date}</p>
</div>
```

```astro /title=".+"/ /date=".+"/
---
// src/pages/index.astro
import Heading from '../components/Heading.astro';
---
<Heading title="My First Post" date="09 Aug 2022" />
```

<ReadMore>Learn more about how [Markdown and MDX Layouts](/en/guides/markdown-content/#frontmatter-layout-property) handle props.</ReadMore>


`context.props` is an object containing any `props` passed from `getStaticPaths()`. Because `getStaticPaths()` is not used when building for SSR (server-side rendering), `context.props` is only available in static builds.

```ts title="src/pages/posts/[id].json.ts"
import type { APIContext } from 'astro';

export function getStaticPaths() {
  return [
    { params: { id: '1' }, props: { author: 'Blu' } },
    { params: { id: '2' }, props: { author: 'Erika' } },
    { params: { id: '3' }, props: { author: 'Matthew' } }
  ];
}

export function GET({ props }: APIContext) {
	return new Response(
    JSON.stringify({ author: props.author }),
  );
}
```

See also: [Data Passing with `props`](/en/reference/routing-reference/#data-passing-with-props)

### `params`

`params` is an object containing the values of dynamic route segments matched for this request.

In static builds, this will be the `params` returned by `getStaticPaths()` used for prerendering [dynamic routes](/en/guides/routing/#dynamic-routes).

<Tabs>
  <TabItem label="Astro.params">
    ```astro title="src/pages/posts/[id].astro" "Astro.params"
    ---
    export function getStaticPaths() {
      return [
        { params: { id: '1' } },
        { params: { id: '2' } },
        { params: { id: '3' } }
      ];
    }
    const { id } = Astro.params;
    ---
    <h1>{id}</h1>
    ```
  </TabItem>
  <TabItem label="context.params">
    ```ts title="src/pages/posts/[id].json.ts" "params.id"
    import type { APIContext } from 'astro';

    export function getStaticPaths() {
      return [
        { params: { id: '1' } },
        { params: { id: '2' } },
        { params: { id: '3' } }
      ];
    }

    export function GET({ params }: APIContext) {
      return new Response(
        JSON.stringify({ id: params.id }),
      );
    }
    ```
  </TabItem>
</Tabs>


In SSR builds, this can be any value matching the path segments in the dynamic route pattern.

```astro title="src/pages/posts/[id].astro" "Astro.params"
---
import { getPost } from '../api';

const post = await getPost(Astro.params.id);

// No posts found with this ID
if (!post) {
  Astro.redirect("/404")
}
---
<html>
  <h1>{post.name}</h1>
</html>
```

See also: [`params`](/en/reference/routing-reference/#params)

### `url`

<p>

**Type:** `URL`<br />
<Since v="1.0.0" />
</p>

`url` is a [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL) object constructed from the current `request.url` URL string value. Useful for interacting with individual properties of the request URL, like pathname and origin. 

Equivalent to doing `new URL(Astro.request.url)`.

`url` will be `localhost` in dev mode if [`site`](/en/reference/configuration-reference/#site) is not configured for static sites, and for on-demand rendered sites using `server` or `hybrid` output.

```astro
<h1>The current URL is: {Astro.url}</h1>
<h1>The current URL pathname is: {Astro.url.pathname}</h1>
<h1>The current URL origin is: {Astro.url.origin}</h1>
```

You can also use `url` to create new URLs by passing it as an argument to [`new URL()`](https://developer.mozilla.org/en-US/docs/Web/API/URL/URL).

```astro title="src/pages/index.astro"
---
// Example: Construct a canonical URL using your production domain
const canonicalURL = new URL(Astro.url.pathname, Astro.site);
// Example: Construct a URL for SEO meta tags using your current domain
const socialImageURL = new URL('/images/preview.png', Astro.url);
---
<link rel="canonical" href={canonicalURL} />
<meta property="og:image" content={socialImageURL} />
```

### `site`

<p>

**Type:** `URL | undefined`
</p>

`Astro.site` returns a `URL` made from `site` in your Astro config. If `site` in your Astro config isn't defined, `Astro.site` won't be defined.

`context.site` returns a `URL` made from `site` in your Astro config. If undefined, this will return a URL generated from `localhost`.

### `clientAddress`

<p>

**Type:** `string`<br />
<Since v="1.0.0" />
</p>

`clientAddress` specifies the [IP address](https://en.wikipedia.org/wiki/IP_address) of the request. This property is only available for routes rendered on demand and cannot be used on prerendered pages.

<Tabs>
  <TabItem label="Astro.clientAddress">
    ```astro
    ---
    export const prerender = false;
    const ip = Astro.clientAddress;
    ---

    <div>Your IP address is: <span class="address">{ ip }</span></div>
    ```
  </TabItem>
  <TabItem label="context.clientAddress">
    ```ts
    export const prerender = false;
    import type { APIContext } from 'astro';

    export function GET({ clientAddress }: APIContext) {
      return new Response(`Your IP address is: ${clientAddress}`);
    }
    ```
  </TabItem>
</Tabs>

### `generator`

<p>

**Type:** `string`<br />
<Since v="1.0.0" />
</p>

`generator` provides the current version of Astro your project is running. This is a convenient way to add a [`<meta name="generator">`](https://html.spec.whatwg.org/multipage/semantics.html#meta-generator) tag with your current version of Astro. It follows the format `"Astro v5.x.x"`.

<Tabs>
  <TabItem label="Astro.generator">
    ```astro mark="Astro.generator"
    <html>
      <head>
        <meta name="generator" content={Astro.generator} />
      </head>
      <body>
        <footer>
          <p>Built with <a href="https://astro.build">{Astro.generator}</a></p>
        </footer>
      </body>
    </html>
    ```
  </TabItem>
  <TabItem label="context.generator">
    ```ts title="src/pages/site-info.json.ts"
    import type { APIContext } from 'astro';

    export function GET({ generator, site }: APIContext) {
      const body = JSON.stringify({ generator, site });
      return new Response(body);
    }
    ```
  </TabItem>
</Tabs>

### `request`

<p>

**Type:** `Request`
</p>

`request` is a standard [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) object. It can be used to get the `url`, `headers`, `method`, and even body of the request. 

<Tabs>
  <TabItem label="Astro.request">
    ```astro wrap title="src/pages/index.astro" "Astro.request"
    <p>Received a {Astro.request.method} request to "{Astro.request.url}".</p>
    <p>Received request headers:</p>
    <p><code>{JSON.stringify(Object.fromEntries(Astro.request.headers))}</code></p>
    ```
  </TabItem>
  <TabItem label="context.request">
    ```ts "request"
    import type { APIContext } from 'astro';

    export function GET({ request }: APIContext) {
      return new Response(`Hello ${request.url}`);
    }
    ```
  </TabItem>
</Tabs>

:::note
On prerendered pages, `request.url` does not contain search parameters, like `?foo=bar`, as it's not possible to determine them ahead of time during static builds. However, `request.url` does contain search parameters for pages rendered on-demand as they can be determined from a server request.
:::

### `response`

<p>

**Type:** `ResponseInit & { readonly headers: Headers }`
</p>

`response` is a standard `ResponseInit` object. It has the following structure. 

 - `status`: The numeric status code of the response, e.g., `200`.
 - `statusText`: The status message associated with the status code, e.g., `'OK'`.
 - `headers`: A [`Headers`](https://developer.mozilla.org/en-US/docs/Web/API/Headers) instance that you can use to set the HTTP headers of the response.

`Astro.response` is used to set the `status`, `statusText`, and `headers` for a page's response.


```astro
---
if(condition) {
  Astro.response.status = 404;
  Astro.response.statusText = 'Not found';
}
---
```

Or to set a header:

```astro
---
Astro.response.headers.set('Set-Cookie', 'a=b; Path=/;');
---
```

### `redirect()`

<p>

**Type:** `(path: string, status?: number) => Response`
<Since v="1.5.0" />
</p>

`redirect()` returns a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) object that allows you to redirect to another page, and optionally provide an [HTTP response status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages) as a second parameter.

A page (and not a child component) must `return` the result of `Astro.redirect()` for the redirect to occur.

For statically-generated sites, this will produce a client redirect using a [`<meta http-equiv="refresh">` tag](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#http-equiv) and does not support status codes.

When using an on-demand rendering mode, status codes are supported. Astro will serve redirected requests with a default HTTP response status of `302` unless another code is specified.

The following example redirects a user to a login page:

<Tabs>
  <TabItem label="Astro.redirect()">
    ```astro title="src/pages/account.astro" {8}
    ---
    import { isLoggedIn } from '../utils';

    const cookie = Astro.request.headers.get('cookie');

    // If the user is not logged in, redirect them to the login page
    if (!isLoggedIn(cookie)) {
      return Astro.redirect('/login');
    }
    ---
    ```
  </TabItem>
  <TabItem label="context.redirect()">
    ```ts
    import type { APIContext } from 'astro';

    export function GET({ redirect }: APIContext) {
      return redirect('/login', 302);
    }
    ```
  </TabItem>
</Tabs>


### `rewrite()`

<p>

**Type:** `(rewritePayload: string | URL | Request) => Promise<Response>`<br />
<Since v="4.13.0" />
</p>

`rewrite()` allows you to serve content from a different URL or path without redirecting the browser to a new page. 

The method accepts either a string, a `URL`, or a `Request` for the location of the path.

Use a string to provide an explicit path:

<Tabs>
  <TabItem label="Astro.rewrite()">
    ```astro title="src/pages/index.astro"
    ---
    return Astro.rewrite("/login")
    ---
    ```
  </TabItem>
  <TabItem label="context.rewrite()">
    ```ts
    import type { APIContext } from 'astro';

    export function GET({ rewrite }: APIContext) {
      return rewrite('/login');
    }
    ```
  </TabItem>
</Tabs>

Use a `URL` type when you need to construct the URL path for the rewrite. The following example renders a page's parent path by creating a new URL from the relative  `"../"` path:

<Tabs>
  <TabItem label="Astro.rewrite()">
    ```astro title="src/pages/blog/index.astro"
    ---
    return Astro.rewrite(new URL("../", Astro.url))
    ---
    ```
  </TabItem>
  <TabItem label="context.rewrite()">
    ```ts
    import type { APIContext } from 'astro';

    export function GET({ rewrite }: APIContext) {
      return rewrite(new URL("../", Astro.url));
    }
    ```
  </TabItem>
</Tabs>

Use a `Request` type for complete control of the `Request` sent to the server for the new path. The following example sends a request to render the parent page while also providing headers:

<Tabs>
  <TabItem label="Astro.rewrite()">
    ```astro title="src/pages/blog/index.astro"
    ---
    return Astro.rewrite(new Request(new URL("../", Astro.url), {
      headers: {
        "x-custom-header": JSON.stringify(Astro.locals.someValue)
      }
    }))
    ---
    ```
  </TabItem>
  <TabItem label="context.rewrite()">
    ```ts
    import type { APIContext } from 'astro';

    export function GET({ rewrite }: APIContext) {
      return rewrite(new Request(new URL("../", Astro.url), {
      headers: {
        "x-custom-header": JSON.stringify(Astro.locals.someValue)
      }
    }));
    }
    ```
  </TabItem>
</Tabs>

### `locals`

<p>

<Since v="2.4.0" />
</p>

`locals` is an  object used to store and access arbitrary information during the lifecycle of a request. `Astro.locals` is an object containing any values from the `context.locals` object from a middleware. Use this to access data returned by middleware in your `.astro` files.

Middleware functions can read and write the values of `context.locals`:

```ts title="src/middleware.ts"
import type { MiddlewareHandler } from 'astro';

export const onRequest: MiddlewareHandler = ({ locals }, next) => {
  if (!locals.title) {
    locals.title = "Default Title";
  }
  return next();
}
```

`Astro.locals` is read only for Astro components and `context.locals` is read only for API endpoints:

<Tabs>
  <TabItem label="Astro.locals">
    ```astro title="src/pages/Orders.astro"
    ---
    const title = Astro.locals.welcomeTitle();
    const orders = Array.from(Astro.locals.orders.entries());
    ---
    <h1>{title}</h1>
    <ul>
        {orders.map(order => {
            return <li>{/* do something with each order */}</li>
        })}
    </ul>
    ```
  </TabItem>
  <TabItem label="context.locals">
    ```ts title="src/pages/hello.ts"
    import type { APIContext } from 'astro';

    export function GET({ locals }: APIContext) {
      return new Response(locals.title); // "Default Title"
    }
    ```
  </TabItem>
</Tabs>


### `getActionResult()`

<p>
**Type:** `(action: TAction) => ActionReturnType<TAction> | undefined`<br />
<Since v="4.15.0" />
</p>

`getActionResult()` is a function that returns the result of an [Action](/en/guides/actions/) submission. This accepts an action function as an argument (e.g. `actions.logout`) and returns a `data` or `error` object when a submission is received. Otherwise, it will return `undefined`.

```astro title="src/pages/index.astro"
---
import { actions } from 'astro:actions';

const result = Astro.getActionResult(actions.logout);
---

<form action={actions.logout}>
  <button type="submit">Log out</button>
</form>
{result?.error && <p>Failed to log out. Please try again.</p>}
```

### `callAction()`

<p>
<Since v="4.15.0" />
</p>

`callAction()` is a function used to call an Action handler directly from your Astro component. This function accepts an Action function as the first argument (e.g. `actions.logout`) and any input that action receives as the second argument. It returns the result of the action as a promise.

```astro title="src/pages/index.astro"
---
import { actions } from 'astro:actions';

const { data, error } = await Astro.callAction(actions.logout, { userId: '123' });
---
```

### `routePattern`

<p>

**Type**: `string`<br />
<Since v="5.0.0" />
</p>

The route pattern responsible for generating the current page or route. In file-based routing, this resembles the file path in your project used to create the route. When integrations create routes for your project, `context.routePattern` is identical to the value for `injectRoute.pattern`.

The value will start with a leading slash and look similar to the path of a page component relative to your `srcDir/pages/` folder without a file extension.

For example, the file `src/pages/en/blog/[slug].astro` will return `/en/blog/[slug]` for `context.routePattern`. Every page on your site generated by that file (e.g. `/en/blog/post-1/`, `/en/blog/post-2/`, etc.) shares the same value for `context.routePattern`. In the case of `index.*` routes, the route pattern will not include the word "index." For example, `src/pages/index.astro` will return `/`.

You can use this property to understand which route is rendering your component. This allows you to target or analyze similarly-generated page URLs together. For example, you can use it to conditionally render certain information, or collect metrics about which routes are slower.

### `isPrerendered`

<p>

**Type**: `boolean`<br />
<Since v="5.0.0" />
</p>

A boolean representing whether or not the current page is prerendered.

You can use this property to run conditional logic in middleware, for example, to avoid accessing headers in prerendered pages.

## WIP 1

The `cookies` entry is minimal in `context` docs and this is very heavily skewed towards `Astro.cookies` (e.g. types). How to generalize?

### `Astro.cookies`

<p>

**Type:** `AstroCookies`<br />
<Since v="1.4.0" />
</p>

`cookies` contains utilities for reading and manipulating cookies in [server-side rendering](/en/guides/server-side-rendering/) mode.

#### Cookie utilities

##### `get`

<p>

**Type:** <code>(key: string, options?: <a href="#astrocookiegetoptions">AstroCookieGetOptions</a>) => <a href="#astrocookie">AstroCookie</a> | undefined</code>
</p>

Gets the cookie as an [`AstroCookie`](#astrocookie) object, which contains the `value` and utility functions for converting the cookie to non-string types.

##### `has`

<p>

**Type:** <code>(key: string, options?: <a href="#astrocookiegetoptions">AstroCookieGetOptions</a>) => boolean</code>
</p>

Whether this cookie exists. If the cookie has been set via `Astro.cookies.set()` this will return true, otherwise it will check cookies in the `Astro.request`.

##### `set`

<p>

**Type:** <code>(key: string, value: string | object, options?: <a href="#astrocookiesetoptions">AstroCookieSetOptions</a>) => void</code>
</p>

Sets the cookie `key` to the given value. This will attempt to convert the cookie value to a string. Options provide ways to set [cookie features](https://www.npmjs.com/package/cookie#options-1), such as the `maxAge` or `httpOnly`.

##### `delete`

<p>

**Type:** `(key: string, options?: AstroCookieDeleteOptions) => void`
</p>

Invalidates a cookie by setting the expiration date in the past (0 in Unix time).

Once a cookie is "deleted" (expired), `Astro.cookies.has()` will return `false` and `Astro.cookies.get()` will return an [`AstroCookie`](#astrocookie) with a `value` of `undefined`. Options available when deleting a cookie are: `domain`, `path`, `httpOnly`, `sameSite`, and `secure`.

##### `merge`

<p>

**Type:** `(cookies: AstroCookies) => void`
</p>

Merges a new `AstroCookies` instance into the current instance. Any new cookies will be added to the current instance and any cookies with the same name will overwrite existing values.

##### `headers`

<p>

**Type:** `() => Iterator<string>`
</p>

Gets the header values for `Set-Cookie` that will be sent out with the response.

#### `AstroCookie`

Getting a cookie via `Astro.cookies.get()` returns a `AstroCookie` type. It has the following structure.

##### `value`

<p>

**Type:** `string`
</p>

The raw string value of the cookie.

##### `json`

<p>

**Type:** `() => Record<string, any>`
</p>

Parses the cookie value via `JSON.parse()`, returning an object. Throws if the cookie value is not valid JSON.

##### `number`

<p>

**Type:** `() => number`
</p>

Parses the cookie value as a Number. Returns NaN if not a valid number.

##### `boolean`

<p>

**Type:** `() => boolean`
</p>

Converts the cookie value to a boolean.

#### `AstroCookieGetOptions`

<p><Since v="4.1.0"/></p>

Getting a cookie also allows specifying options via the `AstroCookieGetOptions` interface:

##### `decode`

<p>
**Type:** `(value: string) => string`
</p>

Allows customization of how a cookie is deserialized into a value.

#### `AstroCookieSetOptions`

<p><Since v="4.1.0"/></p>

Setting a cookie via `Astro.cookies.set()` allows passing in a `AstroCookieSetOptions` to customize how the cookie is serialized.

##### `domain`

<p>

**Type:** `string`
</p>

 Specifies the domain. If no domain is set, most clients will interpret to apply to the current domain.

##### `expires`

<p>

**Type:** `Date`
</p>

Specifies the date on which the cookie will expire.

##### `httpOnly`

<p>

**Type:** `boolean`
</p>

If true, the cookie will not be accessible client-side.

##### `maxAge`

<p>

**Type:** `number`
</p>

Specifies a number, in seconds, for which the cookie is valid.

##### `path`

<p>

**Type:** `string`
</p>

Specifies a subpath of the domain in which the cookie is applied.

##### `sameSite`

<p>

**Type:** `boolean | 'lax' | 'none' | 'strict'`
</p>

Specifies the value of the [SameSite](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-09#section-5.4.7) cookie header.

##### `secure`

<p>

**Type:** `boolean`
</p>

If true, the cookie is only set on https sites.

##### `encode`

<p>

**Type:** `(value: string) => string`
</p>

Allows customizing how the cookie is serialized.

## WIP 2

These do not have corresponding `context` entries in current docs

### `Astro.preferredLocale`

<p>

**Type:** `string | undefined`<br />
<Since v="3.5.0" />
</p>

`Astro.preferredLocale` is a computed value that represents the preferred locale of the user. 

It is computed by checking the configured locales in your `i18n.locales` array and locales supported by the users's browser via the header `Accept-Language`. This value is `undefined` if no such match exists.

This property is only available when building for SSR (server-side rendering) and should not be used for static sites.

### `Astro.preferredLocaleList`

<p>

**Type:** `string[] | undefined`<br />
<Since v="3.5.0" />
</p>

`preferredLocaleList` represents the array of all locales that are both requested by the browser and supported by your website. This produces a list of all compatible languages between your site and your visitor. 

If none of the browser's requested languages are found in your locales array, then the value is `[]`: you do not support any of your visitor's preferred locales.

If the browser does not specify any preferred languages, then this value will be [`i18n.locales`](/en/reference/configuration-reference/#i18nlocales): all of your supported locales will be considered equally preferred by a visitor with no preferences. 

This property is only available when building for SSR (server-side rendering) and should not be used for static sites.

### `Astro.currentLocale`

<p>

**Type:** `string | undefined`<br />
<Since v="3.5.6" />
</p>

The locale computed from the current URL, using the syntax specified in your `locales` configuration. If the URL does not contain a `/[locale]/` prefix, then the value will default to `i18n.defaultLocale`.

## WIP 3

This one is fine; will be deprecated. Stick it at the end when we're done.

### `Astro.glob()`

:::caution[Deprecated in v5.0]
Use [Vite's `import.meta.glob`](https://vite.dev/guide/features.html#glob-import) to query project files. 

`Astro.glob('../pages/post/*.md')` can be replaced with:

`Object.values(await import.meta.glob('../pages/post/*.md', { eager: true }));`

See the [imports guide](/en/guides/imports/#importmetaglob) for more information and usage.
:::

`Astro.glob()` is a way to load many local files into your static site setup.

```astro
---
// src/components/my-component.astro
const posts = await Astro.glob('../pages/post/*.md'); // returns an array of posts that live at ./src/pages/post/*.md
---

<div>
{posts.slice(0, 3).map((post) => (
  <article>
    <h2>{post.frontmatter.title}</h2>
    <p>{post.frontmatter.description}</p>
    <a href={post.url}>Read more</a>
  </article>
))}
</div>
```

`.glob()` only takes one parameter: a relative URL glob of which local files you'd like to import. It’s asynchronous, and returns an array of the exports from matching files.

`.glob()` can't take variables or strings that interpolate them, as they aren't statically analyzable. (See [the imports guide](/en/guides/imports/#supported-values) for a workaround.) This is because `Astro.glob()` is a wrapper of Vite's [`import.meta.glob()`](https://vite.dev/guide/features.html#glob-import).

:::note
You can also use `import.meta.glob()` itself in your Astro project. You may want to do this when:
- You need this feature in a file that isn't `.astro`, like an API route. `Astro.glob()` is only available in `.astro` files, while `import.meta.glob()` is available anywhere in the project.
- You don't want to load each file immediately. `import.meta.glob()` can return functions that import the file content, rather than returning the content itself. Note that this import includes all styles and scripts for any imported files. These will be bundled and added to the page whether or not a file is actually used, as this is decided by static analysis, not at runtime.
- You want access to each file's path. `import.meta.glob()` returns a map of a file's path to its content, while `Astro.glob()` returns a list of content.
- You want to pass multiple patterns; for example, you want to add a "negative pattern" that filters out certain files. `import.meta.glob()` can optionally take an array of glob strings, rather than a single string.

Read more in the [Vite documentation](https://vite.dev/guide/features.html#glob-import).
:::

#### Markdown Files

Markdown files loaded with `Astro.glob()` return the following `MarkdownInstance` interface:

```ts
export interface MarkdownInstance<T extends Record<string, any>> {
  /* Any data specified in this file's YAML frontmatter */
	frontmatter: T;
  /* The absolute file path of this file */
	file: string;
  /* The rendered path of this file */
	url: string | undefined;
  /* Astro Component that renders the contents of this file */
	Content: AstroComponentFactory;
  /** (Markdown only) Raw Markdown file content, excluding layout HTML and YAML frontmatter */
	rawContent(): string;
  /** (Markdown only) Markdown file compiled to HTML, excluding layout HTML */
	compiledContent(): string;
  /* Function that returns an array of the h1...h6 elements in this file */
	getHeadings(): Promise<{ depth: number; slug: string; text: string }[]>;
	default: AstroComponentFactory;
}
```

You can optionally provide a type for the `frontmatter` variable using a TypeScript generic.

```astro
---
interface Frontmatter {
  title: string;
  description?: string;
}
const posts = await Astro.glob<Frontmatter>('../pages/post/*.md');
---

<ul>
  {posts.map(post => <li>{post.frontmatter.title}</li>)}
</ul>
```

#### Astro Files

Astro files have the following interface:

```ts
export interface AstroInstance {
  /* The file path of this file */
  file: string;
  /* The URL for this file (if it is in the pages directory) */
	url: string | undefined;
	default: AstroComponentFactory;
}
```

#### Other Files

Other files may have various different interfaces, but `Astro.glob()` accepts a TypeScript generic if you know exactly what an unrecognized file type contains.

```ts
---
interface CustomDataFile {
  default: Record<string, any>;
}
const data = await Astro.glob<CustomDataFile>('../data/**/*.js');
---
```

## Component syntax

### `Astro.slots`

`Astro.slots` contains utility functions for modifying an Astro component's slotted children.

#### `Astro.slots.has()`

<p>

**Type:** `(slotName: string) => boolean`
</p>

You can check whether content for a specific slot name exists with `Astro.slots.has()`. This can be useful when you want to wrap slot contents, but only want to render the wrapper elements when the slot is being used.

```astro  title="src/pages/index.astro"
---
---
<slot />

{Astro.slots.has('more') && (
  <aside>
    <h2>More</h2>
    <slot name="more" />
  </aside>
)}
```

#### `Astro.slots.render()`

<p>

**Type:** `(slotName: string, args?: any[]) => Promise<string>`
</p>

You can asynchronously render the contents of a slot to a string of HTML using `Astro.slots.render()`.

```astro
---
const html = await Astro.slots.render('default');
---
<Fragment set:html={html} />
```

:::note
This is for advanced use cases! In most circumstances, it is simpler to render slot contents with [the `<slot />` element](/en/basics/astro-components/#slots).
:::

`Astro.slots.render()` optionally accepts a second argument: an array of parameters that will be forwarded to any function children. This can be useful for custom utility components.

For example, this `<Shout />` component converts its `message` prop to uppercase and passes it to the default slot:

```astro title="src/components/Shout.astro" "await Astro.slots.render('default', [message])"
---
const message = Astro.props.message.toUpperCase();
let html = '';
if (Astro.slots.has('default')) {
  html = await Astro.slots.render('default', [message]);
}
---
<Fragment set:html={html} />
```

A callback function passed as `<Shout />`’s child will receive the all-caps `message` parameter:

```astro title="src/pages/index.astro"
---
import Shout from "../components/Shout.astro";
---
<Shout message="slots!">
  {(message) => <div>{message}</div>}
</Shout>

<!-- renders as <div>SLOTS!</div> -->
```

Callback functions can be passed to named slots inside a wrapping HTML element tag with a `slot` attribute. This element is only used to transfer the callback to a named slot and will not be rendered onto the page.

```astro
<Shout message="slots!">
  <fragment slot="message">
    {(message) => <div>{message}</div>}
  </fragment>
</Shout>
```

Use a standard HTML element for the wrapping tag, or any lower case tag (e.g. `<fragment>` instead of `<Fragment />`) that will not be interpreted as a component.  Do not use the HTML `<slot>` element as this will be interpreted as an Astro slot.

### `Astro.self`

`Astro.self` allows Astro components to be recursively called. This behaviour lets you render an Astro component from within itself by using `<Astro.self>` in the component template. This can be helpful for iterating over large data stores and nested data-structures.

```astro
---
// NestedList.astro
const { items } = Astro.props;
---
<ul class="nested-list">
  {items.map((item) => (
    <li>
      <!-- If there is a nested data-structure we render `<Astro.self>` -->
      <!-- and can pass props through with the recursive call -->
      {Array.isArray(item) ? (
        <Astro.self items={item} />
      ) : (
        item
      )}
    </li>
  ))}
</ul>
```

This component could then be used like this:

```astro
---
import NestedList from './NestedList.astro';
---
<NestedList items={['A', ['B', 'C'], 'D']} />
```

And would render HTML like this:

```html
<ul class="nested-list">
  <li>A</li>
  <li>
    <ul class="nested-list">
      <li>B</li>
      <li>C</li>
    </ul>
  </li>
  <li>D</li>
</ul>
```

-----
