---
# NOTE: This file is auto-generated from 'scripts/docgen.mjs'
# Do not make edits to it directly, they will be overwritten.
# Instead, change this file: https://github.com/withastro/astro/blob/main/packages/astro/src/%40types/astro.ts
# Translators, please remove this note and the <DontEditWarning/> component. 

title: Configuration Reference
i18nReady: true
githubURL: https://github.com/withastro/astro/blob/main/packages/astro/src/%40types/astro.ts
---

import Since from '~/components/Since.astro'
import DontEditWarning from '~/components/DontEditWarning.astro'

<DontEditWarning />

The following reference covers all supported configuration options in Astro. To learn more about configuring Astro, read our guide on [Configuring Astro](/en/guides/configuring-astro/).

```js
// astro.config.mjs
import { defineConfig } from 'astro/config'

export default defineConfig({
  // your configuration options here...
})
```
## Top-Level Options


### site

<p>

**Type:** `string`
</p>

Your final, deployed URL. Astro uses this full URL to generate your sitemap and canonical URLs in your final build. It is strongly recommended that you set this configuration to get the most out of Astro.

```js
{
  site: 'https://www.my-site.dev'
}
```

### base

<p>

**Type:** `string`
</p>

The base path to deploy to. Astro will use this path as the root for your pages and assets both in development and in production build.

In the example below, `astro dev` will start your server at `/docs`.

```js
{
  base: '/docs'
}
```

When using this option, all of your static asset imports and URLs should add the base as a prefix. You can access this value via `import.meta.env.BASE_URL`.

The value of `import.meta.env.BASE_URL` will be determined by your `trailingSlash` config, no matter what value you have set for `base`.

A trailing slash is always included if `trailingSlash: "always"` is set. If `trailingSlash: "never"` is set, `BASE_URL` will not include a trailing slash, even if `base` includes one.

Additionally, Astro will internally manipulate the configured value of `config.base` before making it available to integrations. The value of `config.base` as read by integrations will also be determined by your `trailingSlash` configuration in the same way.

In the example below, the values of `import.meta.env.BASE_URL` and `config.base` when processed will both be `/docs`:
```js
{
	 base: '/docs/',
	 trailingSlash: "never"
}
```

In the example below, the values of `import.meta.env.BASE_URL` and `config.base` when processed will both be `/docs/`:

```js
{
	 base: '/docs',
	 trailingSlash: "always"
}
```

### trailingSlash

<p>

**Type:** `'always' | 'never' | 'ignore'`<br />
**Default:** `'ignore'`
</p>

Set the route matching behavior of the dev server. Choose from the following options:
  - `'always'` - Only match URLs that include a trailing slash (ex: "/foo/")
  - `'never'` - Never match URLs that include a trailing slash (ex: "/foo")
  - `'ignore'` - Match URLs regardless of whether a trailing "/" exists

Use this configuration option if your production host has strict handling of how trailing slashes work or do not work.

You can also set this if you prefer to be more strict yourself, so that URLs with or without trailing slashes won't work during development.

```js
{
  // Example: Require a trailing slash during development
  trailingSlash: 'always'
}
```
**See Also:**
- build.format

### redirects

<p>

**Type:** `Record.<string, RedirectConfig>`<br />
**Default:** `{}`<br />
<Since v="2.9.0" />
</p>

Specify a mapping of redirects where the key is the route to match
and the value is the path to redirect to.

You can redirect both static and dynamic routes, but only to the same kind of route.
For example you cannot have a `'/article': '/blog/[...slug]'` redirect.


```js
{
  redirects: {
    '/old': '/new',
    '/blog/[...slug]': '/articles/[...slug]',
  }
}
```


For statically-generated sites with no adapter installed, this will produce a client redirect using a [`<meta http-equiv="refresh">` tag](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#http-equiv) and does not support status codes.

When using SSR or with a static adapter in `output: static`
mode, status codes are supported.
Astro will serve redirected GET requests with a status of `301`
and use a status of `308` for any other request method.

You can customize the [redirection status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages) using an object in the redirect config:

```js
{
  redirects: {
    '/other': {
      status: 302,
      destination: '/place',
    },
  }
}
```

### output

<p>

**Type:** `'static' | 'server' | 'hybrid'`<br />
**Default:** `'static'`
</p>

Specifies the output target for builds.

- `'static'` - Building a static site to be deployed to any static host.
- `'server'` - Building an app to be deployed to a host supporting SSR (server-side rendering).
- `'hybrid'` - Building a static site with a few server-side rendered pages.

```js
import { defineConfig } from 'astro/config';

export default defineConfig({
  output: 'static'
})
```
**See Also:**
- adapter

### adapter

<p>

**Type:** `AstroIntegration`
</p>

Deploy to your favorite server, serverless, or edge host with build adapters. Import one of our first-party adapters for [Netlify](/en/guides/deploy/netlify/#adapter-for-ssr), [Vercel](/en/guides/deploy/vercel/#adapter-for-ssr), and more to engage Astro SSR.

[See our Server-side Rendering guide](/en/guides/server-side-rendering/) for more on SSR, and [our deployment guides](/en/guides/deploy/) for a complete list of hosts.

```js
import netlify from '@astrojs/netlify';
{
  // Example: Build for Netlify serverless deployment
  adapter: netlify(),
}
```
**See Also:**
- output

### integrations

<p>

**Type:** `AstroIntegration[]`
</p>

Extend Astro with custom integrations. Integrations are your one-stop-shop for adding framework support (like Solid.js), new features (like sitemaps), and new libraries (like Partytown).

Read our [Integrations Guide](/en/guides/integrations-guide/) for help getting started with Astro Integrations.

```js
import react from '@astrojs/react';
import tailwind from '@astrojs/tailwind';
{
  // Example: Add React + Tailwind support to Astro
  integrations: [react(), tailwind()]
}
```

### root

<p>

**Type:** `string`<br />
**CLI:** `--root`<br />
**Default:** `"."` (current working directory)
</p>

You should only provide this option if you run the `astro` CLI commands in a directory other than the project root directory. Usually, this option is provided via the CLI instead of the [Astro config file](/en/guides/configuring-astro/#supported-config-file-types), since Astro needs to know your project root before it can locate your config file.

If you provide a relative path (ex: `--root: './my-project'`) Astro will resolve it against your current working directory.

#### Examples

```js
{
  root: './my-project-directory'
}
```
```bash
$ astro build --root ./my-project-directory
```

### srcDir

<p>

**Type:** `string`<br />
**Default:** `"./src"`
</p>

Set the directory that Astro will read your site from.

The value can be either an absolute file system path or a path relative to the project root.

```js
{
  srcDir: './www'
}
```

### publicDir

<p>

**Type:** `string`<br />
**Default:** `"./public"`
</p>

Set the directory for your static assets. Files in this directory are served at `/` during dev and copied to your build directory during build. These files are always served or copied as-is, without transform or bundling.

The value can be either an absolute file system path or a path relative to the project root.

```js
{
  publicDir: './my-custom-publicDir-directory'
}
```

### outDir

<p>

**Type:** `string`<br />
**Default:** `"./dist"`
</p>

Set the directory that `astro build` writes your final build to.

The value can be either an absolute file system path or a path relative to the project root.

```js
{
  outDir: './my-custom-build-directory'
}
```
**See Also:**
- build.server

### cacheDir

<p>

**Type:** `string`<br />
**Default:** `"./node_modules/.astro"`
</p>

Set the directory for caching build artifacts. Files in this directory will be used in subsequent builds to speed up the build time.

The value can be either an absolute file system path or a path relative to the project root.

```js
{
  cacheDir: './my-custom-cache-directory'
}
```

### compressHTML

<p>

**Type:** `boolean`<br />
**Default:** `true`
</p>

This is an option to minify your HTML output and reduce the size of your HTML files.

By default, Astro removes whitespace from your HTML, including line breaks, from `.astro` components in a lossless manner.
Some whitespace may be kept as needed to preserve the visual rendering of your HTML. This occurs both in development mode and in the final build.

To disable HTML compression, set `compressHTML` to false.

```js
{
  compressHTML: false
}
```

### scopedStyleStrategy

<p>

**Type:** `'where' | 'class' | 'attribute'`<br />
**Default:** `'attribute'`<br />
<Since v="2.4" />
</p>

Specify the strategy used for scoping styles within Astro components. Choose from:
  - `'where'` 		- Use `:where` selectors, causing no specificity increase.
  - `'class'` 		- Use class-based selectors, causing a +1 specificity increase.
  - `'attribute'` 	- Use `data-` attributes, causing a +1 specificity increase.

Using `'class'` is helpful when you want to ensure that element selectors within an Astro component override global style defaults (e.g. from a global stylesheet).
Using `'where'` gives you more control over specificity, but requires that you use higher-specificity selectors, layers, and other tools to control which selectors are applied.
Using `'attribute'` is useful when you are manipulating the `class` attribute of elements and need to avoid conflicts between your own styling logic and Astro's application of styles.

### security

<p>

**Type:** `boolean`<br />
**Default:** `{}`<br />
<Since v="4.9.0" />
</p>

Enables security measures for an Astro website.

These features only exist for pages rendered on demand (SSR) using `server` mode or pages that opt out of prerendering in `hybrid` mode.

```js
// astro.config.mjs
export default defineConfig({
  output: "server",
  security: {
    checkOrigin: true
  }
})
```

#### security.checkOrigin

<p>

**Type:** `boolean`<br />
**Default:** 'false'<br />
<Since v="4.9.0" />
</p>

When enabled, performs a check that the "origin" header, automatically passed by all modern browsers, matches the URL sent by each `Request`. This is used to provide Cross-Site Request Forgery (CSRF) protection.

The "origin" check is executed only for pages rendered on demand, and only for the requests `POST`, `PATCH`, `DELETE` and `PUT` with
one of the following `content-type` headers: `'application/x-www-form-urlencoded'`, `'multipart/form-data'`, `'text/plain'`.

If the "origin" header doesn't match the `pathname` of the request, Astro will return a 403 status code and will not render the page.

### vite

<p>

**Type:** `ViteUserConfig`
</p>

Pass additional configuration options to Vite. Useful when Astro doesn't support some advanced configuration that you may need.

View the full `vite` configuration object documentation on [vitejs.dev](https://vitejs.dev/config/).

#### Examples

```js
{
  vite: {
    ssr: {
      // Example: Force a broken package to skip SSR processing, if needed
      external: ['broken-npm-package'],
    }
  }
}
```

```js
{
  vite: {
    // Example: Add custom vite plugins directly to your Astro project
    plugins: [myPlugin()],
  }
}
```

## Build Options


### build.format

<p>

**Type:** `('file' | 'directory' | 'preserve')`<br />
**Default:** `'directory'`
</p>

Control the output file format of each page. This value may be set by an adapter for you.
  - `'file'`: Astro will generate an HTML file named for each page route. (e.g. `src/pages/about.astro` and `src/pages/about/index.astro` both build the file `/about.html`)
  - `'directory'`: Astro will generate a directory with a nested `index.html` file for each page. (e.g. `src/pages/about.astro` and `src/pages/about/index.astro` both build the file `/about/index.html`)
  - `'preserve'`: Astro will generate HTML files exactly as they appear in your source folder. (e.g. `src/pages/about.astro` builds `/about.html` and `src/pages/about/index.astro` builds the file `/about/index.html`)

```js
{
  build: {
    // Example: Generate `page.html` instead of `page/index.html` during build.
    format: 'file'
  }
}
```



#### Effect on Astro.url
Setting `build.format` controls what `Astro.url` is set to during the build. When it is:
- `directory` - The `Astro.url.pathname` will include a trailing slash to mimic folder behavior; ie `/foo/`.
- `file` - The `Astro.url.pathname` will include `.html`; ie `/foo.html`.

This means that when you create relative URLs using `new URL('./relative', Astro.url)`, you will get consistent behavior between dev and build.

To prevent inconsistencies with trailing slash behaviour in dev, you can restrict the [`trailingSlash` option](#trailingslash) to `'always'` or `'never'` depending on your build format:
- `directory` - Set `trailingSlash: 'always'`
- `file` - Set `trailingSlash: 'never'`

### build.client

<p>

**Type:** `string`<br />
**Default:** `'./dist/client'`
</p>

Controls the output directory of your client-side CSS and JavaScript when `output: 'server'` or `output: 'hybrid'` only.
`outDir` controls where the code is built to.

This value is relative to the `outDir`.

```js
{
  output: 'server', // or 'hybrid'
  build: {
    client: './client'
  }
}
```

### build.server

<p>

**Type:** `string`<br />
**Default:** `'./dist/server'`
</p>

Controls the output directory of server JavaScript when building to SSR.

This value is relative to the `outDir`.

```js
{
  build: {
    server: './server'
  }
}
```

### build.assets

<p>

**Type:** `string`<br />
**Default:** `'_astro'`<br />
<Since v="2.0.0" />
</p>

Specifies the directory in the build output where Astro-generated assets (bundled JS and CSS for example) should live.

```js
{
  build: {
    assets: '_custom'
  }
}
```
**See Also:**
- outDir

### build.assetsPrefix

<p>

**Type:** `string | Record.<string, string>`<br />
**Default:** `undefined`<br />
<Since v="2.2.0" />
</p>

Specifies the prefix for Astro-generated asset links. This can be used if assets are served from a different domain than the current site.

This requires uploading the assets in your local `./dist/_astro` folder to a corresponding `/_astro/` folder on the remote domain.
To rename the `_astro` path, specify a new directory in `build.assets`.

To fetch all assets uploaded to the same domain (e.g. `https://cdn.example.com/_astro/...`), set `assetsPrefix` to the root domain as a string (regardless of your `base` configuration):

```js
{
  build: {
    assetsPrefix: 'https://cdn.example.com'
  }
}
```

**Added in:** `astro@4.5.0`

You can also pass an object to `assetsPrefix` to specify a different domain for each file type.
In this case, a `fallback` property is required and will be used by default for any other files.

```js
{
  build: {
    assetsPrefix: {
      'js': 'https://js.cdn.example.com',
      'mjs': 'https://js.cdn.example.com',
      'css': 'https://css.cdn.example.com',
      'fallback': 'https://cdn.example.com'
    }
  }
}
```

### build.serverEntry

<p>

**Type:** `string`<br />
**Default:** `'entry.mjs'`
</p>

Specifies the file name of the server entrypoint when building to SSR.
This entrypoint is usually dependent on which host you are deploying to and
will be set by your adapter for you.

Note that it is recommended that this file ends with `.mjs` so that the runtime
detects that the file is a JavaScript module.

```js
{
  build: {
    serverEntry: 'main.mjs'
  }
}
```

### build.redirects

<p>

**Type:** `boolean`<br />
**Default:** `true`<br />
<Since v="2.6.0" />
</p>

Specifies whether redirects will be output to HTML during the build.
This option only applies to `output: 'static'` mode; in SSR redirects
are treated the same as all responses.

This option is mostly meant to be used by adapters that have special
configuration files for redirects and do not need/want HTML based redirects.

```js
{
  build: {
    redirects: false
  }
}
```

### build.inlineStylesheets

<p>

**Type:** `'always' | 'auto' | 'never'`<br />
**Default:** `auto`<br />
<Since v="2.6.0" />
</p>

Control whether project styles are sent to the browser in a separate css file or inlined into `<style>` tags. Choose from the following options:
 - `'always'` - project styles are inlined into `<style>` tags
 - `'auto'` - only stylesheets smaller than `ViteConfig.build.assetsInlineLimit` (default: 4kb) are inlined. Otherwise, project styles are sent in external stylesheets.
 - `'never'` - project styles are sent in external stylesheets

```js
{
	build: {
		inlineStylesheets: `never`,
	},
}
```

## Server Options

Customize the Astro dev server, used by both `astro dev` and `astro preview`.

```js
{
  server: { port: 1234, host: true}
}
```

To set different configuration based on the command run ("dev", "preview") a function can also be passed to this configuration option.

```js
{
  // Example: Use the function syntax to customize based on command
  server: ({ command }) => ({ port: command === 'dev' ? 4321 : 4000 })
}
```

### server.host

<p>

**Type:** `string | boolean`<br />
**Default:** `false`<br />
<Since v="0.24.0" />
</p>

Set which network IP addresses the server should listen on (i.e. non-localhost IPs).
- `false` - do not expose on a network IP address
- `true` - listen on all addresses, including LAN and public addresses
- `[custom-address]` - expose on a network IP address at `[custom-address]` (ex: `192.168.0.1`)

### server.port

<p>

**Type:** `number`<br />
**Default:** `4321`
</p>

Set which port the server should listen on.

If the given port is already in use, Astro will automatically try the next available port.

```js
{
  server: { port: 8080 }
}
```

### server.open

<p>

**Type:** `string | boolean`<br />
**Default:** `false`<br />
<Since v="4.1.0" />
</p>

Controls whether the dev server should open in your browser window on startup.

Pass a full URL string (e.g. "http://example.com") or a pathname (e.g. "/about") to specify the URL to open.

```js
{
  server: { open: "/about" }
}
```

### server.headers

<p>

**Type:** `OutgoingHttpHeaders`<br />
**Default:** `{}`<br />
<Since v="1.7.0" />
</p>

Set custom HTTP response headers to be sent in `astro dev` and `astro preview`.

## Dev Toolbar Options


### devToolbar.enabled

<p>

**Type:** `boolean`<br />
**Default:** `true`
</p>

Whether to enable the Astro Dev Toolbar. This toolbar allows you to inspect your page islands, see helpful audits on performance and accessibility, and more.

This option is scoped to the entire project, to only disable the toolbar for yourself, run `npm run astro preferences disable devToolbar`. To disable the toolbar for all your Astro projects, run `npm run astro preferences disable devToolbar --global`.

## Prefetch Options

<p>

**Type:** `boolean | object`
</p>

Enable prefetching for links on your site to provide faster page transitions.
(Enabled by default on pages using the `<ViewTransitions />` router. Set `prefetch: false` to opt out of this behaviour.)

This configuration automatically adds a prefetch script to every page in the project
giving you access to the `data-astro-prefetch` attribute.
Add this attribute to any `<a />` link on your page to enable prefetching for that page.

```html
<a href="/about" data-astro-prefetch>About</a>
```
Further customize the default prefetching behavior using the [`prefetch.defaultStrategy`](#prefetchdefaultstrategy) and [`prefetch.prefetchAll`](#prefetchprefetchall) options.

See the [Prefetch guide](/en/guides/prefetch/) for more information.

### prefetch.prefetchAll

<p>

**Type:** `boolean`
</p>

Enable prefetching for all links, including those without the `data-astro-prefetch` attribute.
This value defaults to `true` when using the `<ViewTransitions />` router. Otherwise, the default value is `false`.

```js
prefetch: {
	prefetchAll: true
}
```

When set to `true`, you can disable prefetching individually by setting `data-astro-prefetch="false"` on any individual links.

```html
<a href="/about" data-astro-prefetch="false">About</a>
```

### prefetch.defaultStrategy

<p>

**Type:** `'tap' | 'hover' | 'viewport' | 'load'`<br />
**Default:** `'hover'`
</p>

The default prefetch strategy to use when the `data-astro-prefetch` attribute is set on a link with no value.

- `'tap'`: Prefetch just before you click on the link.
- `'hover'`: Prefetch when you hover over or focus on the link. (default)
- `'viewport'`: Prefetch as the links enter the viewport.
- `'load'`: Prefetch all links on the page after the page is loaded.

You can override this default value and select a different strategy for any individual link by setting a value on the attribute.

```html
<a href="/about" data-astro-prefetch="viewport">About</a>
```

## Image Options


### image.endpoint

<p>

**Type:** `string`<br />
**Default:** `undefined`<br />
<Since v="3.1.0" />
</p>

Set the endpoint to use for image optimization in dev and SSR. Set to `undefined` to use the default endpoint.

The endpoint will always be injected at `/_image`.

```js
{
  image: {
    // Example: Use a custom image endpoint
    endpoint: './src/image-endpoint.ts',
  },
}
```

### image.service

<p>

**Type:** `Object`<br />
**Default:** `{entrypoint: 'astro/assets/services/sharp', config?: {}}`<br />
<Since v="2.1.0" />
</p>

Set which image service is used for Astroâ€™s assets support.

The value should be an object with an entrypoint for the image service to use and optionally, a config object to pass to the service.

The service entrypoint can be either one of the included services, or a third-party package.

```js
{
  image: {
    // Example: Enable the Sharp-based image service with a custom config
    service: {
			 entrypoint: 'astro/assets/services/sharp',
			 config: {
				 limitInputPixels: false,
      },
		 },
  },
}
```

#### image.service.config.limitInputPixels

<p>

**Type:** `number | boolean`<br />
**Default:** `true`<br />
<Since v="4.1.0" />
</p>

Whether or not to limit the size of images that the Sharp image service will process.

Set `false` to bypass the default image size limit for the Sharp image service and process large images.

### image.domains

<p>

**Type:** `Array.<string>`<br />
**Default:** `{domains: []}`<br />
<Since v="2.10.10" />
</p>

Defines a list of permitted image source domains for remote image optimization. No other remote images will be optimized by Astro.

This option requires an array of individual domain names as strings. Wildcards are not permitted. Instead, use [`image.remotePatterns`](#imageremotepatterns) to define a list of allowed source URL patterns.

```js
// astro.config.mjs
{
  image: {
    // Example: Allow remote image optimization from a single domain
    domains: ['astro.build'],
  },
}
```

### image.remotePatterns

<p>

**Type:** `Array.<RemotePattern>`<br />
**Default:** `{remotePatterns: []}`<br />
<Since v="2.10.10" />
</p>

Defines a list of permitted image source URL patterns for remote image optimization.

`remotePatterns` can be configured with four properties:
1. protocol
2. hostname
3. port
4. pathname

```js
{
  image: {
    // Example: allow processing all images from your aws s3 bucket
    remotePatterns: [{
      protocol: 'https',
      hostname: '**.amazonaws.com',
    }],
  },
}
```

You can use wildcards to define the permitted `hostname` and `pathname` values as described below. Otherwise, only the exact values provided will be configured:
`hostname`:
  - Start with '**.' to allow all subdomains ('endsWith').
  - Start with '*.' to allow only one level of subdomain.

`pathname`:
  - End with '/**' to allow all sub-routes ('startsWith').
  - End with '/*' to allow only one level of sub-route.

## Markdown Options


### markdown.shikiConfig

<p>

**Type:** `Partial<ShikiConfig>`
</p>

Shiki configuration options. See [the Markdown configuration docs](/en/guides/markdown-content/#shiki-configuration) for usage.

### markdown.syntaxHighlight

<p>

**Type:** `'shiki' | 'prism' | false`<br />
**Default:** `shiki`
</p>

Which syntax highlighter to use, if any.
- `shiki` - use the [Shiki](https://shiki.style) highlighter
- `prism` - use the [Prism](https://prismjs.com/) highlighter
- `false` - do not apply syntax highlighting.

```js
{
  markdown: {
    // Example: Switch to use prism for syntax highlighting in Markdown
    syntaxHighlight: 'prism',
  }
}
```

### markdown.remarkPlugins

<p>

**Type:** `RemarkPlugins`
</p>

Pass [remark plugins](https://github.com/remarkjs/remark) to customize how your Markdown is built. You can import and apply the plugin function (recommended), or pass the plugin name as a string.

```js
import remarkToc from 'remark-toc';
{
  markdown: {
    remarkPlugins: [ [remarkToc, { heading: "contents"} ] ]
  }
}
```

### markdown.rehypePlugins

<p>

**Type:** `RehypePlugins`
</p>

Pass [rehype plugins](https://github.com/remarkjs/remark-rehype) to customize how your Markdown's output HTML is processed. You can import and apply the plugin function (recommended), or pass the plugin name as a string.

```js
import { rehypeAccessibleEmojis } from 'rehype-accessible-emojis';
{
  markdown: {
    rehypePlugins: [rehypeAccessibleEmojis]
  }
}
```

### markdown.gfm

<p>

**Type:** `boolean`<br />
**Default:** `true`<br />
<Since v="2.0.0" />
</p>

Astro uses [GitHub-flavored Markdown](https://github.com/remarkjs/remark-gfm) by default. To disable this, set the `gfm` flag to `false`:

```js
{
  markdown: {
    gfm: false,
  }
}
```

### markdown.smartypants

<p>

**Type:** `boolean`<br />
**Default:** `true`<br />
<Since v="2.0.0" />
</p>

Astro uses the [SmartyPants formatter](https://daringfireball.net/projects/smartypants/) by default. To disable this, set the `smartypants` flag to `false`:

```js
{
  markdown: {
    smartypants: false,
  }
}
```

### markdown.remarkRehype

<p>

**Type:** `RemarkRehype`
</p>

Pass options to [remark-rehype](https://github.com/remarkjs/remark-rehype#api).

```js
{
  markdown: {
    // Example: Translate the footnotes text to another language, here are the default English values
    remarkRehype: { footnoteLabel: "Footnotes", footnoteBackLabel: "Back to reference 1"},
  },
};
```

## i18n

<p>

**Type:** `object`<br />
<Since v="3.5.0" />
</p>

Configures i18n routing and allows you to specify some customization options.

See our guide for more information on [internationalization in Astro](/en/guides/internationalization/)

### i18n.defaultLocale

<p>

**Type:** `string`<br />
<Since v="3.5.0" />
</p>

The default locale of your website/application. This is a required field.

No particular language format or syntax is enforced, but we suggest using lower-case and hyphens as needed (e.g. "es", "pt-br") for greatest compatibility.

### i18n.locales

<p>

**Type:** `Locales`<br />
<Since v="3.5.0" />
</p>

A list of all locales supported by the website, including the `defaultLocale`. This is a required field.

Languages can be listed either as individual codes (e.g. `['en', 'es', 'pt-br']`) or mapped to a shared `path` of codes (e.g.  `{ path: "english", codes: ["en", "en-US"]}`). These codes will be used to determine the URL structure of your deployed site.

No particular language code format or syntax is enforced, but your project folders containing your content files must match exactly the `locales` items in the list. In the case of multiple `codes` pointing to a custom URL path prefix, store your content files in a folder with the same name as the `path` configured.

### i18n.fallback

<p>

**Type:** `Record.<string, string>`<br />
<Since v="3.5.0" />
</p>

The fallback strategy when navigating to pages that do not exist (e.g. a translated page has not been created).

Use this object to declare a fallback `locale` route for each language you support. If no fallback is specified, then unavailable pages will return a 404.

##### Example

The following example configures your content fallback strategy to redirect unavailable pages in `/pt-br/` to their `es` version, and unavailable pages in `/fr/` to their `en` version. Unavailable `/es/` pages will return a 404.

```js
export default defineConfig({
	i18n: {
		defaultLocale: "en",
		locales: ["en", "fr", "pt-br", "es"],
		fallback: {
			pt: "es",
		  fr: "en"
		}
	}
})
```

### i18n.routing

<p>

**Type:** `Routing`<br />
<Since v="3.7.0" />
</p>

Controls the routing strategy to determine your site URLs. Set this based on your folder/URL path configuration for your default language.

#### i18n.routing.prefixDefaultLocale

<p>

**Type:** `boolean`<br />
**Default:** `false`<br />
<Since v="3.7.0" />
</p>

When `false`, only non-default languages will display a language prefix.
The `defaultLocale` will not show a language prefix and content files do not exist in a localized folder.
 URLs will be of the form `example.com/[locale]/content/` for all non-default languages, but `example.com/content/` for the default locale.

When `true`, all URLs will display a language prefix.
URLs will be of the form `example.com/[locale]/content/` for every route, including the default language.
Localized folders are used for every language, including the default.

```js
export default defineConfig({
	i18n: {
		defaultLocale: "en",
		locales: ["en", "fr", "pt-br", "es"],
		routing: {
			prefixDefaultLocale: true,
		}
	}
})
```

#### i18n.routing.redirectToDefaultLocale

<p>

**Type:** `boolean`<br />
**Default:** `true`<br />
<Since v="4.2.0" />
</p>

Configures whether or not the home URL (`/`) generated by `src/pages/index.astro`
will redirect to `/[defaultLocale]` when `prefixDefaultLocale: true` is set.

Set `redirectToDefaultLocale: false` to disable this automatic redirection at the root of your site:
```js
// astro.config.mjs
export default defineConfig({
  i18n:{
    defaultLocale: "en",
		locales: ["en", "fr"],
    routing: {
      prefixDefaultLocale: true,
      redirectToDefaultLocale: false
    }
  }
})
```

#### i18n.routing.manual

<p>

**Type:** `string`<br />
<Since v="4.6.0" />
</p>

When this option is enabled, Astro will **disable** its i18n middleware so that you can implement your own custom logic. No other `routing` options (e.g. `prefixDefaultLocale`) may be configured with `routing: "manual"`.

You will be responsible for writing your own routing logic, or executing Astro's i18n middleware manually alongside your own.

```js
export default defineConfig({
	i18n: {
		defaultLocale: "en",
		locales: ["en", "fr", "pt-br", "es"],
		routing: {
			prefixDefaultLocale: true,
		}
	}
})
```

## Legacy Flags

To help some users migrate between versions of Astro, we occasionally introduce `legacy` flags.
These flags allow you to opt in to some deprecated or otherwise outdated behavior of Astro
in the latest version, so that you can continue to upgrade and take advantage of new Astro releases.

## Experimental Flags

Astro offers experimental flags to give users early access to new features.
These flags are not guaranteed to be stable.

### experimental.directRenderScript

<p>

**Type:** `boolean`<br />
**Default:** `false`<br />
<Since v="4.5.0" />
</p>

Enables a more reliable strategy to prevent scripts from being executed in pages where they are not used.

Scripts will directly render as declared in Astro files (including existing features like TypeScript, importing `node_modules`,
and deduplicating scripts). You can also now conditionally render scripts in your Astro file.
However, this means scripts are no longer hoisted to the `<head>` and multiple scripts on a page are no longer bundled together.
If you enable this option, you should check that all your `<script>` tags behave as expected.

This option will be enabled by default in Astro 5.0.

```js
{
  experimental: {
    directRenderScript: true,
  },
}
```

### experimental.actions

<p>

**Type:** `boolean`<br />
**Default:** `false`<br />
<Since v="4.8.0" />
</p>

Actions help you write type-safe backend functions you can call from anywhere. Enable server rendering [using the `output` property](/en/basics/rendering-modes/#on-demand-rendered) and add the `actions` flag to the `experimental` object:

```js
{
  output: 'hybrid', // or 'server'
  experimental: {
    actions: true,
  },
}
```

Declare all your actions in `src/actions/index.ts`. This file is the global actions handler.

Define an action using the `defineAction()` utility from the `astro:actions` module. An action accepts the `handler` property to define your server-side request handler. If your action accepts arguments, apply the `input` property to validate parameters with Zod.

This example defines two actions: `like` and `comment`. The `like` action accepts a JSON object with a `postId` string, while the `comment` action accepts [FormData](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest_API/Using_FormData_Objects) with `postId`, `author`, and `body` strings. Each `handler` updates your database and return a type-safe response.

```ts
// src/actions/index.ts
import { defineAction, z } from "astro:actions";

export const server = {
  like: defineAction({
    input: z.object({ postId: z.string() }),
    handler: async ({ postId }) => {
      // update likes in db

      return likes;
    },
  }),
  comment: defineAction({
    accept: 'form',
    input: z.object({
      postId: z.string(),
      author: z.string(),
      body: z.string(),
    }),
    handler: async ({ postId }) => {
      // insert comments in db

      return comment;
    },
  }),
};
```

Then, call an action from your client components using the `actions` object from `astro:actions`. You can pass a type-safe object when using JSON, or a [FormData](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest_API/Using_FormData_Objects) object when using `accept: 'form'` in your action definition.

This example calls the `like` and `comment` actions from a React component:

```tsx "actions"
// src/components/blog.tsx
import { actions } from "astro:actions";
import { useState } from "react";

export function Like({ postId }: { postId: string }) {
  const [likes, setLikes] = useState(0);
  return (
    <button
      onClick={async () => {
        const newLikes = await actions.like({ postId });
        setLikes(newLikes);
      }}
    >
      {likes} likes
    </button>
  );
}

export function Comment({ postId }: { postId: string }) {
  return (
    <form
      onSubmit={async (e) => {
        e.preventDefault();
        const formData = new FormData(e.target as HTMLFormElement);
        const result = await actions.blog.comment(formData);
        // handle result
      }}
    >
      <input type="hidden" name="postId" value={postId} />
      <label htmlFor="author">Author</label>
      <input id="author" type="text" name="author" />
      <textarea rows={10} name="body"></textarea>
      <button type="submit">Post</button>
    </form>
  );
}
```

For a complete overview, and to give feedback on this experimental API, see the [Actions RFC](https://github.com/withastro/roadmap/blob/actions/proposals/0046-actions.md).

### experimental.contentCollectionCache

<p>

**Type:** `boolean`<br />
**Default:** `false`<br />
<Since v="3.5.0" />
</p>

Enables a persistent cache for content collections when building in static mode.

```js
{
	experimental: {
		contentCollectionCache: true,
	},
}
```

### experimental.clientPrerender

<p>

**Type:** `boolean`<br />
**Default:** `false`<br />
<Since v="4.2.0" />
</p>

Enables pre-rendering your prefetched pages on the client in supported browsers.

This feature uses the experimental [Speculation Rules Web API](https://developer.mozilla.org/en-US/docs/Web/API/Speculation_Rules_API) and enhances the default `prefetch` behavior globally to prerender links on the client.
You may wish to review the [possible risks when prerendering on the client](https://developer.mozilla.org/en-US/docs/Web/API/Speculation_Rules_API#unsafe_prefetching) before enabling this feature.

Enable client side prerendering in your `astro.config.mjs` along with any desired `prefetch` configuration options:

```js
// astro.config.mjs
{
  prefetch: {
    prefetchAll: true,
    defaultStrategy: 'viewport',
  },
	experimental: {
		clientPrerender: true,
	},
}
```

Continue to use the `data-astro-prefetch` attribute on any `<a />` link on your site to opt in to prefetching.
Instead of appending a `<link>` tag to the head of the document or fetching the page with JavaScript, a `<script>` tag will be appended with the corresponding speculation rules.

Client side prerendering requires browser support. If the Speculation Rules API is not supported, `prefetch` will fallback to the supported strategy.

See the [Prefetch Guide](/en/guides/prefetch/) for more `prefetch` options and usage.

### experimental.globalRoutePriority

<p>

**Type:** `boolean`<br />
**Default:** `false`<br />
<Since v="4.2.0" />
</p>

Prioritizes redirects and injected routes equally alongside file-based project routes, following the same [route priority order rules](/en/guides/routing/#route-priority-order) for all routes.

This allows more control over routing in your project by not automatically prioritizing certain types of routes, and standardizes the route priority ordering for all routes.

The following example shows which route will build certain page URLs when file-based routes, injected routes, and redirects are combined as shown below:
- File-based route: `/blog/post/[pid]`
- File-based route: `/[page]`
- Injected route: `/blog/[...slug]`
- Redirect: `/blog/tags/[tag]` -> `/[tag]`
- Redirect: `/posts` -> `/blog`

With `experimental.globalRoutingPriority` enabled (instead of Astro 4.0 default route priority order):

- `/blog/tags/astro` is built by the redirect to `/tags/[tag]` (instead of the injected route `/blog/[...slug]`)
- `/blog/post/0` is built by the file-based route `/blog/post/[pid]` (instead of the injected route `/blog/[...slug]`)
- `/posts` is built by the redirect to `/blog` (instead of the file-based route `/[page]`)


In the event of route collisions, where two routes of equal route priority attempt to build the same URL, Astro will log a warning identifying the conflicting routes.

### experimental.env

<p>

**Type:** `object`<br />
**Default:** `undefined`<br />
<Since v="4.10.0" />
</p>

Enables experimental `astro:env` features .

The `astro:env` API lets you configure a type-safe schema for your environment variables, and indicate whether they should be available on the server or the client. Import and use your defined variables from the appropriate `/client` or `/server` module:

```astro
---
import { APP_ID } from "astro:env/client"
import { API_URL, API_TOKEN, getSecret } from "astro:env/server"
const NODE_ENV = getSecret("NODE_ENV")

const data = await fetch(`${API_URL}/users`, {
	method: "POST",
	headers: {
		"Content-Type": "application/json",
		"Authorization": `Bearer ${API_TOKEN}`
	},
	body: JSON.stringify({ appId: APP_ID, nodeEnv: NODE_ENV })
})
---
```

To define the data type and properties of your environment variables, declare a schema in your Astro config in `experimental.env.schema`. The `envField` helper allows you define your variable as a string, number, or boolean and pass properties in an object:

```js
// astro.config.mjs
import { defineConfig, envField } from "astro/config"

export default defineConfig({
    experimental: {
        env: {
            schema: {
                API_URL: envField.string({ context: "client", access: "public", optional: true }),
                PORT: envField.number({ context: "server", access: "public", default: 4321 }),
                API_SECRET: envField.string({ context: "server", access: "secret" }),
            }
        }
    }
})
```

There are currently four data types supported: strings, numbers, booleans and enums.

There are three kinds of environment variables, determined by the combination of `context` (client or server) and `access` (secret or public) settings defined in your [`env.schema`](#experimentalenvschema):

- **Public client variables**: These variables end up in both your final client and server bundles, and can be accessed from both client and server through the `astro:env/client` module:

    ```js
    import { API_URL } from "astro:env/client"
    ```

- **Public server variables**: These variables end up in your final server bundle and can be accessed on the server through the `astro:env/server` module:

    ```js
    import { PORT } from "astro:env/server"
    ```

- **Secret server variables**: These variables are not part of your final bundle and can be accessed on the server through the `astro:env/server` module. The `getSecret()` helper function can be used to retrieve secrets not specified in the schema:

    ```js
    import { API_SECRET, getSecret } from "astro:env/server"

    const SECRET_NOT_IN_SCHEMA = getSecret("SECRET_NOT_IN_SCHEMA") // string | undefined
    ```

**Note:** Secret client variables are not supported because there is no safe way to send this data to the client. Therefore, it is not possible to configure both `context: "client"` and `access: "secret"` in your schema.

For a complete overview, and to give feedback on this experimental API, see the [Astro Env RFC](https://github.com/withastro/roadmap/blob/feat/astro-env-rfc/proposals/0046-astro-env.md).

#### experimental.env.schema

<p>

**Type:** `EnvSchema`<br />
**Default:** `undefined`<br />
<Since v="4.10.0" />
</p>

An object that uses `envField` to define the data type (`string`, `number`, or `boolean`) and properties of your environment variables: `context` (client or server), `access` (public or secret), a `default` value to use, and whether or not this environment variable is `optional` (defaults to `false`).
```js
// astro.config.mjs
import { defineConfig, envField } from "astro/config"

export default defineConfig({
  experimental: {
    env: {
      schema: {
        API_URL: envField.string({ context: "client", access: "public", optional: true }),
        PORT: envField.number({ context: "server", access: "public", default: 4321 }),
        API_SECRET: envField.string({ context: "server", access: "secret" }),
      }
    }
  }
})
```

#### experimental.env.validateSecrets

<p>

**Type:** `boolean`<br />
**Default:** `false`<br />
<Since v="4.11.6" />
</p>

Whether or not to validate secrets on the server when starting the dev server or running a build.

By default, only public variables are validated on the server when starting the dev server or a build, and private variables are validated at runtime only. If enabled, private variables will also be checked on start. This is useful in some continuous integration (CI) pipelines to make sure all your secrets are correctly set before deploying.

```js
// astro.config.mjs
import { defineConfig, envField } from "astro/config"

export default defineConfig({
  experimental: {
    env: {
      schema: {
        // ...
      },
      validateSecrets: true
    }
  }
})
```

### experimental.serverIslands

<p>

**Type:** `boolean`<br />
**Default:** `false`<br />
<Since v="4.12.0" />
</p>

Enables experimental Server Island features.
Server Islands offer the ability to defer a component to render asynchronously after the page has already rendered.

To enable, configure an [on-demand server rendering `output` mode](/en/basics/rendering-modes/#on-demand-rendered) with an adapter, and add the `serverIslands` flag to the `experimental` object:

```js
{
  output: 'hybrid', // or 'server'
  adapter: nodejs({ mode: 'standalone' }),
  experimental: {
    serverIslands: true,
  },
}
```

Use the `server:defer` directive on any Astro component to delay initial rendering:

```astro "server:defer"
---
import Avatar from '~/components/Avatar.astro';
---
<Avatar server:defer />
```

The outer page will be rendered, either at build time (`hybrid`) or at runtime (`server`) with the island content omitted and a `<script>` tag included in its place.

After the page loads in the browser, the script tag will replace itself with the the contents of the island by making a request.

Any Astro component can be given the `server: defer` attribute to delay its rendering. There is no special API and you can write `.astro` code as normal:

```astro
---
import { getUser } from '../api';

const user = await getUser(Astro.locals.userId);
---
<img class="avatar" src={user.imageUrl}>
```

#### Server island fallback content

Since your component will not render with the rest of the page, you may want to add generic content (e.g. a loading message) to temporarily show in its place. This content will be displayed when the page first renders but before the island has loaded.

Add placeholder content as a child of your Astro component with the `slot="fallback"` attribute. When your island content is available, the fallback content will be replaced.

The example below displays a generic avatar as fallback content, then animates into a personalized avatar using view transitions:

```astro
<Avatar server:defer>
  <svg slot="fallback" class="generic-avatar" transition:name="avatar">...</svg>
</Avatar>
```

For a complete overview, and to give feedback on this experimental API, see the [Server Islands RFC](https://github.com/withastro/roadmap/pull/963).

