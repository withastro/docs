---
title: Upgrade to Astro v3
description: How to upgrade your project to the latest version of Astro.
i18nReady: false
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'
import FileTree from '~/components/FileTree.astro'


This guide will help you migrate from Astro v2 to Astro v3.

Need to upgrade an older project to v2? See our [older migration guide](/en/guides/upgrade-to/v2/).

## Upgrade Astro

Update your project's version of Astro to the latest version using your package manager. If you're using Astro integrations, please also update those to the latest version.

<PackageManagerTabs>
  <Fragment slot="npm">
  ```shell
  # Upgrade to Astro v3.x
  npm install astro@latest
  
  # Example: upgrade React and Tailwind integrations
  npm install @astrojs/react@latest @astrojs/tailwind@latest
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```shell
  # Upgrade to Astro v3.x
  pnpm install astro@latest

  # Example: upgrade React and Tailwind integrations
  pnpm install @astrojs/react@latest @astrojs/tailwind@latest
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```shell
  # Upgrade to Astro v3.x
  yarn add astro@latest
  
  # Example: upgrade React and Tailwind integrations
  yarn add @astrojs/react@latest @astrojs/tailwind@latest
  ```
  </Fragment>
</PackageManagerTabs>

## Astro v3.0 Experimental Flags Removed

Remove the following experimental flags from `astro.config.mjs`:

```js del={5-8}
// astro.config.mjs
import { defineConfig } from 'astro/config';

export default defineConfig({
  experimental: {
    assets: true,
    viewTransitions: true,
  },
})
```

These features are now available by default:

- [View Transitions](/en/guides/view-transitions/) for animated page transitions and persistent islands.
- A new image services API `astro:assets` for [using images in Astro](/en/guides/images/), including a new `<Image />` component and `getImage()` function.

Read more about these two exciting features and more in the 3.0 Blog post!



## Astro v3.0 Breaking Changes

Astro v3.0 includes some breaking changes, as well as the removal of some previously deprecated features. If your project doesn't work as expected after upgrading to v3.0, check this guide for an overview of all breaking changes and instructions on how to update your codebase.

See [the changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) for full release notes.

### Removed: Support for Node 16

Node 16 is scheduled to reach its End of Life in September 2023. 

Astro v3.0 drops Node 16 support entirely, so that all Astro users can take advantage of Node's more modern features.

#### What should I do?

 Check that both your development environment and your deployment environment are using **Node `18.14.1` or later**.

1. Check your local version of Node using:

    ```sh
    node -v
    ```

    If your local development environment needs upgrading, [install Node](https://nodejs.org/en/download/).


2. Check your [deployment environment's](/en/guides/deploy/) own documentation to verify that they support Node 18. 

    You can specify Node `18.14.1` for your Astro project either in a dashboard configuration setting, or a `.nvmrc` file.

### Removed: `@astrojs/image`

In Astro v2.x, Astro offered an official image integration that included Astro `<Image />` and `<Picture />` components.

Astro v3.0 removes this integration from the codebase entirely. Astro's new solution for images is a built-in image services API: `astro:assets`.

#### What should I do?

Remove the `@astrojs/image` integration from your project. You will need to not only uninstall the integration, but also update or remove any import statements and existing `<Image />` and `<Picture />` components. You might also need to configure a preferred default image processing service.

You will find [complete, step-by-step instructions for removing the old image integration](/en/guides/images/#remove-astrojsimage) in our Images guide.

Migrating to `astro:assets` will also bring some new image options and features that you may now wish to use. Please see the full [v3.0 Image Upgrade Advice](/en/guides/images/#upgrade-to-v30-from-v2x) for full details!

```js del={3,7}
// astro.config.mjs
import { defineConfig } from 'astro/config';
import image from '@astrojs/image';

export default defineConfig({
  integrations: [
    image(),
  ]
})
```


### Removed: `<Markdown />` component

In Astro v2.x, Astro deprecated the `<Markdown />` component and moved it to an external package.

Astro v3.0 completely removes the package `@astrojs/markdown-component`. Astro's `<Markdown />` component will no longer work in your project.

#### What should I do?

Remove all instances of the `@astrojs/markdown-component`.

```astro del={3}
---
// astro.config.mjs
import Markdown from '@astrojs/markdown-component';
---
```

To continue using a similar `<Markdown />` component in your code, consider using [community integrations](https://astro.build/integrations/) such as [`astro-remote`](https://github.com/natemoo-re/astro-remote). Be sure to update your `<Markdown />` component imports and attributes as necessary, according to the integration's own documentation. 

Otherwise, delete all references to importing Astro's `<Markdown />` component and the component itself in your `.astro` files. You will need to rewrite your content as HTML directly or [import Markdown](/en/guides/markdown-content/#importing-markdown) from a `.md` file.

### Removed: `build.excludeMiddleware` and `build.split`

In Astro v2.x, `build.excludeMiddleware` and `build.split` could be used to change how specific files were emitted when using an adapter in SSR mode.

Astro v3.0 replaces these build config options with new adapter configuration options **(CHECK ONLY Netlify, Vercel, and Cloudflare??)** to perform the same tasks: `edgeMiddleware` and `functionPerRoute`.

#### What should I do?

Update the Astro config file to now use the new options **in the adapter configuration** directly.

```astro title="astro.config.mjs" del={5-7} ins={9}
import { defineConfig } from "astro/config";
import vercel from "@astrojs/vercel/serverless";

export default defineConfig({
    build: {
      excludeMiddleware: true
    },
    adapter: vercel({
      edgeMiddleware: true
    }),
});
```

```astro title="astro.config.mjs" del={5-7} ins={9}
import { defineConfig } from "astro/config";
import vercel from "@astrojs/vercel/serverless";

export default defineConfig({
     build: {
        split: true
     },
     adapter: vercel({
        functionPerRoute: true
     }),
});
```

```astro title="astro.config.mjs" del={5-7} ins={9}
import { defineConfig } from "astro/config";
import netlify from "@astrojs/netlify/functions";

export default defineConfig({
     build: {
        excludeMiddleware: true
     },
     adapter: netlify({
        edgeMiddleware: true
     }),
});
```

```astro title="astro.config.mjs" del={5-7} ins={9}
import { defineConfig } from "astro/config";
import netlify from "@astrojs/netlify/functions";

export default defineConfig({
     build: {
        split: true
     },
     adapter: netlify({
        functionPerRoute: true
     }),
});
```

### Changed: automatic flattening of `getStaticPaths()`'s return value

:::note[Example needed]
Find an example of returning an array of an array
:::

In Astro v2.x, we would magically flatten the result of `getStaticPaths()` automatically for the user, so if you returned an array of array, it would still work

Astro v3.0 we changed this in favour of the user doing it themselves when they need to, in line with how we typically prefer for users to do explicit things.

Removed automatic flattening of getStaticPaths result. .flatMap and .flat should now be used to ensure that youâ€™re returning a flat array.

#### What should I do?

If you're returning an array of arrays instead of an array of object (as you should), please flatten it using .flat(), or if you're using a .map(), use .flatMap() instead

A [error message indicating that `getStaticPath()`'s return value must be an array of objects](/en/reference/errors/invalid-get-static-paths-entry/#what-went-wrong) will be provided if you need to update your code.

### Changed: default image service to Sharp instead of Squoosh

In Astro v2.x, Squoosh was the default image service.

Astro v3.0, Sharp is now the default image service.

#### What should I do?

Sharp is now the default image service used for Astro.

You no longer need to install the dependency locally in your project.

Uninstall Sharp using your package manager, or by removing manually from your `package.json`.

If you would prefer to continue to use Squoosh to transform your images, update your config with the following: 

```ts title="astro.config.mjs" ins={4-6}
import { defineConfig, squooshImageService } from "astro/config";

export default defineConfig({
  image: {
    service: squooshImageService(),
  }
})
```

### Changed: casing in function endpoints 

In Astro v2.x, endpoints were defined using lowercase function names: `get`, `post`, `put`, `all`, and `del`.

Astro v3.0, uses uppercase function names.

#### What should I do?

Rename functions to uppercase equivalent:

- `get` to `GET`
- `post` to `POST`
- `put` to `PUT`
- `all` to `ALL`
- `del` to `DELETE`

```ts title="endpoint.ts" del={1} ins={2}
export function get() {
export function GET() {
    return new Response(JSON.stringify({ "title": "Bob's blog" }));
}
```

### Changed: Behaviour when `Astro.cookies.get(key)` doesn't exist

In Astro v2.x, `Astro.cookies.get(key)` would always return a `AstroCookie` object, even if the cookie did not exist. To check for the existence you needed to use `Astro.cookies.has(key)`.

Astro v3.0 `Astro.cookies.get(key)` will return `undefined` if the cookie does not exist.

#### What should I do?

This change will not break existing code that checks for the existance of the `Astro.cookie` object before using `Astro.cookies.get(key)`, but is now no longer required. You can safely remove this code.

You can safely skip `has()` and check if the value is `undefined`:

```ts
// before:
if (Astro.cookies.has(id)) {
  const id = Astro.cookies.get(id)!;
}

//after:
const id = Astro.cookies.get(id);
if (id) {
  // TypeScript knows id is an AstroCookie
}
```

### Changed: the default value of `compressHTML`

In Astro v2.x, Astro only compressed the emitted HTML by explicitly setting the configuration to `true`.

Astro v3.0 now compresses emitted HTML by default.

#### What should I do?

You can now remove `compressHTML: true` from your configuration as this is now the default behavior.

```ts title="astro.config.mjs" del={4}
import { defineConfig } from "astro/config";

export default defineConfig({
	compressHTML: true
})
```

You must now set `compressHTML: false` to opt out of HTML compression.

### Changed: default port used

In Astro v2.x, Astro ran on port `3000` by default.

Astro v3.0 changes the default port to `4321`.

#### What should I do?

Update any existing references to `localhost:3000`, for example in tests or in your `README` to reflect the new port `localhost:4321`.

### Changed: TypeScript minimum version

In Astro v2.x, the `tsconfig.json` presets include support for both TypeScript 4.x and 5.x.

Astro v3.0 updates the `tsconfig.json` presets to only support TypeScript 5.x. Astro now assumes that you use TypeScript 5.0 (March 2023), or that your editor includes it (e.g. VS Code 1.77)

#### What should I do?

Update your TypeScript version to at least v5.0.

```bash
npm install typescript@latest --save-dev
```

### Changed `astro check` is now an external package

In Astro v2.x, `astro check` was included in Astro by default and its dependencies were bundled in Astro. This meant a larger package whether or not you ever used `astro check` and also prevented you from having control over the version of TypeScript and the Astro Language Server to use. 


Astro v3.0 moves the `astro check` command out of Astro core and now requires an external package `@astrojs/check`. Additionally, you must install `typescript` in your project.

#### What should I do?

Run the `astro check` command after upgrading to Astro v3.0 and follow the prompts to install the required dependencies, or manually install `@astrojs/check` and `typescript` into your project.

### Added: simple asset support for Cloudflare, Deno, Vercel Edge and Netlify Edge
 In Astro v2.x, using the assets feature in Cloudflare, Deno, Vercel Edge and Netlify Edge errors in runtime as the environments do not support Astro's builtin Squoosh and Sharp image optimization.

 Astro v3.0 allows these environments to work without errors, but does not perform any image transformation and processing. However, you would still get benefits, e.g. no Cumulative Layout Shift (CLS), enforced alt attribute, etc.

 What should I do?
 If you previously avoided the assets feature due these constraints, you can now use them without issues. You can also use the no-op image service to explicitly opt-in to this behaviour:

 ```
 // astro.config.mjs
 export default {
   image: {
     service: {
       entrypoint: 'astro/assets/services/noop'
     }
   }
 }
 ```

In Astro v2.x, you would get an error log in development. When building a project, the build would fail.

Astro V3 still displays the error log, but now you can build the project.

When using an adapter that supports neither Squoosh or Sharp, Astro will now automatically use an image service that does not support processing, but still provides the other benefits of `astro:assets` such as enforcing `alt`, no CLS etc to users. Should be noted that it does no transformations or processing, but you still get all the other benefits (no CLS, alt enforced, etc). All of those benefits are part of the image service, if you make your own, you lose those benefits unless you make it yourself


### Removed: camelCase transformations

In Astro 2.x, Astro automatically transformed camelCase CSS variable names passed to the `style` attribute of an HTML element.

Astro 3.0 removes backwards-compatible kebab-case transform for these camelCase CSS variable names. 

#### What should I do?

If you were relying on Astro to transform kebab-case in your styles, update your existing styles to use the camelCase version to prevent missing styles. For example:

```astro
---
const myValue = "red"
---
<!-- input -->
<div style={{ "--myValue": myValue }}></div>
<!-- output (before) -->
<div style="--my-value:var(--myValue);--myValue:red"></div>
<!-- output (after) -->
<div style="--myValue:red"></div>
```

```diff
<style>
  div {
-   color: var(--my-value);
+   color: var(--myValue);
  }
</style>
```

### Changed: default `scopedStyleStrategy`

In Astro v2.x, the default value of `scopedStyleStrategy` was `"where"`.

Astro v3.0, the default value is `"attribute"`. By default, styles are now applied using `data-*` attributes.

#### What should I do?

To retain your project's current style scoping, update the configuration file to the previous default value: 

```diff
export default defineConfig({
+	scopedStyleStrategy: "where"
})
```

### Changed: import.meta.env.BASE_URL default `trailingSlash` behaviour

In Astro v2.x, `import.meta.env.BASE_URL`, which derives from `base` config, is always appended a trailingSlash by default or when `trailingSlash: "ignore"` is set.

Astro v3.0 `import.meta.env.BASE_URL` is not appended with a trailingSlash by default or when `trailingSlash: "ignore"` is set. The existing behavior of `base` in combination with `trailingSlash: "always"` or `trailingSlash: "never"` is unchanged.

#### What should I do?

If your `base` already has a trailing slash, no change is needed.

 If your `base` does not have a trailing slash, add one to preserve the previous behaviour:

 ```diff
 // astro.config.mjs
 - base: 'my-base',
 + base: 'my-base/',
```

### Changed: Multiple JSX framework configuration

In Astro v2.x, you could use multiple JSX framework integrations (React, Solid, Preact) in the same project and Astro without having to identify which files belonged to which framework. Astro automatically scanned your components to determine which framework-specific transformations should be used, but at a performance cost.

Astro v3.0 determines which framework to use with `include` and `exclude` integration config options where you can specify files and folders on a per-framework basis. This allows Astro to better support single-framework usage, as well as advanced features like Fast Refresh.

#### What should I do?

If you are using multiple JSX frameworks in the same project, use the `include` and/or `exclude` configuration options to specify which files belong to which framework. Provide an array of files and/or folders. Wildcards may be used to include multiple file paths.

We recommend placing common framework components in the same folder (e.g. `/components/react/` and `/components/solid/`) to make specifying your includes easier, but this is not required:

```js
import { defineConfig } from 'astro/config';
import preact from '@astrojs/preact';
import react from '@astrojs/react';
import svelte from '@astrojs/svelte';
import vue from '@astrojs/vue';
import solid from '@astrojs/solid-js';

export default defineConfig({
  // Enable many frameworks to support all different kinds of components.
  // No `include` is needed if you are only using a single framework!
  integrations: [
		preact({
			include: ['**/preact/*']
		}),
		react({
			include: ['**/react/*']
		}),
		solid({
			include: ['**/solid/*'],
		}),
  ]
});
```


### Removed: kebab-case transform for camelCase CSS variables

In Astro v2.x, camelCase CSS variables passed to the `style` attribute were rendered as camelCase (original) and kebab-case (incorrect by kept for backwards compatibility).

Astro v3.0 removes the kebab-case transform, and only the original camelCase CSS variable is rendered.

 ```astro
 ---
 const myValue = "red"
 ---
 <!-- input -->
 <div style={{ "--myValue": myValue }}></div>
 <!-- output (before) -->
 <div style="--my-value:var(--myValue);--myValue:red"></div>
 <!-- output (after) -->
 <div style="--myValue:red"></div>
 ```

#### What should I do?

If you were relying on the kebab-case transform in your styles, make sure to use the camelCase version to prevent missing styles. For example:

 ```diff
 <style>
   div {
 -   color: var(--my-value);
 +   color: var(--myValue);
   }
 </style>
 ```
DUPE TO BE COMBINED

 Remove backwards-compatible kebab-case transform for camelCase CSS variable names passed to the `style` attribute. If you were relying on the kebab-case transform in your styles, make sure to use the camelCase version to prevent missing styles. For example:

```astro
---
const myValue = "red"
---
<!-- input -->
<div style={{ "--myValue": myValue }}></div>
<!-- output (before) -->
<div style="--my-value:var(--myValue);--myValue:red"></div>
<!-- output (after) -->
<div style="--myValue:red"></div>
```

```diff
<style>
  div {
-   color: var(--my-value);
+   color: var(--myValue);
  }
</style>
```

### Changed entrypoint export paths

In Astro v2.x, you can import internal Astro APIs from `astro/internal/star` and `astro/runtime/server/star`.

Astro v3.0 removes the two entrypoints in favour of the existing `astro/runtime/star` entrypoint.

#### What should I do?

These are entrypoints for Astro's internal API and should not affect your project, but if you do use these entrypoints, you can migrate like below:

 ```diff
 - import 'astro/internal/index.js';
 + import 'astro/runtime/server/index.js';

 - import 'astro/server/index.js';
 + import 'astro/runtime/server/index.js';
 ```

### Small stylesheets now get inlined by default
In Astro v2.x, all project stylesheets were sent  lnd u could opt-in to inlining them by using the `build.inlineStylesheets` configuration.

were sent as link tags by default  and you could opt  in to inlining them

Astro v3.0 defaults `inlineStylesheets` to "auto", which means stylesheets smaller than 4kB get included in the initial response.

#### What should I do?
Nothing, this change does not require any migration. To go back to the old behavior, configure `inlineStylesheets` to "never"

```diff
export default defineConfig({
    build: {
+       inlineStylesheets: "never"
    }
})
```

### Changed implementation of `class:list` directive
In Astro v2.x, `class:list` used a custom implementation inspired by [`clsx`](https://github.com/lukeed/clsx) with a few extra features like deduplication and `Set` support.

In Astro v3.0, `class:list` uses [`clsx`](https://github.com/lukeed/clsx) directly, which does not support deduplication or `Set` values.

#### What should I do?

Replace any `Set` elements passed to the `class:list` directive with a plain `Array`.

```diff
 <Component class:list={[
    'a',
    'b',
-   new Set(['c', 'd'])
+   ['c', 'd'] 
  ]} />
```

### Changed behavior of `class:list` directive for components

In Astro v2.x, `class:list` values were sent to components via `Astro.props['class:list']`.

In Astro v3.0, `class:list` values are normalized into a string before being sent to components via `Astro.props['class']`

#### What should I do?

Remove any code that expects to receive the `class:list` prop.

```diff
---
- import { clsx } from 'clsx';
- const { class: className, 'class:list': classList } = Astro.props;
+ const { class: className } = Astro.props;
---
<div
-  class:list={[className, classList]}
+  class={className}
/>
```

## Known Issues

There are currently no known issues.

