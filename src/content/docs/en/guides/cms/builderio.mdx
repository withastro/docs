---
title: Builder.io & Astro
description: Add content to your Astro project using Builder.ioâ€™s visual CMS
type: cms
service: Builder.io
stub: false
i18nReady: false
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'
import FileTree from '~/components/FileTree.astro';

[Builder.io](https://www.builder.io/) is a visual CMS that supports drag and drop content editing for building web sites.

At the end of this recipe you'll be able to create blog posts in Builder's visual editor and have your Astro site fetch this content automatically at build time using a webhook.

To do this, you'll use 2 [Builder's REST APIs](xxx) to connect your Builder space to Astro with zero client-side JavaScript.

:::note[Other options]
If You are using a JavaScript framework (e.g. Svelte, Vue, or React) in your Astro project you can use [one of Builder's integrations](xxx).
:::

## Prerequisites

To get started, you will need to have the following:

* ??? **A basic knowledge of using a code editor / the command line** - You can read a beginner-friendly introduction here [https://www.tatianamac.com/posts/beginner-eleventy-tutorial-partii/#1a.-terminal-emulator]

* ???* *A basic knowledge of REST APIs**

* **An Astro project** - If you don't have an Astro project yet, our [Installation guide](/en/install/auto/) will get you up and running in no time. 

* **A Builder account and space** - If you don't have an account yet, [sign up for free](https://www.builder.io/) and create a new space. If you already have a space with Builder, feel free to use it, but you will need to modify the code to match the model name and custom data fiels.

* **A Builder API key** - This key will be used when fetching your content from Builder. [Here's](https://www.builder.io/c/docs/using-your-api-key) Builder's guide how to find it. 

* ??? **A basic understanding of Builder** - specifically [section models](xxx), [custom data fields](xxx) and [the preview URL](xxx).

## Setting up credentials

To add your Builder API key to Astro, create a `.env` file in the root of your project with the following variable:

```ini title="/.env"
BUILDER_API_PUBLIC_KEY=YOUR_KEY
```

Now, you should be able to use this API key in your project. 

:::note
At the time of writing, this key for the Builder API is public [xxx] - so you don't have to worry about hiding or encrypting it. 
:::

If you would like to have IntelliSense for your Contentful environment variables, you can create a `env.d.ts` file in the `src/` directory and configure `ImportMetaEnv` like this:

```ts title="src/env.d.ts"
interface ImportMetaEnv {
  readonly BUILDER_API_PUBLIC_KEY: string;
}
```

Your project should now include these new files:

<FileTree title="Project Structure">
- src/
  - **env.d.ts**
- **.env**
- astro.config.mjs
- package.json
</FileTree>

:::tip
You could paste the key into your API call directly, but since you'll be making a few of these calls, it makes sense to put it in a separate file where you can access it from multiple places.

Read more about [using environment variables](/en/guides/environment-variables/) and `.env` files in Astro.
:::

## Making a blog with Astro and Builder

With the set up above, you can now create a blog with Astro and Builder.

### Creating a section model with custom data fields
alt: ### Create a model for a blogpost 

:::info
You can also follow [Builder's official tutorial](https://www.builder.io/blog/creating-blog) for creating a blog post model - it has gifs!
:::

In the Builder app create the model that will represent a blogpost: go to the **Models** tab and click the **+ Create Model** button to create model with the following fields and values:

- **Type:** Section
- **Name:** Blog Post
- **Description:** This model is for a blog post

:::info
A section model means that the content can sit between other elements of a page - like a <header> and <footer>, for example. 
:::

Click on the new model and use the **+ New Custom Field** button to create 2 new fields:

1. Text field
    - **Name:** "title"
    - **Required:** Yes
    - **Default value** "_"
    (leave the other parameters as their defaults)
2. Text field
    - **Name:** "slug"
    - **Required:** Yes
    - **Default value** "_"
    (leave the other parameters as their defaults)

:::caution
This guide relies on these fields to be exactly like this and later code will not run correctly if these fields don't exist, are empty, or the titles misspelled.
:::

:::caution
Make sure your slug is not just a number!

There is a pitfall with the `slug` field: it allows you to enter a number but this seems to break the API call later and is hard to debug. 
:::

Put the name of the model in the `.env` file for convenience:
```ini title="/.env" ins={2}
BUILDER_API_PUBLIC_KEY=YOUR_KEY
BUILDER_BLOGPOST_MODEL='Blog Post'
```

### Setting up the preview URL 

:::info
If you want to dig in, [read more about the preview URL in the Builder docs](https://www.builder.io/c/docs/html-api#previewing-content-on-your-site).
:::

To use Builder's visual editor, you'll create a page that renders/???returns the special `<builder-component>`. This component tells Builder where to insert the content from its CMS - it represents the portion of the page that's editable in the Builder app. 

In this guide the `<builder-component>` represents the content of a blog post and the following `builder-preview.astro` files recreates how it will be embedded into the site later on - sitting between a <header> and a <footer>.

### Creating a route for the preview
1. In your `/src/pages` folder, create a file named `builder-preview.astro`  with the following content:

```astro title="src/pages/builder-preview.astro"
---
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
---
<html lang="en">
  <head>
    <title>Preview for builder.io</title>
  </head>
  <body>     
    <header>
      Here be a header
    </header>

    <builder-component model={builderModel} api-key={builderAPIpublicKey}
    ></builder-component>
    <script async src="https://cdn.builder.io/js/webcomponents"></script>

    <footer>
      Here be a footer
    </footer>
  </body>     
</html>
```

2. Run your Astro project (e.g. start the dev server) and go to the route corresponding to the file you just created. Copy the URL to your clipboard. (It might be something like `https://localhost:3000/builder-preview`. The exact URL will depend on your project environment.)

3. Go to the **Models** tab in your Builder space, pick the model  you've created and paste the URL from step 2 in the **Preview URL** field. Make sure the URL is complete and includes the protocol, for example `https://`.

:::note
When you deploy your site, change the preview URL to match your production URL, for example `https://myAwesomeAstroBlog.com/builder-preview`.
:::

#### Testing it 
1. In your Builder space under the **Content** tab, click on **New** to create a new content entry for your "blogpost" model.

2. In the Builder editor that just opened, you should be able to see the `builder-preview.astro` page with a big inviting **+ Add Block** in the middle!

[screenshot]xxx

:::tip
**Troubleshooting**

Things can sometimes go wrong when setting up the preview. If the preview doesn't work, you can try one of the following things:

* Make sure that the routes match exactly - your Astro route and the one in your Builder preview-URL
* Make sure you include the full URL including the protocol (like `https://`)
* Make sure the site is live - your server is running 
* If you're working in a virtual environment like *Stackblitz* or *Gitpod*, you might have to copy and paste the URL again when you restart your workspace, since this usually generates a new URL for your project

For more ideas, read (Builder's troubleshooting guide)[https://www.builder.io/c/docs/guides/preview-url-working].
:::

### Creating a blog post
alt: ### Creating New Content
alt: ### Using Builder's Visual Editor

:::caution
Before You can create new content in Builder, make sure the preview URL for your model is working. See the [instructions](/#Setting-up-the-Preview-URL) above. 
:::

If You've followed the steps under [testing it](xxx), go to the content entry for the 'blogpost' model you just created. Otherwise create it now: Go to the **Content** tab in your Builder space and click on *+ New*. You should see the Builder editor now:

[screenshot with empty blogpost]

1. In the panel on the right under the **options** tab, fill in data fields 'title' and 'slug'. These are the fields you've created in a previous step(xxx).

2. Design your post! Click on the *+ Add Block* button and add whatever you want - maybe a text field with some text to start with.

3. When You're ready click on the big blue **Publish** button in the upper right corner. 

Your content is now live in the Builder CMS but not part of your Astro project yet. You'll be fetching and displaying it in the following steps. 

Feel free to add as many blog posts as you want, then switch to your favorite code editor to start hacking with Astro!

### Displaying a list of blog posts

Create the page `src/pages/index.astro` that will display a list of posts, each linking to its own page:

<FileTree title="Project Structure">
- src/
  - pages/
    - **index.astro**
  - env.d.ts
- .env
- astro.config.mjs
- package.json
</FileTree>

Then add the following content:

```astro title="src/pages/index.astro /data.(title|slug)/" 
---
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;

const { results: posts } = await fetch(
    `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
            {
                apiKey: builderAPIpublicKey,
                fields: ["data.slug", "data.title"].join(","),
                cachebust: "true",
            }
        ).toString()}`
    )
    .then((res) => res.json())
    .catch(
            // ...catch some errors...
    );
---
```

:::caution
URLs used to access APIs change fairly frequently. Check [Builder's API reference](https://www.builder.io/c/docs/content-api-versions) for the latest URL. 
:::

Fetching via the content API returns an array of objects containing data for each post. The `fields` query parameter tells Builder which data to send (see line / ??? highlighted code). `slug` and `title` should match the names of the custom data fields in your Builder model (see this step xxx). 
:::

???[screenshot showing matching fields: in code editor on one side, on builder.io on the other model custom fields]

Use the `posts` array returned from the fetch to display a list of blog posts on the page:

```astro title="src/pages/index.astro" ins={20-45}
---
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;

const { results: posts } = await fetch(
    `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
            {
                apiKey: builderAPIpublicKey,
                fields: ["data.slug", "data.title"].join(","),
                cachebust: "true",
            }
        ).toString()}`
    )
    .then((res) => res.json())
    .catch(
            // ...catch some errors...
    );
---
<html lang="en">
  <head>
    <title>Blog Index</title>
  </head>
  <body>
    <ul>
        {
            posts.map(({ data: { slug, title } }) => (
                <a href={`/posts/${slug}`} > 
                {title}
                </a>
            ))
        }
    </ul>
  </body>
</html>
```

:::info
To debug or fine-tune the API results, you can use [Builder's API explorer](https://builder.io/api-explorer) 
:::

### Displaying a single blogpost

Create the page `src/pages/post/[slug].astro` that will [dynamically generate a page](/en/core-concepts/routing/#dynamic-routes) for each post.

<FileTree title="Project Structure">
- src/
  - pages/
    - index.astro
    - post/
      - **[slug].astro**
  - env.d.ts
- .env
- astro.config.mjs
- package.json
</FileTree>

Then add the following content: 

```astro title="src/pages/posts/[slug].astro"
---
export async function getStaticPaths() {
  const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
  const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;

    const { results: posts } = await fetch(
        `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
            {
                apiKey: builderAPIpublicKey,
                fields: ["data.slug"].join(","),
                cachebust: "true",
            }
        ).toString()}`
    )
        .then((res) => res.json())
        .catch(
      // ...catch some errors...);
        )

    return [
        ...posts.map(({ data: { slug } }) => [
            {
                params: { slug },
            },
        ]),
    ];
}
const { slug } = Astro.params;
```

The fetch call is very similar to the one in the previous step(xxx). Here, the `getStaticPaths` function creates a static route for each blog post, based on the `slug` data field.

alt: This file generates a [dynamic route](https://docs.astro.build/en/core-concepts/routing/#static-ssg-mode) for each blog post based on the `slug` custom data field You filled when You created your blogpost on Builder.     

[âš¡ï¸ TO REVIEWER: I've looked into ways how to not repeat this fetch call and landed on the `integrations API`. That seemed a little complex. I'm thinking mb it's not too bad to repeat this code here, but I'm very open for suggestions or pointers on how to DRY it']

Next, add the following content:

```astro title="src/pages/posts/[slug].astro" ins={25-99}
---
export async function getStaticPaths() {
  const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
  const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;

    const { results: posts } = await fetch(
        `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
            {
                apiKey: builderAPIpublicKey,
                fields: ["data.slug"].join(","),
                cachebust: "true",
            }
        ).toString()}`
    )
        .then((res) => res.json())
        .catch(
      // ...catch some errors...);
        )

    return [
        ...posts.map(({ data: { slug } }) => [
            {
                params: { slug },
            },
        ]),
    ];
}
const { slug } = Astro.params;

const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
// Builder's API requires this field but for this use case the url doesn't seem to matter - the API returns the same HTML
const encodedUrl = encodeURIComponent("moot");

const { html: postHTML } = await fetch(
    `https://cdn.builder.io/api/v1/qwik/${builderModel}?${new URLSearchParams({
        apiKey: builderAPIpublicKey,
        url: encodedUrl,
        "query.data.slug": slug,
        cachebust: "true",
    }).toString()}`
)
    .then((res) => res.json())
    .catch(
      // ...catch more errors...);
        )
---
```

::: caution
This code is relying on the fact that each content entry in the `blogpost` model has in fact fields called `slug`, so make sure these fields are required and all pieces of content have them, including those that might have been created before. It's best to create a new model with the proper rules set up from the beginning for that reason. 
:::

:::info
The variables `builderModel` and `builderAPIpublicKey` need to be created again, since [`getStaticPaths` runs in its own isolated scope](https://docs.astro.build/en/reference/api-reference/#getstaticpaths).
:::

Here, you are fetching the HTML of each blogpost based on its `slug` custom data field. This HTML is made of the blocks you put on the page in Builder's editor.

Finally, render the HTML:

```astro title="src/pages/posts/[slug].astro" ins={25-99}
---
export async function getStaticPaths() {
  const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
  const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;

    const { results: posts } = await fetch(
        `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(
            {
                apiKey: builderAPIpublicKey,
                fields: ["data.slug"].join(","),
                cachebust: "true",
            }
        ).toString()}`
    )
        .then((res) => res.json())
        .catch(
      // ...catch some errors...);
        )

    return [
        ...posts.map(({ data: { slug } }) => [
            {
                params: { slug },
            },
        ]),
    ];
}
const { slug } = Astro.params;

const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;
const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;
// Builder's API requires this field but for this use case the url doesn't seem to matter - the API returns the same HTML
const encodedUrl = encodeURIComponent("moot");

const { html: postHTML } = await fetch(
    `https://cdn.builder.io/api/v1/qwik/${builderModel}?${new URLSearchParams({
        apiKey: builderAPIpublicKey,
        url: encodedUrl,
        "query.data.slug": slug,
        cachebust: "true",
    }).toString()}`
)
    .then((res) => res.json())
    .catch(
      // ...catch more errors...);
        )
---
<html lang="en">
  <head>
    <title>Preview for builder.io</title>
  </head>
  <body>     
    <header>
      Here be a header
    </header>

    <article>
        <Fragment set:html={postHTML} />
    </article>

    <footer>
      Here be a footer
    </footer>
  </body>     
</html>
```

This page matches the `builder-preview` page you created previously (xxx).

Now when you go to the route `posts/my-first-builder-post`, you should be able to see the blog post!

::: info
The full URL depends on how you are running your project and might go something like `localhost:3000/posts/my-first-builder-post`
:::

### Publishing your site

To deploy your website, visit our [deployment guides](/en/guides/deploy/) and follow the instructions for your preferred hosting provider.

#### Rebuild on Builder changes

If your project is using Astro's default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build whenever You click **Publish** in the Builder editor.

##### Netlify

To set up a webhook in Netlify:

1. Go to your site dashboard, then **Site Settings** and click on **Build & deploy**.

2. Under the **Continuous Deployment** tab, find the **Build hooks** section and click on **Add build hook**.

3. Provide a name for your webhook and select the branch you want to trigger the build on. Click on **Save** and copy the generated URL.

##### Vercel

To set up a webhook in Vercel:

1. Go to your project dashboard and click on **Settings**.

2. Under the **Git** tab, find the **Deploy Hooks** section.

3. Provide a name for your webhook and the branch you want to trigger the build on. Click **Add** and copy the generated URL.

##### Adding a webhook to Builder

::: info
Builder provides a guide for setting up a webhook [here](https://www.builder.io/c/docs/webhooks)
:::

To set up a webhook in Builder: 

0. Have the URL ready that your hosting provider generated in the previous step 
1. In your Builder dashboard go to the **Models** tab, and pick the **blogpost** model. 
2. In the new dialog, click on **Show More Options** and then on **Edit Webhooks** at the bottom.
3. Now add a new webhook by clicking on **+ Webhook** and then expand the Webhook that appeared by clicking on it.
4. Paste the URL that was generated by your hosting provider into the **Url** field.
5. The last thing to do is to click on **Show Advanced** under the URL field and click the toggle so that the option **Disable Payload** is **enabled**. Click on **Done** and you're done.

:::note
Not disabling the payload can cause the automated build process to break as your website gets bigger and bigger. With the payload disabled, Builder always sends a simple POST request.
::::

With this set up in place, when you click on the **Publish** button Builder lets your hosting provider know that new content was added. This causes your site to be rebuilt and during this process Astro fetches the newly published data. Nothing to do but lean back and pump out that sweet sweet content. 

## Official Resources

- Check out [the official Builder.io starter project](https://github.com/BuilderIO/builder/tree/main/examples/astro-solidjs), which uses Astro and SolidJS

## Community Resources

- Read [Connecting Builder.io's Visual CMS to Astro](https://www.hamatoyogi.dev/blog/astro-log/connecting-builderio-to-astro) by Yoav Ganbar

---

## TODO
[x] write draft
[x] follow the tutorial: general connecting  ("part 1")
[x] follow the tutorial: build blog ("part 2")
[x] dynamic preview URL??????
[x] go through stars * notes, mb make TODOs out of them
[x] ask Discord about tone and structure
[x] read WRITING.md
[x] look at other astro stuff for ideas about tone and structure --- contently, storyblok, ghost
[x] from contentful/ghost: take the prerequisite section about setting up the .env file 
[x] simplify: remove part 1, give instructions for setting up the preview URL in the blog section
[x] fix the flow of the instructions: in part 2 there is no mention of the preview URL. idea 1: leave part 1 to be a content section model, then just assume that and build on that. idea 2: link back to the preview URL / mention it again. idea 3: give the instructions again. also relevant here: simplify the first part by making it a **page** model?
[x] do a big general revision - tone, code, flow
[x] unify tone --- we vs you AI, 
[x] remove unused copy
[] unify the use of <FileTree>
* from Ghost CMS: take the structure of putting a <FileTree> at the beginning of each section
[] unify the structure of instructions --- numbering steps or not
* from both: think about mb taking a step-by-step approach to the [slug] section --- 
[] give concrete instructions instead of suggestions --- e.g. tell what title and what slug to put in (makes giving instructions simpler later on)
[] settle on tone and address in terms of you/You/we/let's  
[] go through code -- AI
  [] remove <BaseLayout> references
  [] simplify - destructuring? see also WRITING.md on destructuring props
  [] tidy up comments 
  [x] sort out the BUILDER_BLOGPOST_MODEL issue
[] go through the tutorial and test it again
[] fix typos -- AI
[] revise, simplify, clarify -- AI
[] check spots marked with "???"
[] add links
[] add screenshots 
[] preview site
[] revise again --- AI
* dodgy: no 'fetching data section'
* awkward: some repetition between #### testing it and the next step ### creating a blog post. idea: remove testing it and put create a blog post in its place
[] write PR --- mention new ideas
[] ask Discord about squashing commits
[] add a logo to `/public/logos`? see here: https://github.com/withastro/docs/blob/main/RECIPES.md#cms-deploy-and-migrate

## FURTHER ideas
* make WRITING.md more visible (e.g. put it on github repo)
* do this with an integration 
* add section for SSR whatever that is
* ðŸ§  High level stuff: explain how to structure the data of a blogpost - what to put in a data field and what to put directly via Builder's drag and drop. might be more of a tutorial about how to map builder templates to components
