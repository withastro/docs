---
title: TypeScript
description: Aprende a usar TypeScript incorporado en Astro.
i18nReady: true
---
import Since from '~/components/Since.astro'
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'
import Tabs from '~/components/tabs/Tabs.astro'
import { TabItem } from '@astrojs/starlight/components'



Astro tiene compatibilidad integrada con [TypeScript](https://www.typescriptlang.org/). Puedes importar archivos `.ts` y `.tsx` en tu proyecto de Astro, escribir c√≥digo TypeScript directamente dentro del [componente de Astro](/es/core-concepts/astro-components/#script-de-un-componente), e incluso utilizar un archivo de configuraci√≥n [`astro.config.ts`](/es/guides/configuring-astro/#archivo-de-configuraci√≥n-de-astro)  si as√≠ lo deseas.

Usando TypeScript, puedes prevenir errores en tiempo de ejecuci√≥n al definir las formas de los objetos y componentes en tu c√≥digo. Por ejemplo, si utilizas TypeScript para [tipar las props de tu componente](#props-de-componentes), obtendr√°s un error en tu editor si estableces una prop que tu componente no acepta.

No necesitas escribir c√≥digo de TypeScript en tus proyectos de Astro para obtener beneficios de este. Astro siempre trata el c√≥digo de tu componente como TypeScript, y la [Extensi√≥n de Astro para VSCode](/es/editor-setup/) inferir√° todo lo que pueda para proporcionar autocompletado, sugerencias, y errores en tu editor.

El servidor de desarrollo de Astro no realizar√° ning√∫n chequeo de tipado, pero puedes usar un [script aparte](#verificaci√≥n-de-tipos) para verificar errores de tipado desde la l√≠nea de comandos.

## Configuraci√≥n

Los *starter projects* de Astro incluyen un archivo `tsconfig.json` en tu proyecto. Incluso si no escribes c√≥digo TypeScript, este archivo es importante para que herramientas como Astro y VS Code sepan c√≥mo interpretar tu proyecto. Algunas caracter√≠sticas (como importaciones de paquetes npm) no est√°n totalmente soportadas en el editor sin un archivo `tsconfig.json`. Si instalas Astro manualmente, aseg√∫rate de crear este archivo por ti mismo.

Tres plantillas extensibles del archivo `tsconfig.json` est√°n incluidas con Astro: `base`, `strict` y `strictest`. La plantilla `base` habilita el soporte para caracter√≠sticas modernas de JavaScript y tambi√©n es usada como base para las otras plantillas. Recomendamos usar las plantillas `strict` o `strictest` si planeas escribir TypeScript en tu proyecto. Puedes ver y comparar las tres plantillas en [astro/tsconfigs/](https://github.com/withastro/astro/blob/main/packages/astro/tsconfigs/).

Para heredar una de las plantillas, usa [la opci√≥n `extends`](https://www.typescriptlang.org/tsconfig#extends):

```json title="tsconfg.json"
{
  "extends": "astro/tsconfig/base"
}
```

Adicionalmente, nuestras plantillas incluyen un archivo `env.d.ts` dentro de la carpeta `src` para proveer [tipos del cliente de Vite](https://vitejs.dev/guide/features.html#client-types) en tu proyecto:

```typescript title="env.d.ts"
/// <reference types="astro/client" />
```

Si no est√°s utilizando VSCode, puedes instalar el [plugin de Astro TypeScript](https://www.npmjs.com/package/@astrojs/ts-plugin) para admitir la importaci√≥n de archivos `.astro` desde archivos `.ts`  (lo cual puede ser √∫til para volver a exportar).

<PackageManagerTabs>
  <Fragment slot="npm">
  ```shell
  npm install @astrojs/ts-plugin
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```shell
  pnpm install @astrojs/ts-plugin
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```shell
  yarn add @astrojs/ts-plugin
  ```
  </Fragment>
</PackageManagerTabs>

Luego, agrega lo siguiente a tu archivo `tsconfig.json`:

```json title="tsconfig.json"
  "compilerOptions": {
    "plugins": [
      {
        "name": "@astrojs/ts-plugin"
      },
    ],
  }
```

Para comprobar que el plugin est√° funcionando, crea un archivo `.ts` e importa un componente de Astro en √©l. No deber√≠as tener mensajes de advertencia de tu editor.

### Componentes de Frameworks

Si tu proyecto utiliza [componentes de otros framework](/es/core-concepts/framework-components/), es posible que se necesiten configuraciones adicionales dependiendo el framework utilizado. Por favor revisa la documentaci√≥n de TypeScript de tu framework para m√°s informaci√≥n. ([Vue](https://vuejs.org/guide/typescript/overview.html#using-vue-with-typescript), [React](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup), [Preact](https://preactjs.com/guide/v10/typescript), [Solid](https://www.solidjs.com/guides/typescript))

## Importaci√≥n de tipos

Usa importaciones y exportaciones expl√≠citas de tipos siempre que sea posible.

```js del={1} ins={2} ins="type"
import { SomeType } from './script';
import type { SomeType } from './script';
```
Esto te ayudar√° a evitar casos extremos en los que el empaquetador de Astro intente empaquetar incorrectamente sus tipos importados como si fueran JavaScript.

Puedes configurar TypeScript para que obligue a realizar importaciones de tipos en tu archivo `.tsconfig`.

<Tabs group="typescript-version">
  <TabItem label="TypeScript ‚â§4.9">
		Establece [`importsNotUsedAsValues`](https://www.typescriptlang.org/tsconfig#importsNotUsedAsValues) en `"error"`. TypeScript verificar√° tus importaciones y te indicar√° cu√°ndo se debe utilizar `import type`. Esta configuraci√≥n se incluye de forma predeterminada en nuestras plantillas `strict` y `strictest`.

    ```json title="tsconfig.json" ins={3}
    {
      "compilerOptions": {
        "importsNotUsedAsValues": "error"
      }
    }
    ```
  </TabItem>
  <TabItem label="TypeScript ‚â•5.0">
		Establece [`verbatimModuleSyntax`](https://www.typescriptlang.org/tsconfig#verbatimModuleSyntax) en `true`. TypeScript verificar√° tus importaciones y te indicar√° cu√°ndo se debe utilizar `import type`.

    ```json title="tsconfig.json" ins={3}
    {
      "compilerOptions": {
        "verbatimModuleSyntax": true
      }
    }
    ```
  </TabItem>
</Tabs>

## Alias de importaci√≥n

Astro es compatible con [alias de importaci√≥n](/es/guides/aliases/) definidos en la configuraci√≥n `tsconfig.json` o `jsconfig.json` usando `paths`. [Lee nuestra gu√≠a](/es/guides/aliases/) para saber m√°s.


```astro title="src/pages/about/nate.astro" "@components" "@layouts"
---
import HelloWorld from '@components/HelloWorld.astro';
import Layout from '@layouts/Layout.astro';
---
```

```json title="tsconfig.json" {5-6}
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@components/*": ["src/components/*"],
      "@layouts/*": ["src/layouts/*"]
    }
  }
}
```

## Extender `window` y `globalThis`

Es posible que desees agregar una propiedad al objeto global. Puedes hacer esto agregando una declaraci√≥n global a tu archivo `env.d.ts`:

```ts title="env.d.ts"
declare global {
	var myString: string;
	function myFunction(): boolean;
}
export {};
```

Esto proporcionar√° tipado a `globalThis.myString` y `globalThis.myFunction`, as√≠ como a `window.myString` y `window.myFunction`.

Ten en cuenta que `window` s√≥lo est√° disponible en el c√≥digo del lado del cliente. `globalThis` est√° disponible tanto en el lado del servidor como en el lado del cliente, pero su valor del lado del servidor no se compartir√° con el cliente.

Si s√≥lo quieres tipar una propiedad en el objeto `window`, proporciona una interfaz `Window` en su lugar:

```ts title="env.d.ts"
interface Window {
	myFunction(): boolean;
}
```

## Props de componentes

Astro soporta escribir los tipos de las propiedades de tus componentes usando TypeScript. Para habilitar esto, agrega una interfaz `Props` a tu componente en el frontmatter. Puedes usar una declaraci√≥n `export`, pero no es necesaria. La [Extensi√≥n de Astro para VSCode](/es/editor-setup/) buscar√° autom√°ticamente la interfaz `Props` y te dar√° soporte de TS cuando uses ese componente en otra plantilla.
```astro title="src/components/HelloProps.astro" ins={2-5}
---
interface Props {
  name: string;
  greeting?: string;
}
const { greeting = 'Hello', name } = Astro.props;
---
<h2>{greeting}, {name}!</h2>
```
### Patrones comunes de tipos de prop

- Si tu componente no recibe props ni slots, puedes utilizar `type Props = Record<string, never>`.
- Si tu componente debe recibir children en el slot de forma predeterminada, puedes forzar esto usando `type Props = { children: any; };`.

## Utilidades de Tipos

<Since v="1.6.0" />

Astro tiene algunas utilidades de tipos integradas para patrones de tipos de props comunes. Estos est√°n disponibles en la extensi√≥n `astro/types`.

### Atributos HTML integrados

Astro provee el tipo `HTMLAttributes` para verificar que las etiquetas est√©n usando atributos HTML v√°lidos. Puedes usar estos tipos para ayudar a construir props en tus componentes.

Por ejemplo, si estuvieras construyendo un componente `<Link>`, podr√≠as hacer lo siguiente para reflejar los atributos HTML por defecto para las etiquetas `<a>` en los tipos de props de tu componente.

```astro title="src/components/Link.astro" ins="HTMLAttributes" ins="HTMLAttributes<'a'>"
---
import type { HTMLAttributes } from 'astro/types'
// usa un `type`
type Props = HTMLAttributes<'a'>;
// o extiendelo con una `interface`
interface Props extends HTMLAttributes<'a'> {
  myProp?: boolean;
}
const { href, ...attrs } = Astro.props;
---
<a href={href} {...attrs}>
  <slot />
</a>
```

Tambi√©n es posible extender las definiciones de JSX por defecto para agregar atributos no est√°ndar, redeclarando el namespace `astroHTML.JSX` en un archivo `.d.ts`.

```ts
// src/custom-attributes.d.ts

declare namespace astroHTML.JSX {
  interface HTMLAttributes {
    'data-count'?: number;
    'data-label'?: string;
  }
}
```

:::note
`astroHTML` es inyectado de manera global en los componentes `.astro`. Para usarlo en archivos de TypeScript, utiliza una [directiva de triple barra](https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html):

```ts
/// <reference types="astro/astro-jsx" />

type MyAttributes = astroHTML.JSX.ImgHTMLAttributes;
```
:::

### Tipo polim√≥rfico

<Since v="2.5.0" />

Astro incluye un helper para facilitar la construcci√≥n de componentes que pueden renderizarse como diferentes elementos HTML con total seguridad de tipos. Esto es √∫til para componentes como `<Link>` que pueden renderizarse como `<a>` o `<button>` dependiendo de las props que se le pasen.

El ejemplo a continuaci√≥n implementa un componente completamente tipado y polim√≥rfico que puede representarse como cualquier elemento HTML. El tipo [`HTMLTag`](#atributos-html-integrados) se utiliza para garantizar que la propiedad `as` sea un elemento HTML v√°lido.

```astro
---
import { HTMLTag, Polymorphic } from 'astro/types';
type Props<Tag extends HTMLTag> = Polymorphic<{ as: Tag }>;
const { as: Tag, ...props } = Astro.props;
---
<Tag {...props} />
```

### Inferir los tipos de `getStaticPaths()`

<Since v="2.1.0" />

Astro incluye ayudantes para trabajar con los tipos devueltos por tu funci√≥n [`getStaticPaths()`](/es/reference/api-reference/#getstaticpaths) para rutas din√°micas.

Puedes obtener el tipo de [`Astro.params`](/es/reference/api-reference/#astroparams) con `InferGetStaticParamsType` y el tipo de [`Astro.props`](/es/reference/api-reference/#astroprops) con `InferGetStaticPropsType`:

```astro title="src/pages/posts/[...slug].astro" {2,14-15}
---
import { InferGetStaticParamsType, InferGetStaticPropsType, GetStaticPaths  } from 'astro';

export const getStaticPaths = (async () => {
  const posts = await getCollection('blog');
  return posts.map((post) => {
    return {
      params: { slug: post.slug },
      props: { draft: post.data.draft, title: post.data.title },
    };
  });
}) satisfies GetStaticPaths;

type Params = InferGetStaticParamsType<typeof getStaticPaths>;
type Props = InferGetStaticPropsType<typeof getStaticPaths>;

const { slug } = Astro.params as Params;
//               			 ^? { slug: string; }
const { title } = Astro.props;
//                			^? { draft: boolean; title: string; }
---
```

## Verificaci√≥n de tipos

Para ver errores de tipos en tu editor, aseg√∫rate de tener instalada la [extensi√≥n de Astro VS Code](/es/editor-setup/). Ten en cuenta que los comandos `astro start` y `astro build` transpilar√°n el c√≥digo con esbuild, pero no ejecutar√°n ninguna verificaci√≥n de tipos. Para evitar que tu c√≥digo se compile si contiene errores de TypeScript, cambia tu script de "compilaci√≥n" en `package.json` a lo siguiente:

```json title="package.json" del={2} ins={3} ins="astro check && tsc --noEmit && "
  "scripts": {
    "build": "astro build",
    "build": "astro check && tsc --noEmit && astro build",
  },
```

:::note
`astro check` solo verifica los tipos dentro de los archivos `.astro`, y `tsc --noEmit` solo verifica los tipos dentro de los archivos `.ts` y `.tsx`. Para chequeo de tipos dentro de archivos de Svelte y Vue, puedes usar los paquetes [`svelte-check`](https://www.npmjs.com/package/svelte-check) y [`vue-tsc`](https://www.npmjs.com/package/vue-tsc) respectivamente.
:::

üìö Lee m√°s sobre las [importaciones de archivos `.ts`](/es/guides/imports/#typescript) en Astro.
üìö Lee m√°s sobre la [configuraci√≥n de TypeScript](https://www.typescriptlang.org/tsconfig/).

## Soluci√≥n de problemas

### Errores usando m√∫ltiples frameworks JSX a la vez

Puedes tener errores al utilizar m√∫ltiples frameworks JSX en el mismo proyecto, ya que cada framework requiere diferentes, y algunas veces, conflictivas configuraciones dentro del archivo `tsconfig.json.`

**Soluci√≥n**: Establece la [configuraci√≥n `jsxImportSource`](https://www.typescriptlang.org/tsconfig#jsxImportSource) a `react` (por defecto), `preact` o `solid-js` dependiendo cu√°l sea el framework m√°s utilizado. Luego, usa un [comentario pragma](https://www.typescriptlang.org/docs/handbook/jsx.html#configuring-jsx) dentro de cada archivo conflictivo de un framework distinto al establecido anteriormente.

Para la configuraci√≥n por defecto `jsxImportSource: react`, deber√≠as hacer lo siguiente:

```jsx
// Para Preact
/** @jsxImportSource preact */

// Para Solid
/** @jsxImportSource solid-js */
```
