---
title: Enrutamiento
description: Introducci√≥n al enrutamiento en Astro.
i18nReady: true
---
import FileTree from '~/components/FileTree.astro'
import RecipeLinks from "~/components/RecipeLinks.astro"
import Since from '~/components/Since.astro'

Astro utiliza **enrutamiento basado en archivos** para generar las URLs finales seg√∫n el contenido de la carpeta `src/pages/`. 

## Navegando entre p√°ginas

Astro usa elementos HTML est√°ndar [`<a>`](https://developer.mozilla.org/es/docs/Web/HTML/Element/a) para navegar entre rutas. No se proporciona ning√∫n componente `<Link>` espec√≠fico en Astro.

```astro title="src/pages/index.astro"
<p>¬°Leer m√°s <a href="/about/">sobre</a> Astro!</p>
```

## Rutas est√°ticas

Los [componentes p√°gina](/es/core-concepts/astro-pages/) `.astro` as√≠ como los archivos Markdown y MDX (`.md`, `.mdx`) dentro del directorio `src/pages/` **se convierten autom√°ticamente en p√°ginas de tu sitio web**. La ruta de cada p√°gina corresponde a su ruta y nombre de archivo dentro del directorio `src/pages/`.

```diff
# Ejemplo: Rutas est√°ticas
src/pages/index.astro        -> mysite.com/
src/pages/about.astro        -> mysite.com/about
src/pages/about/index.astro  -> mysite.com/about
src/pages/about/me.astro     -> mysite.com/about/me
src/pages/posts/1.md         -> mysite.com/posts/1
```

:::tip
¬°No hay una "configuraci√≥n de enrutamiento" separada para mantener en un proyecto Astro! Cuando se agrega un archivo al directorio `src/pages`, se crea autom√°ticamente una nueva ruta. En compilaciones est√°ticas, puedes personalizar el formato de salida del archivo usando la opci√≥n de configuraci√≥n [`build.format`](/es/reference/configuration-reference/#buildformat)
:::

## Rutas din√°micas

Un archivo de p√°gina Astro puede especificar par√°metros de ruta din√°micos en su nombre para generar m√∫ltiples p√°ginas emparejadas. Por ejemplo, `src/pages/authors/[author].astro` que generar√° una p√°gina por cada autor en tu blog. `author` se convierte en un _par√°metro_ al que puedes acceder dentro de la p√°gina.

En el modo de generaci√≥n est√°tico por defecto de Astro, estas p√°ginas ser√°n generadas en tiempo de compilaci√≥n, as√≠ que deber√≠as definir previamente la lista de `author`s para ese archivo. En modo SSR, se generar√° una p√°gina bajo petici√≥n para cada ruta que coincida.

### Modo Est√°tico (SSG)

Debido a que todas las rutas deben definirse en tiempo de compilaci√≥n, una ruta din√°mica debe exportar una funci√≥n `getStaticPaths()` que devuelva un array de objetos con una propiedad `params`. Cada uno de estos objetos generar√° su ruta correspondiente.

`[dogs].astro` define el par√°metro din√°mico `dog` en su nombre de archivo, as√≠ que los objetos devueltos por `getStaticPaths()` deben incluir `dog` en sus `params`. De esta manera la p√°gina puede acceder a este par√°metro por medio de `Astro.params`.

```astro title="src/pages/dogs/[dog].astro"
---
export function getStaticPaths() {
  return [
    {params: {dog: 'clifford'}},
    {params: {dog: 'rover'}},
    {params: {dog: 'spot'}},
  ];
}

const { dog } = Astro.params;
---
<div>¬°Buen chico, {dog}!</div>
```

Esto generar√° tres p√°ginas: `/dogs/clifford`, `/dogs/rover` y `/dogs/spot`, cada una mostrando el nombre de perro correspondiente.

El nombre de archivo puede incluir m√∫ltiples par√°metros, los cuales deben estar todos incluidos en los objetos `params` de `getStaticPaths()`:

```astro title="src/pages/[lang]-[version]/info.astro"
---
export function getStaticPaths () {
 return [
    {params: {lang: 'en', version: 'v1'}},
    {params: {lang: 'fr', version: 'v2'}},
  ];
}

const { lang, version } = Astro.params;
---
...
```

Esto generar√° `/en-v1/info` y `/fr-v2/info`.

Los par√°metros pueden incluirse en distintas partes del path. Por ejemplo, el archivo `src/pages/[lang]/[version]/info.astro` con la misma `getStaticPaths()` arriba generar√° las rutas `/en/v1/info` y `/fr/v2/info`.

üìö Lee m√°s sobre [`getStaticPaths()`](/es/reference/api-reference/#getstaticpaths).

<RecipeLinks slugs={["es/recipes/i18n"]} />

### Par√°metros Rest

Si necesitas m√°s flexibilidad en el enrutamiento de la URL, puedes usar un [par√°metro rest](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Functions/rest_parameters) (`[...param]`) en el nombre de archivo `.astro` para emparejar rutas de archivos de cualquier profundidad:

```astro title="src/pages/sequences/[...path].astro"
---
export function getStaticPaths() {
  return [
    {params: {path: 'uno/dos/tres'}},
    {params: {path: 'cuatro'}},
    {params: {path: undefined }}
  ]
}

const { path } = Astro.params;
---
...
```

Esto generar√° `/sequences/uno/dos/tres`, `/sequences/cuatro` y `/sequences`. (Definir el par√°metro restante como `undefined` permite emparejar con la p√°gina del nivel m√°s alto.)

Los par√°metros rest pueden usarse con **otros par√°metros nombrados**. Por ejemplo, el visor de archivos de GitHub puede ser representado con la siguiente ruta din√°mica:

```
/[org]/[repo]/tree/[branch]/[...file]
```

En este ejemplo, una solicitud a `/withastro/astro/tree/main/docs/public/favicon.svg` dar√≠a como resultado los siguientes par√°metros con nombre:

```js
{
	org: 'withastro',
	repo: 'astro',
	branch: 'main',
	file: 'docs/public/favicon.svg'
}
```

#### Ejemplo: P√°ginas din√°micas en m√∫ltiples niveles

En el siguiente ejemplo, un par√°metro rest (`[...slug]`) y la caracter√≠stica [`props`](/es/reference/api-reference/#transferencia-de-datos-con-props) de `getStaticPaths()` para generar p√°ginas para _slugs_ de diversa profundidad.

```astro title="src/pages/[...slug].astro"
---
export async function getStaticPaths() {
  const pages = [
    {
      slug: undefined,
      title: "Tienda de Astro",
      text: "¬°Te damos la bienvenida a la tienda de Astro!",
    },
    {
      slug: "products",
      title: "Productos de Astro",
      text: "Tenemos muchos productos para ti",
    },
    {
      slug: "products/astro-handbook",
      title: "El libro definitivo de Astro",
      text: "Si quieres aprender sobre Astro, debes leer este libro.",
    },
  ];
  return pages.map(({ slug, title, text }) => {
    return {
      params: { slug },
      props: { title, text },
    };
  });
}
const { title, text } = Astro.props;
---
<html>
  <head>
    <title>{title}</title>
  </head>
  <body>
    <h1>{title}</h1>
    <p>{text}</p>
  </body>
</html>
```

### Modo Servidor (SSR)
En el [modo SSR](/es/guides/server-side-rendering/), las rutas din√°micas se definen de la misma manera: incluyendo `[param]` o `[...path]` en corchetes a los nombres de tus archivos para emparejar con strings o paths arbitrarios. Pero, como esas rutas no se compilan con anticipaci√≥n, la p√°gina va a servirse con cualquier ruta que coincida. Como estas no son rutas "est√°ticas", no debemos usar `getStaticPaths`.

```astro title="src/pages/resources/[resource]/[id].astro"
---
const { resource, id } = Astro.params;
---
<h1>{resource}: {id}<h1>
```
Esta p√°gina ser√° servida para cualquier valor de `resource` y `id`: `resources/users/1`, `resources/colors/blue`, etc.

#### Modificando el ejemplo `[...slug]` para SSR

Debido a que las p√°ginas SSR no pueden usar `getStaticPaths`, no pueden recibir props. El [ejemplo anterior](#ejemplo-p√°ginas-din√°micas-en-m√∫ltiples-niveles) puede ser adaptado para el modo SSR buscando el valor del par√°metro `slug` en un objeto. Si la ruta est√° en la ra√≠z ("/"), el par√°metro slug va a ser `undefined`. Si el valor no existe en el objeto, redirigiremos a una p√°gina 404.

```astro title="src/pages/[...slug].astro"
---
const pages = [
	{
		slug: undefined,
		title: 'Tienda de Astro',
		text: '¬°Te damos la bienvenida a la tienda de Astro!',
	},
	{
		slug: 'products',
		title: 'Productos de Astro',
		text: 'Tenemos muchos productos para ti',
	},
	{
		slug: 'products/astro-handbook',
		title: 'El libro definitivo de Astro',
		text: 'Si quieres aprender sobre Astro, debes leer este libro.',
	}
];

const { slug } = Astro.params;
const page = pages.find((page) => page.slug === slug);
if (!page) return Astro.redirect("/404");
const { title, text } = page;
---
<html>
<head>
  <title>{title}</title>
</head>
<body>
  <h1>{title}</h1>
  <p>{text}</p>
</body>
</html>
```

## Redirecciones

A veces necesitar√°s redirigir a tus lectores a una nueva p√°gina, ya sea de forma permanente debido a cambios en la estructura de tu sitio o como respuesta a una acci√≥n como iniciar sesi√≥n en una ruta autenticada.

Puedes definir reglas para [redirigir a los usuarios a p√°ginas movidas permanentemente](#redirecciones-configuradas) en tu configuraci√≥n de Astro. O puedes redirigir a los [usuarios din√°micamente](#redirecciones-din√°micas) a medida que utilizan tu sitio.

### Redirecciones configuradas
<Since v="2.9.0" />

Puedes especificar un mapeo de redirecciones permanentes en la configuraci√≥n de Astro con el valor `redirects`. Para la mayor√≠a de las redirecciones, esto es un mapeo de una ruta antigua a la nueva ruta:

```js title="astro.config.mjs" {4-6}
import { defineConfig } from 'astro/config';
export default defineConfig({
  redirects: {
    '/old-page': '/new-page'
  }
});
```

Estas redirecciones siguen las mismas reglas que las rutas basadas en archivos. Se permiten rutas din√°micas siempre y cuando tanto las rutas nuevas como las antiguas contengan los mismos par√°metros, por ejemplo:

```js
{
  "/blog/[...slug]": "/articles/[...slug]"
}
```

Usando SSR o un adaptador est√°tico, tambi√©n puedes proporcionar un objeto como valor, lo que te permite especificar el c√≥digo de estado (`status`) adem√°s del nuevo destino (`destination`):

```js title="astro.config.mjs" {5-8}
import { defineConfig } from 'astro/config';
export default defineConfig({
  redirects: {
    '/old-page': {
      status: 302,
      destination: '/new-page'
    }
  }
});
```

Al ejecutar `astro build`, Astro generar√° archivos HTML con la etiqueta [meta refresh](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#examples) de forma predeterminada. En cambio, los adaptadores compatibles escribir√°n el archivo de configuraci√≥n del host con las redirecciones.

Por defecto, el c√≥digo de estado es `301`. Si est√°s generando archivos HTML est√°ticos, el servidor no utiliza el c√≥digo de estado.

### Redirecciones din√°micas

En el objeto global `Astro`, el m√©todo `Astro.redirect` te permite redirigir a otra p√°gina de forma din√°mica. Puedes hacer esto despu√©s de verificar si el usuario ha iniciado sesi√≥n obteniendo su sesi√≥n desde una cookie.

```astro title="src/pages/account.astro" {8}
---
import { isLoggedIn } from '../utils';
const cookie = Astro.request.headers.get('cookie');
// Si el usuario no ha iniciado sesi√≥n, redir√≠gelos a la p√°gina de inicio de sesi√≥n
if (!isLoggedIn(cookie)) {
  return Astro.redirect('/login');
}
---
<html>
  <!-- Aqu√≠ est√° la p√°gina... -->
</html>
```


### Orden de prioridad de rutas

Es posible que varias rutas coincidan con la misma ruta URL. Por ejemplo, cada una de estas rutas coincidir√≠a con `/posts/create`:

<FileTree>
- src/pages/
  - posts/
    - create.astro
    - [pid].astro
    - [...slug].astro
</FileTree>

Astro necesita saber qu√© ruta debe usarse para construir la p√°gina. Para ello, los ordena de acuerdo con las siguientes reglas:

- Las rutas est√°ticas sin par√°metros de ruta tendr√°n prioridad sobre todas las dem√°s rutas
- Las rutas din√°micas que usan par√°metros nombrados tienen prioridad sobre los par√°metros rest
- Las rutas din√°micas pre-renderizadas tienen prioridad sobre las rutas din√°micas del servidor
- Los par√°metros rest tienen la prioridad m√°s baja
- Los endpoints siempre tienen prioridad sobre las p√°ginas
- Los empates se resuelven alfab√©ticamente

Dado el ejemplo anterior, aqu√≠ hay algunos ejemplos de c√≥mo las reglas har√°n coincidir una URL solicitada con la ruta utilizada al compilar el HTML:

- `pages/posts/create.astro` - Construir√° `/posts/create`
- `pages/posts/[pid].astro` - Construir√° `/posts/1`, `/posts/abc`, etc. Pero no `/posts/create`
- `pages/posts/[...slug].astro` - Construir√° `/posts/1/2`, `/posts/a/b/c`, etc. Pero no `/posts/create`, ` /mensajes/1`, `/mensajes/abc`

Las redirecciones tambi√©n siguen las mismas reglas, pero se priorizan en *√∫ltimo lugar*. Si existe una ruta basada en archivos y una redirecci√≥n con el mismo nivel de prioridad de ruta, se elige la ruta basada en archivos.

## Paginaci√≥n

Astro mantiene la paginaci√≥n autom√°tica integrada para grandes colecciones de datos que deben dividirse en varias p√°ginas. Astro incluir√° autom√°ticamente metadatos de paginaci√≥n como la URL de la p√°gina anterior/siguiente, el n√∫mero total de p√°ginas y m√°s.

Los nombres de rutas paginadas deben usar la misma sintaxis `[corchete]` que una ruta din√°mica est√°ndar. Por ejemplo, el nombre de archivo `/astronautas/[page].astro` generar√° rutas para `/astronautas/1`, `/astronautas/2`, etc., donde `[page]` es el n√∫mero de p√°gina generado.

Puedes usar la funci√≥n `paginate()` para generar estas p√°ginas para un array de valores como este:

```astro /{ (paginate) }/ /paginate\\(.*\\)/ /(?<=const.*)(page)/ /page\\.[a-zA-Z]+/
---
// src/pages/astronauts/[page].astro
export async function getStaticPaths({ paginate }) {
  const astronautPages = [{
    astronaut: 'Neil Armstrong',
  }, {
    astronaut: 'Buzz Aldrin',
  }, {
    astronaut: 'Sally Ride',
  }, {
    astronaut: 'John Glenn',
  }];
  // Genera p√°ginas para nuestro array de astronautas, con 2 elementos por p√°gina
  return paginate(astronautPages, { pageSize: 2 });
}
// Todos los datos paginados se pasan en la prop "page"
const { page } = Astro.props;
---

<!--Muestra el n√∫mero de p√°gina actual. ¬°Tambi√©n puedes utilizar Astro.params.page!-->
<h1>P√°gina {page.currentPage}</h1>
<ul>
  <!--Enumera el array con informaci√≥n sobre astronautas-->
  {page.data.map(({ astronaut }) => <li>{astronaut}</li>)}
</ul>
```

Esto genera las siguientes p√°ginas, con 2 elementos por p√°gina:
- `/astronauts/1` - P√°gina 1: muestra "Neil Armstrong" y "Buzz Aldrin"
- `/astronauts/2` - P√°gina 2: Muestra "Sally Ride" y "John Glenn"

### La prop `page`

Cuando usas la funci√≥n `paginate()`, a cada p√°gina se le pasar√°n los datos a trav√©s de una prop `page`. La prop `page` tiene muchas propiedades √∫tiles, pero estas son las m√°s destacadas:
- **page.data** - array que contiene la porci√≥n de datos de p√°gina que introdujo a la funci√≥n `paginate()`
- **page.url.next** - enlace a la p√°gina siguiente del mismo conjunto de datos
- **page.url.prev** - enlace a la p√°gina anterior del mismo conjunto de datos

```astro /(?<=const.*)(page)/ /page\\.[a-zA-Z]+(?:\\.(?:prev|next))?/
---
// src/pages/astronauts/[page].astro
// Paginar la misma lista de objetos { astronaut } como en el ejemplo anterior
export async function getStaticPaths({ paginate }) { /* ... */ }
const { page } = Astro.props;
---
<h1>P√°gina {page.currentPage}</h1>
<ul>
  {page.data.map(({ astronaut }) => <li>{astronaut}</li>)}
</ul>
{page.url.prev ? <a href={page.url.prev}>Anterior</a> : null}
{page.url.next ? <a href={page.url.next}>Siguiente</a> : null}
```

#### Referencia completa de la API

```ts
interface Page<T = any> {
	/** resultado */
	data: T[];
	/** metadatos */
	/** el recuento del primer elemento de la p√°gina, a partir de 0 */
	start: number;
	/** el recuento del √∫ltimo elemento de la p√°gina, a partir de 0 */
	end: number;
	/** el n√∫mero total de resultados */
	total: number;
	/** el n√∫mero de la p√°gina actual, a partir de 1 */
	currentPage: number;
	/** el n√∫mero de elementos por p√°gina (predeterminado: 25) */
	size: number;
	/** el n√∫mero de la √∫ltima p√°gina */
	lastPage: number;
	url: {
		/** la url de la p√°gina actual */
		current: string;
		/** la url de la p√°gina anterior (si hay alguna) */
		prev: string | undefined;
		/** la url de la p√°gina siguiente (si hay alguna) */
		next: string | undefined;
	};
}
```

### Paginaci√≥n anidada

Un caso de uso m√°s avanzado de la paginaci√≥n es la **paginaci√≥n anidada.** Aqu√≠ es cuando la paginaci√≥n se combina con otros par√°metros de rutas din√°micas. Puedes usar la paginaci√≥n anidada para agrupar la colecci√≥n paginada por alguna propiedad o etiqueta.

Por ejemplo, si prefieres agrupar las publicaciones de Markdown paginadas por alguna etiqueta, usar√°s la paginaci√≥n anidada creando una p√°gina `/src/pages/[tag]/[page].astro` que coincida con las siguientes URL:

- `/red/1` (tag=red)
- `/red/2` (tag=red)
- `/blue/1` (tag=blue)
- `/green/1` (tag=green)

La paginaci√≥n anidada funciona devolviendo un array de resultados `paginate()` de `getStaticPaths()`, uno para cada grupo.

En el siguiente ejemplo, implementaremos la paginaci√≥n anidada para crear las URL enumeradas anteriormente:

```astro /(?:[(]|=== )(tag)/ "params: { tag }" /const [{ ]*(page|params)/
---
// src/pages/[tag]/[page].astro
export async function getStaticPaths({paginate}) {
  const allTags = ['rojo', 'azul', 'verde'];
  const allPosts = await Astro.glob('../../posts/*.md');
  // Para cada etiqueta, devuelve un resultado de paginate().
  // Aseg√∫rate de pasar `{params: {tag}}` a `paginate()`
  // As√≠ Astro sabr√° qu√© agrupaci√≥n de etiquetas usar.
  return allTags.flatMap((tag) => {
    const filteredPosts = allPosts.filter((post) => post.frontmatter.tag === tag);
    return paginate(filteredPosts, {
      params: { tag },
      pageSize: 10
    });
  });
}
const { page } = Astro.props;
const params = Astro.params;
```


## Excluyendo p√°ginas

Puedes excluir la generaci√≥n de p√°ginas o directorios a√±adiendo el prefijo (`_`). Los archivos con el prefijo `_` no ser√°n reconocidos por el router y no ser√°n generados en el directorio `dist/`.

Puedes usar esto para inhabilitar p√°ginas temporalmente y tambi√©n para poner tests, utilidades y componentes en la misma carpeta junto a sus p√°ginas correspondientes.

En este ejemplo, solo `src/pages/index.astro` y `src/pages/posts/post1.md` ser√°n generados como rutas y archivos `.html`.

```md mark="post1.md" mark="index.astro"
src/
‚îî‚îÄ‚îÄ pages/
   ‚îú‚îÄ‚îÄ _directorio-oculto/
   ‚îÇ   ‚îú‚îÄ‚îÄ page1.md
   ‚îÇ   ‚îî‚îÄ‚îÄ page2.md
   ‚îú‚îÄ‚îÄ _pagina-oculta.astro
   ‚îú‚îÄ‚îÄ index.astro
   ‚îî‚îÄ‚îÄ posts/
       ‚îú‚îÄ‚îÄ _UnComponente.astro
       ‚îú‚îÄ‚îÄ _utils.js
       ‚îî‚îÄ‚îÄ post1.md
```
