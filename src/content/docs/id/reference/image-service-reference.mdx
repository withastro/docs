---
title: API Layanan Gambar
i18nReady: true
---
import Since from '~/components/Since.astro';

`astro:assets` dirancang untuk memudahkan layanan optimasi gambar apa pun membangun layanan di atas Astro.

## Apa itu Layanan Gambar?

Astro menyediakan dua jenis layanan gambar: Lokal dan Eksternal.

- **Layanan lokal** menangani transformasi gambar langsung saat build untuk situs statis, atau saat runtime baik dalam mode pengembangan maupun untuk rendering on‑demand. Ini sering kali membungkus pustaka seperti Sharp, ImageMagick, atau Squoosh. Dalam mode dev dan pada rute produksi yang dirender on‑demand, layanan lokal menggunakan endpoint API untuk melakukan transformasi.
- **Layanan eksternal** menunjuk ke URL dan dapat menambahkan dukungan untuk layanan seperti Cloudinary, Vercel, atau server apa pun yang mematuhi [RIAPI](https://github.com/riapi/riapi).

## Membangun dengan Image Services API

Definisi layanan berbentuk objek default yang diekspor dengan berbagai metode yang diperlukan (“hook”).

Layanan eksternal menyediakan `getURL()` yang menunjuk ke `src` pada tag `<img>` keluaran.

Layanan lokal menyediakan metode `transform()` untuk melakukan transformasi pada gambar Anda, serta `getURL()` dan `parseURL()` untuk menggunakan endpoint pada mode dev dan saat dirender on‑demand.

Kedua jenis layanan dapat menyediakan `getHTMLAttributes()` untuk menentukan atribut lain pada tag `<img>` keluaran dan `validateOptions()` untuk memvalidasi serta memperkaya opsi yang diteruskan.

### Layanan Eksternal

Layanan eksternal menunjuk ke URL jarak jauh yang digunakan sebagai atribut `src` pada tag `<img>` akhir. URL jarak jauh tersebut bertanggung jawab untuk mengunduh, mentransformasi, dan mengembalikan gambar.

```ts
import type { ExternalImageService, ImageTransform, AstroConfig } from "astro";

const service: ExternalImageService = {
  validateOptions(options: ImageTransform, imageConfig: AstroConfig['image']) {
    const serviceConfig = imageConfig.service.config;

    // Enforce the user set max width.
    if (options.width && options.width > serviceConfig.maxWidth) {
      console.warn(`Image width ${options.width} exceeds max width ${serviceConfig.maxWidth}. Falling back to max width.`);
      options.width = serviceConfig.maxWidth;
    }

    return options;
  },
  getURL(options, imageConfig) {
    return `https://mysupercdn.com/${options.src}?q=${options.quality}&w=${options.width}&h=${options.height}`;
  },
  getHTMLAttributes(options, imageConfig) {
    const { src, format, quality, ...attributes } = options;
		return {
			...attributes,
			loading: options.loading ?? 'lazy',
			decoding: options.decoding ?? 'async',
		};
	}
};


export default service;
```

### Layanan Lokal

Untuk membuat layanan lokal Anda sendiri, Anda dapat menunjuk ke [endpoint bawaan](https://github.com/withastro/astro/blob/main/packages/astro/src/assets/endpoint/generic.ts) (`/_image`), atau Anda juga dapat membuat endpoint sendiri yang memanggil metode layanan.

```ts
import type { ImageTransform, LocalImageService, AstroConfig } from "astro";

const service: LocalImageService<AstroConfig["image"]> = {
  getURL(options: ImageTransform, imageConfig) {
    const searchParams = new URLSearchParams();
		searchParams.append('href', typeof options.src === "string" ? options.src : options.src.src);
		options.width && searchParams.append('w', options.width.toString());
		options.height && searchParams.append('h', options.height.toString());
		options.quality && searchParams.append('q', options.quality.toString());
		options.format && searchParams.append('f', options.format);
    return `/my_custom_endpoint_that_transforms_images?${searchParams}`;
    // Or use the built-in endpoint, which will call your parseURL and transform functions:
    // return `/_image?${searchParams}`;
  },
  parseURL(url: URL, imageConfig) {
    const params = url.searchParams;
    return {
      src: params.get('href')!,
      width: params.has('w') ? parseInt(params.get('w')!) : undefined,
      height: params.has('h') ? parseInt(params.get('h')!) : undefined,
			format: params.get('f'),
      quality: params.get('q'),
    };
  },
  async transform(inputBuffer: Uint8Array, options: { src: string, [key: string]: any }, imageConfig) {
    const { buffer } = await mySuperLibraryThatEncodesImages(options);
    return {
      data: buffer,
      format: options.format,
    };
  },
  getHTMLAttributes(options, imageConfig) {
		let targetWidth = options.width;
		let targetHeight = options.height;
		if (typeof options.src === "object") {
			const aspectRatio = options.src.width / options.src.height;

			if (targetHeight && !targetWidth) {
				targetWidth = Math.round(targetHeight * aspectRatio);
			} else if (targetWidth && !targetHeight) {
				targetHeight = Math.round(targetWidth / aspectRatio);
			}
		}

		const { src, width, height, format, quality, ...attributes } = options;

		return {
			...attributes,
			width: targetWidth,
			height: targetHeight,
			loading: attributes.loading ?? 'lazy',
			decoding: attributes.decoding ?? 'async',
		};
	},
  propertiesToHash: ['src', 'width', 'height', 'format', 'quality'], 
};
export default service;
```

Pada saat build untuk situs statis dan rute yang diprerender, baik `<Image />` maupun `getImage(options)` akan memanggil fungsi `transform()`. Keduanya meneruskan opsi baik melalui atribut komponen atau argumen `options`. Gambar yang telah ditransformasi akan dibangun ke folder `dist/_astro`. Nama file mereka akan berisi hash dari properti yang diteruskan ke `propertiesToHash`. Properti ini opsional dan akan bernilai default `['src', 'width', 'height', 'format', 'quality']`. Jika layanan gambar kustom Anda memiliki opsi lain yang mengubah hasil gambar, tambahkan ke array tersebut.

Dalam mode dev dan saat menggunakan adapter untuk render on‑demand, Astro tidak mengetahui terlebih dahulu gambar mana yang perlu dioptimalkan. Astro menggunakan endpoint GET (default: `/_image`) untuk memproses gambar saat runtime. `<Image />` dan `getImage()` meneruskan opsinya ke `getURL()`, yang akan mengembalikan URL endpoint. Lalu, endpoint memanggil `parseURL()` dan meneruskan properti yang dihasilkan ke `transform()`.

#### getConfiguredImageService & imageConfig

Jika Anda mengimplementasikan endpoint sendiri sebagai endpoint Astro, Anda dapat menggunakan `getConfiguredImageService` dan `imageConfig` untuk memanggil metode `parseURL` dan `transform` dari layanan Anda serta menyediakan konfigurasi gambar.

Untuk mengakses konfigurasi layanan gambar ([`image.service.config`](/id/reference/configuration-reference/#imageservice)), Anda dapat menggunakan `imageConfig.service.config`.

```ts title="src/api/my_custom_endpoint_that_transforms_images.ts"
import type { APIRoute } from "astro";
import { getConfiguredImageService, imageConfig } from 'astro:assets';

export const GET: APIRoute = async ({ request }) => {
  const imageService = await getConfiguredImageService();

  const imageTransform = imageService.parseURL(new URL(request.url), imageConfig);
  // ... fetch the image from imageTransform.src and store it in inputBuffer
  const { data, format } = await imageService.transform(inputBuffer, imageTransform, imageConfig);
  return new Response(data, {
			status: 200,
			headers: {
				'Content-Type': mime.getType(format) || ''
      }
    }
  );
}
```

[Lihat endpoint bawaan](https://github.com/withastro/astro/blob/main/packages/astro/src/assets/endpoint/generic.ts) untuk contoh lengkap.

## Hook

### `getURL()`

<p>

**Type:** `(options: ImageTransform, imageConfig: AstroConfig['image']) => string | Promise<string>`<br />
<Since v="2.1.0" />
</p>

**Wajib untuk layanan lokal dan eksternal**

Untuk layanan lokal, hook ini mengembalikan URL endpoint yang menghasilkan gambar Anda (untuk rendering on‑demand dan dalam mode dev). Hook ini tidak digunakan saat build. Endpoint lokal yang dituju `getURL()` dapat memanggil `parseURL()` dan `transform()`.

Untuk layanan eksternal, hook ini mengembalikan URL akhir dari gambar.

Untuk kedua jenis layanan, `options` adalah properti yang diteruskan oleh pengguna sebagai atribut komponen `<Image />` atau sebagai opsi ke `getImage()`. Tipenya adalah sebagai berikut:

```ts
export type ImageTransform = {
    // ESM imported images | remote/public image paths
    src: ImageMetadata | string;
    width?: number | undefined;
    height?: number | undefined;
    widths?: number[] | undefined;
	  densities?: (number | `${number}x`)[] | undefined;
    quality?: ImageQuality  | undefined;
    format?: OutputFormat | undefined;
    fit?: ImageFit | undefined;
    position?: string | undefined;
    [key: string]: any;
};
```

### `parseURL()`

<p>

**Type:** `(url: URL, imageConfig: AstroConfig['image']) => { src: string, [key: string]: any } | undefined | Promise<{ src: string, [key: string]: any }> | Promise<undefined>`<br />
<Since v="2.1.0" />
</p>

**Wajib untuk layanan lokal saja; tidak tersedia untuk layanan eksternal**

Hook ini mem‑parse URL yang dihasilkan oleh `getURL()` kembali menjadi objek dengan berbagai properti untuk digunakan oleh `transform` (untuk rendering on‑demand dan dalam mode dev). Hook ini tidak digunakan saat build.

### `transform()`

<p>

**Type:** `(inputBuffer: Uint8Array, options: { src: string, [key: string]: any }, imageConfig: AstroConfig['image']) => Promise<{ data: Uint8Array; format: ImageOutputFormat }>`<br />
<Since v="2.1.0" />
</p>

**Wajib untuk layanan lokal saja; tidak tersedia untuk layanan eksternal**

Hook ini melakukan transformasi dan mengembalikan gambar, dan dipanggil saat build untuk membuat berkas aset final.

Anda harus mengembalikan `format` agar tipe MIME yang tepat disajikan ke pengguna untuk rendering on‑demand dan mode pengembangan.

### `getHTMLAttributes()`

<p>

**Type:** `(options: ImageTransform, imageConfig: AstroConfig['image'] ) => Record<string, any> | Promise<Record<string, any>>`<br />
<Since v="2.1.0" />
</p>

**Opsional untuk layanan lokal maupun eksternal**

Hook ini mengembalikan semua atribut tambahan yang digunakan untuk merender gambar sebagai HTML, berdasarkan parameter yang diteruskan pengguna (`options`).

### `getSrcSet()`

<p>

**Type:** `(options: ImageTransform, imageConfig: AstroConfig['image'] ) => UnresolvedSrcSetValue[] | Promise<UnresolvedSrcSetValue[]>`<br />
<Since v="3.3.0" />
</p>

**Opsional untuk layanan lokal maupun eksternal.**

Hook ini menghasilkan beberapa varian gambar yang ditentukan, misalnya untuk membuat atribut `srcset` pada `<img>` atau `source` di dalam `<picture>`.

Hook ini mengembalikan array objek dengan properti berikut:

```ts
export type UnresolvedSrcSetValue = {
	transform: ImageTransform;
	descriptor?: string;
	attributes?: Record<string, any>;
};
```

### `validateOptions()`

<p>

**Type:** `(options: ImageTransform, imageConfig: AstroConfig['image'] ) => ImageTransform | Promise<ImageTransform>`
<Since v="2.1.4" />
</p>

**Opsional untuk layanan lokal maupun eksternal**

Hook ini memungkinkan Anda memvalidasi dan memperkaya opsi yang diteruskan oleh pengguna. Ini berguna untuk menetapkan nilai default atau memberi tahu pengguna bahwa suatu parameter diperlukan.

[Lihat bagaimana `validateOptions()` digunakan di layanan bawaan Astro](https://github.com/withastro/astro/blob/0ab6bad7dffd413c975ab00e545f8bc150f6a92f/packages/astro/src/assets/services/service.ts#L124).

## Konfigurasi Pengguna

Konfigurasikan layanan gambar yang akan digunakan di `astro.config.mjs`. Bentuk konfigurasinya seperti berikut:

```js title="astro.config.mjs"
import { defineConfig } from "astro/config";

export default defineConfig({
  image: {
    service: {
      entrypoint: "your-entrypoint", // 'astro/assets/services/sharp' | string,
      config: {
        // ... konfigurasi khusus layanan. Opsional.
      }
    }
  },
});
```

## Utilitas

Astro mengekspos sejumlah fungsi pembantu yang dapat digunakan untuk mengembangkan layanan gambar kustom. Utilitas ini dapat diimpor dari `astro/assets/utils`:

```ts
import { 
    isRemoteAllowed,
    matchHostname,
    matchPathname,
    matchPattern,
    matchPort,
    matchProtocol,
    isESMImportedImage,
    isRemoteImage,
    resolveSrc,
    imageMetadata,
    emitESMImage,
    emitImageMetadata,
    getOrigQueryParams,
    inferRemoteSize,
    propsToFilename,
    hashTransform
} from "astro/assets/utils";
```

### `isRemoteAllowed()`

<p>
**Type:** `(src: string, { domains, remotePatterns }: { domains: string[], remotePatterns: RemotePattern[] }) => boolean`<br />
<Since v="4.0.0" />
</p>

Menentukan apakah suatu sumber daya jarak jauh tertentu, yang diidentifikasi oleh URL sumbernya, diizinkan berdasarkan domain dan pola jarak jauh yang ditentukan.

```ts
import { isRemoteAllowed } from 'astro/assets/utils';

const testImageURL = 'https://example.com/images/test.jpg';
const domains = ['example.com', 'anotherdomain.com'];
const remotePatterns = [
  { protocol: 'https', hostname: 'images.example.com', pathname: '/**' }, // Allow any path under this hostname
];

const url = new URL(testImageURL);
const isAllowed = isRemoteAllowed(url.href, { domains, remotePatterns });

console.log(`Is the remote image allowed? ${isAllowed}`);
```

### `matchHostname()`

<p>
**Type:** `(url: URL, hostname?: string, allowWildcard = false) => boolean`<br />
<Since v="4.0.0" />
</p>

Mencocokkan hostname suatu URL dengan hostname yang ditentukan, dengan dukungan opsional untuk pola wildcard.

```ts
import { matchHostname } from 'astro/assets/utils';

const testURL = new URL('https://sub.example.com/path/to/resource');

// Example usage of matchHostname
const hostnameToMatch = 'example.com';

// Match without wildcard
const isMatchWithoutWildcard = matchHostname(testURL, hostnameToMatch);
console.log(`Does the hostname match without wildcard? ${isMatchWithoutWildcard}`); // Output: false

// Match with wildcard
const isMatchWithWildcard = matchHostname(testURL, hostnameToMatch, true);
console.log(`Does the hostname match with wildcard? ${isMatchWithWildcard}`); // Output: true
```

### `matchPathname()`

<p>
**Type:** `(url: URL, pathname?: string, allowWildcard = false) => boolean`<br />
<Since v="4.0.0" />
</p>

Mencocokkan pathname suatu URL dengan pola yang ditentukan, dengan dukungan opsional untuk wildcard.

```ts
import { matchPathname } from 'astro/assets/utils';

const testURL = new URL('https://example.com/images/photo.jpg');

// Example pathname to match
const pathnameToMatch = '/images/photo.jpg';

// Match without wildcard
const isMatchWithoutWildcard = matchPathname(testURL, pathnameToMatch);
console.log(`Does the pathname match without wildcard? ${isMatchWithoutWildcard}`); // Output: true

// Match with wildcard
const wildcardPathname = '/images/*';
const isMatchWithWildcard = matchPathname(testURL, wildcardPathname, true);
console.log(`Does the pathname match with wildcard? ${isMatchWithWildcard}`); // Output: true
```

### `matchPattern()`

<p>
**Type:** `(url: URL, remotePattern: RemotePattern) => boolean`<br />
<Since v="4.0.0" />
</p>

Mengevaluasi apakah suatu URL cocok dengan pola jarak jauh yang ditentukan berdasarkan protocol, hostname, port, dan pathname.

```ts
import { matchPattern } from 'astro/assets/utils';

const testURL = new URL('https://images.example.com/photos/test.jpg');

// Define a remote pattern to match the URL
const remotePattern = {
  protocol: 'https',
  hostname: 'images.example.com',
  pathname: '/photos/**', // Wildcard to allow all files under /photos/
  port: '', // Optional: Match any port or leave empty for default
};

// Check if the URL matches the remote pattern
const isPatternMatched = matchPattern(testURL, remotePattern);

console.log(`Does the URL match the remote pattern? ${isPatternMatched}`); // Output: true
```

### `matchPort()`

<p>
**Type:** `(url: URL, port?: string) => boolean`<br />
<Since v="4.0.0" />
</p>

Memeriksa apakah port pada URL yang diberikan cocok dengan port yang ditentukan. Jika tidak ada port yang diberikan, mengembalikan `true`.

```ts
import { matchPort } from 'astro/assets/utils';

const testURL1 = new URL('https://example.com:8080/resource');
const testURL2 = new URL('https://example.com/resource');

// Example usage of matchPort
const portToMatch = '8080';

// Match a URL with a port specified
const isPortMatch1 = matchPort(testURL1, portToMatch);
console.log(`Does the port match? ${isPortMatch1}`); // Output: true

// Match a URL without a port specified (default port will be assumed)
const isPortMatch2 = matchPort(testURL2, portToMatch);
console.log(`Does the port match? ${isPortMatch2}`); // Output: false

// Check a URL without explicitly providing a port (defaults to true if port is undefined)
const isPortMatch3 = matchPort(testURL1);
console.log(`Does the port match (no port specified)? ${isPortMatch3}`); // Output: true
```

### `matchProtocol()`

<p>
**Type:** `(url: URL, protocol?: string) => boolean`<br />
<Since v="4.0.0" />
</p>

Membandingkan protokol dari URL yang diberikan dengan protokol yang ditentukan.

```ts
import { matchProtocol } from 'astro/assets/utils';

const testURL1 = new URL('https://example.com/resource');
const testURL2 = new URL('http://example.com/resource');

// Example usage of matchProtocol
const protocolToMatch = 'https';

// Match a URL with correct protocol
const isProtocolMatch1 = matchProtocol(testURL1, protocolToMatch);
console.log(`Does the protocol match for testURL1? ${isProtocolMatch1}`); // Output: true

// Match a URL with incorrect protocol
const isProtocolMatch2 = matchProtocol(testURL2, protocolToMatch);
console.log(`Does the protocol match for testURL2? ${isProtocolMatch2}`); // Output: false

// Match a URL without explicitly providing a protocol (defaults to true if protocol is undefined)
const isProtocolMatch3 = matchProtocol(testURL1);
console.log(`Does the protocol match (no protocol specified)? ${isProtocolMatch3}`); // Output: true
```

### `isESMImportedImage()`

<p>
  **Type:** `(src: ImageMetadata | string) => boolean`<br />
  <Since v="4.0.0" />
</p>

Menentukan apakah sumber yang diberikan adalah gambar yang diimpor sebagai ESM (ECMAScript Module).

```ts
import { isESMImportedImage } from 'astro/assets/utils';

// Example usage of isESMImportedImage
const imageMetadataExample = {
  src: '/images/photo.jpg',
  width: 800,
  height: 600,
  format: 'jpg',
};

const filePathExample = '/images/photo.jpg';

// Check if the input is an ESM imported image
const isMetadataImage = isESMImportedImage(imageMetadataExample);
console.log(`Is imageMetadataExample an ESM imported image? ${isMetadataImage}`); // Output: true

const isFilePathImage = isESMImportedImage(filePathExample);
console.log(`Is filePathExample an ESM imported image? ${isFilePathImage}`); // Output: false
```

### `isRemoteImage()`

<p>
  **Type:** `(src: ImageMetadata | string) => boolean`<br />
  <Since v="4.0.0" />
</p>

Menentukan apakah sumber yang diberikan merupakan URL gambar jarak jauh dalam bentuk string.

```ts
import { isRemoteImage } from 'astro/assets/utils';

// Example usage of isRemoteImage
const remoteImageUrl = 'https://example.com/images/photo.jpg';
const localImageMetadata = {
  src: '/images/photo.jpg',
  width: 800,
  height: 600,
  format: 'jpg',
};

// Check if the input is a remote image URL
const isRemote1 = isRemoteImage(remoteImageUrl);
console.log(`Is remoteImageUrl a remote image? ${isRemote1}`); // Output: true

const isRemote2 = isRemoteImage(localImageMetadata);
console.log(`Is localImageMetadata a remote image? ${isRemote2}`); // Output: false
```

### `resolveSrc()`

<p>
  **Type:** `(src: UnresolvedImageTransform['src']) => Promise<string | ImageMetadata>`<br />
  <Since v="4.0.0" />
</p>

Mengembalikan sumber gambar. Fungsi ini memastikan bahwa jika `src` berupa Promise (mis. `import()` dinamis), maka akan di‑await dan `src` yang benar diekstrak. Jika `src` sudah berupa nilai yang terselesaikan, nilai tersebut dikembalikan apa adanya.

```ts
import { resolveSrc } from 'astro/assets/utils';
import localImage from "./images/photo.jpg";

const resolvedLocal = await resolveSrc(localImage);
// will be `{ src: '/images/photo.jpg', width: 800, height: 600, format: 'jpg' }`

const resolvedRemote = await resolveSrc("https://example.com/remote-img.jpg");
// will be `"https://example.com/remote-img.jpg"`

const resolvedDynamic = await resolveSrc(import("./images/dynamic-image.jpg"))
// will be `{ src: '/images/dynamic-image.jpg', width: 800, height: 600, format: 'jpg' }`
```

### `imageMetadata()`

<p>
  **Type:** `(data: Uint8Array, src?: string) => Promise<Omit<ImageMetadata, 'src' | 'fsPath'>>`<br />
  <Since v="4.0.0" />
</p>

Menarik metadata gambar seperti dimensi, format, dan orientasi dari data gambar yang diberikan.

```ts
import { imageMetadata } from 'astro/assets/utils';

async function extractImageMetadata() {
  // Example image data (Uint8Array)
  const exampleImageData = new Uint8Array([/* ...binary image data... */]);

  // Optional source path (useful for debugging or additional metadata context)
  const sourcePath = '/images/photo.jpg';

  try {
    // Extract metadata from the image data
    const metadata = await imageMetadata(exampleImageData, sourcePath);

    console.log('Extracted Image Metadata:', metadata);
    // Example output:
    // {
    //   width: 800,
    //   height: 600,
    //   format: 'jpg',
    //   orientation: undefined
    // }
  } catch (error) {
    console.error('Failed to extract metadata from image:', error);
  }
}

await extractImageMetadata();
```

### `emitESMImage()`

:::caution[Deprecated]
Gunakan fungsi [`emitImageMetadata`](#emitimagemetadata) sebagai gantinya.
:::

<p>
  **Type:** `(id: string | undefined, _watchMode: boolean, experimentalSvgEnabled: boolean,  fileEmitter?: FileEmitter) => Promise<ImageMetadataWithContents | undefined>`<br />
  <Since v="4.0.0" />
</p>

Memproses berkas gambar dan memancarkan metadatanya serta (opsional) isinya. Dalam mode build, fungsi menggunakan `fileEmitter` untuk menghasilkan referensi aset. Dalam mode pengembangan, fungsi me-resolve ke URL berkas lokal dengan parameter kueri untuk metadata.

```ts

import { emitESMImage } from 'astro/assets/utils';

const imageId = '/images/photo.jpg';
const unusedWatchMode = false; // Deprecated, unused 
const unusedExperimentalSvgEnabled = false; // Set to `true` only if you are using SVG and want the file data to be embedded

try {
  const result = await emitESMImage(imageId, unusedWatchMode, unusedExperimentalSvgEnabled);
  if (result) {
    console.log('Image metadata with contents:', result);
    // Example output:
    // {
    //   width: 800,
    //   height: 600,
    //   format: 'jpg',
    //   contents: Uint8Array([...])
    // }
  } else {
    console.log('No metadata was emitted for this image.');
  }
} catch (error) {
  console.error('Failed to emit ESM image:', error);
}

```

### `emitImageMetadata()`

<p>
  **Type:** `(id: string | undefined, fileEmitter?: FileEmitter) => Promise<ImageMetadataWithContents | undefined>`<br />
  <Since v="5.7.0" />
</p>

Memproses berkas gambar dan memancarkan metadatanya serta (opsional) isinya. Dalam mode build, fungsi menggunakan `fileEmitter` untuk menghasilkan referensi aset. Dalam mode pengembangan, fungsi me-resolve ke URL berkas lokal dengan parameter kueri untuk metadata.

```ts

import { emitImageMetadata } from 'astro/assets/utils';

const imageId = '/images/photo.jpg';

try {
  const result = await emitImageMetadata(imageId);
  if (result) {
    console.log('Image metadata with contents:', result);
    // Example output:
    // {
    //   width: 800,
    //   height: 600,
    //   format: 'jpg',
    //   contents: Uint8Array([...])
    // }
  } else {
    console.log('No metadata was emitted for this image.');
  }
} catch (error) {
  console.error('Failed to emit ESM image:', error);
}

```

### `getOrigQueryParams()`

<p>
  **Type:** `(params: URLSearchParams) => Pick<ImageMetadata, 'width' | 'height' | 'format'> | undefined`<br />
  <Since v="4.0.0" />
</p>

Mengambil `width`, `height`, dan `format` dari sebuah gambar melalui objek [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams). Jika salah satu parameter hilang atau tidak valid, fungsi mengembalikan `undefined`.

```ts

import { getOrigQueryParams } from 'astro/assets/utils';

const url = new URL('https://example.com/image.jpg?width=800&height=600&format=jpg');
const queryParams = url.searchParams;

// Extract the original query parameters
const origParams = getOrigQueryParams(queryParams);

if (origParams) {
  console.log('Original query parameters:', origParams);
  // Example output:
  // {
  //   width: 800,
  //   height: 600,
  //   format: 'jpg'
  // }
} else {
  console.log('Failed to extract original query parameters.');
}
```

### `inferRemoteSize()`

<p>
  **Type:** `(url: string) => Promise<Omit<ImageMetadata, 'src' | 'fsPath'>>`<br />
  <Since v="4.0.0" />
</p>

Menyimpulkan dimensi gambar jarak jauh dengan melakukan streaming datanya dan menganalisisnya secara progresif hingga metadata yang cukup tersedia.

```ts

import { inferRemoteSize } from 'astro/assets/utils';

async function getRemoteImageSize() {
  const remoteImageUrl = 'https://example.com/image.jpg';

  try {
    // Infer remote image size from the URL
    const imageSize = await inferRemoteSize(remoteImageUrl);

    console.log('Inferred remote image size:', imageSize);
    // Example output:
    // {
    //   width: 1920,
    //   height: 1080,
    //   format: 'jpg'
    // }
  } catch (error) {
    console.error('Failed to infer the size of the remote image:', error);
  }
}

await getRemoteImageSize();
```

### `propsToFilename()`

<p>
  **Type:** `(filePath: string, transform: ImageTransform, hash: string) => string`<br />
  <Since v="4.0.0" />
</p>

Menghasilkan nama file terformat untuk sebuah gambar berdasarkan path sumbernya, properti transformasi, dan hash unik.

Format nama berkasnya sebagai berikut:

`<prefixDirname>/<baseFilename>_<hash><outputExtension>`

- `prefixDirname`: Jika gambar diimpor sebagai ESM, ini adalah nama direktori dari path berkas asli; jika bukan, akan menjadi string kosong.
- `baseFilename`: Nama dasar berkas atau nama pendek yang di‑hash jika berkas berupa `data:` URI.
- `hash`: String hash unik yang dibuat untuk membedakan berkas hasil transformasi.
- `outputExtension`: Ekstensi berkas keluaran yang diambil dari `transform.format` atau ekstensi berkas asli.

```ts
import { propsToFilename } from 'astro/assets/utils';

function generateTransformedFilename() {
  const filePath = '/images/photo.jpg';
  const transform = {
    format: 'png',
    src: '/images/photo.jpg'
  };
  const hash = 'abcd1234';

  // Generate the transformed filename based on the file path, transformation, and hash
  const filename = propsToFilename(filePath, transform, hash);

  console.log('Generated transformed filename:', filename);
  // Example output: '/images/photo_abcd1234.png'
}

generateTransformedFilename();
```

### `hashTransform()`

<p>
  **Type:** `(transform: ImageTransform, imageService: string, propertiesToHash: string[]) => string`<br />
  <Since v="4.0.0" />
</p>

Mengubah objek `transform` yang diberikan menjadi string hash berdasarkan properti terpilih dan `imageService` yang ditentukan.

```ts

import { hashTransform } from 'astro/assets/utils';

function generateTransformHash() {
  const transform = {
    src: '/images/photo.jpg',
    width: 800,
    height: 600,
    format: 'jpg',
  };

  const imageService = 'astroImageService';
  const propertiesToHash = ['width', 'height', 'format'];

  // Generate the hash based on the transform, image service, and properties
  const hash = hashTransform(transform, imageService, propertiesToHash);

  console.log('Generated transform hash:', hash);
  // Example output: 'd41d8cd98f00b204e9800998ecf8427e'
}

generateTransformHash();
```