---
title: Astro v5へのアップグレード
description: プロジェクトを Astro v5.0にアップグレードする方法。
sidebar:
  label: v5.0
i18nReady: true
---
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'
import { Steps } from '@astrojs/starlight/components';
import ReadMore from '~/components/ReadMore.astro'
import SourcePR from '~/components/SourcePR.astro'

このガイドでは、Astro v4 から Astro v5 への移行をサポートします。

もし、古いプロジェクトを v4 にアップグレードする必要がある場合は、[以前の移行ガイド](/ja/guides/upgrade-to/v4/) を見てください。

v4 のドキュメントを見たい場合は、[v4.16 スナップショットのドキュメントサイトはメンテナンスされていません](https://v4.docs.astro.build/) にアクセスしてください。

## Astro のアップグレード

まずは、パッケージマネージャーを使って、プロジェクトの Astro を最新バージョンに更新しましょう。

<PackageManagerTabs>
  <Fragment slot="npm">
  ```shell
  # Astro と公式インテグレーションを一緒にアップグレードします
  npx @astrojs/upgrade
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```shell
  # Astro と公式インテグレーションを一緒にアップグレードします
  pnpm dlx @astrojs/upgrade
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```shell
  # Astro と公式インテグレーションを一緒にアップグレードします
  yarn dlx @astrojs/upgrade
  ```
  </Fragment>
</PackageManagerTabs>

必要に応じて、[Astro インテグレーションを手動でアップグレード](/ja/guides/integrations-guide/#manual-upgrading) することもできます。また、プロジェクト内の他の依存関係をアップグレードする必要がある場合もあります。

:::note[Need to continue?]
Astro をアップグレードした後は、プロジェクトに変更を加える必要がない場合もあります。

ただし、エラーや予期しない動作が発生した場合は、このガイドで変更点を確認して、プロジェクトを更新してください。
:::

Astro v5.0 では、いくつかの[破壊的な変更](#breaking-changes)や、機能の削除、非推奨などが行われています。

v5.0 にアップグレードした後、プロジェクトが期待通りに動作しない場合は、このガイドで変更点の概要とコードベースの更新方法を確認してください。

See [the Astro changelog](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) for full release notes. 
リリースノートの全文については、[Astro の変更ログ](https://github.com/withastro/astro/blob/main/packages/astro/CHANGELOG.md) をご覧ください。

## 依存関係のアップグレード

Astro の依存関係のメジャーアップグレードは、プロジェクトが壊れる可能性があります。

### Vite 6.0

Astro v5.0 は、開発サーバーおよび本番バンドラーとして Vite v6.0 にアップグレードされます。

#### どうすればいいですか？

Vite 固有のプラグイン、構成、または API を使用している場合は、[Vite 移行ガイド](https://vite.dev/guide/migration.html) でそれらの変更点を確認し、必要に応じてプロジェクトをアップグレードしてください。

### `@astrojs/mdx`

<SourcePR number="11741" title="Cleanup unused JSX code"/>

Astro v4.x では、Astro は `@astrojs/mdx` インテグレーションの内部 JSX 処理を実行しました。

Astro v5.0では、JSX と MDX を処理し、レンダリングする機能を `@astrojs/mdx` パッケージに直接移しました。これは、Astro 5.0 が以前のバージョンの MDX インテグレーションと互換性がないことを意味します。

#### どうすればいいですか？

プロジェクトに `.mdx` ファイルが含まれている場合は、JSX がインテグレーションによって適切に処理されるために、`@astrojs/mdx` を最新バージョン (v4.0.0) にアップグレードする必要があります。

実験的な [Astro Container API](/ja/reference/container-reference/) で MDX サーバーレンダラーを使用している場合は、新しい場所を反映するようにインポートを更新する必要があります。

```ts del={1} ins={2}
import mdxRenderer from "astro/jsx/server.js";
import mdxRenderer from "@astrojs/mdx/server.js";
```

<ReadMore>プロジェクトでの [MDX の使用](/ja/guides/integrations-guide/mdx/) について詳しく学びましょう。</ReadMore>

## 古い (レガシー) 機能

以下の機能は、古い (レガシー) 機能と見なされるようになりました。これらは正常に機能するはずですが、推奨されなくなり、メンテナンスモードになっています。これらは将来の改善は見られず、ドキュメントは更新されません。これらの機能は最終的に非推奨になり、完全に削除されます。

### Legacy: v2.0 コンテンツコレクション API

Astro 4.x では、コンテンツコレクションは、[Astro v2.0 で最初に導入されたコンテンツコレクション API](https://astro.build/blog/introducing-content-collections/) を使用して定義、クエリ、およびレンダリングされました。すべてのコレクションエントリは、確保済みの `src/content/` フォルダー内のローカルファイルでした。さらに、Astro の [個々のページのビルドを除外するためのファイル名規則](/ja/guides/routing/#excluding-pages) は、コンテンツコレクション API に組み込まれていました。

Astro 5.0 は、コンテンツレイヤー API を使用した新しいバージョンのコンテンツコレクションを導入し、パフォーマンスの向上と機能の追加をもたらします。このリリースでは、古い (レガシー) コレクションと新しい (コンテンツレイヤー API) コレクションが共存できますが、既存のレガシーコレクションには破壊的な変更の可能性があります。

このリリースでは、コレクションエントリファイル名の先頭にアンダースコア (`_`) を付けてルートのビルドを防ぐオプションも削除されました。

#### どうすればいいですか？

既存のコレクションは、できるだけ早く [新しいコンテンツレイヤー API に変換](/ja/guides/upgrade-to/v5/#updating-existing-collections) し、新しいコレクションはコンテンツレイヤー API を使用して作成することをお勧めします。

コレクションを変換できない場合は、[レガシーコレクションの変更点](/ja/guides/upgrade-to/v5/#breaking-changes-to-legacy-content-and-data-collections) を参照し、既存のコレクションが影響を受け、更新が必要かどうかを確認してください。

現時点でコレクションに変更を加えることができない場合は、[ `legacy.collections` フラグを有効にする](/ja/guides/upgrade-to/v5/#enabling-the-legacycollections-flag) ことができます。これにより、レガシーフラグがサポートされなくなるまで、コレクションを現在の状態に保つことができます。

<ReadMore>更新された [コンテンツコレクション](/ja/guides/content-collections/) について詳しく学びましょう。</ReadMore>

##### 既存のコレクションの更新

既存のコンテンツコレクション (`type: 'content'` または `type: 'data'`) を更新してコンテンツレイヤー API を使用するための手順を以下に示します。

<details>
<summary>コレクションを更新するための手順</summary>

<Steps>

1. **コンテンツ構成ファイルを移動します**。このファイルは、`src/content/` フォルダー内から居なくなり、`src/content.config.ts` に存在するようになりました。

2. **コレクション定義を編集します**。更新されたコレクションには、コレクションの場所 (`base`) のフォルダーと、一致するコレクションエントリファイル名と拡張子を定義する `pattern` の両方を示す `loader` が必要です。(また、以下の例を更新する必要があるかもしれません。[globster.xyz](https://globster.xyz/) を使用すると、グロブ・パターンを確認できます。) コレクション `type` を選択するオプションは使用できなくなりました。

    ```ts ins={3,8} del={7}
    // src/content.config.ts
    import { defineCollection, z } from 'astro:content';
    import { glob } from 'astro/loaders';

    const blog = defineCollection({
      // コンテンツレイヤーでは、`type` を定義しなくなりました
      type: 'content',
      loader: glob({ pattern: '**/[^_]*.{md,mdx}', base: "./src/data/blog" }),
      schema: z.object({
        title: z.string(),
        description: z.string(),
        pubDate: z.coerce.date(),
        updatedDate: z.coerce.date().optional(),
      }),
    });
    ```

3. **参照を `slug` から `id` に変更します**。コンテンツレイヤーコレクションには、予約済みの `slug` フィールドがありません。代わりに、更新されたすべてのコレクションに `id` があります。

    ```astro ins={7} del={6}
    // src/pages/[slug].astro
    ---
    export async function getStaticPaths() {
      const posts = await getCollection('blog');
      return posts.map((post) => ({
        params: { slug: post.slug },
        params: { slug: post.id },
        props: post,
      }));
    }
    ---
    ```
    変更された `getStaticPaths()` パラメーターの値と一致するように、動的ルーティングファイル名を更新することもできます。

4. **新しい `render()` 関数に切り替えます**。エントリではシリアライズ可能なプレーンオブジェクトになったため、`render()` メソッドがなくなりました。代わりに、`astro:content` から `render()` 関数をインポートします。

    ```astro title="src/pages/index.astro" ins=", render" del={6} ins={7}
    ---
    import { getEntry, render } from 'astro:content';

    const post = await getEntry('blog', params.slug);

    const { Content, headings } = await post.render();
    const { Content, headings } = await render(post);
    ---
    <Content />
    ```
</Steps>

</details>

##### レガシーの `content` および `data` コレクションに対する破壊的な変更点

<SourcePR number="11976" title="glob を使用してレガシーコレクションを実装する(EN)" />

デフォルトでは、古い `type` プロパティ (`content` または `data`) を使用し、`loader` を定義しないコレクションは、コンテンツレイヤー API の組み込み `glob()` ローダーを使用して内部で実装され、追加の下位互換性処理が行われます。

さらに、コンテンツ構成ファイルを元の場所である `src/content/config.ts` に保持するための一時的な下位互換性が存在します。

この下位互換性の実装は、レガシーコレクションのほとんどの機能をエミュレートすることができ、多くのレガシーコレクションはコードを更新しなくても動作し続けることができます。ただし、**いくつかの違いや制限があるため、既存のコレクションに変更を加える可能性があります。**

  - 以前のバージョンの Astro では、`src/content/config.ts` が定義されていない場合でも、`src/content/` のすべてのフォルダーのコレクションが生成されていました。この動作は非推奨になり、コレクションでは常に `src/content/config.ts` を定義する必要があります。既存のコレクションについては、これらを空の宣言（例えば、`const blog = defineCollection({})`）にするだけで、Astroが暗黙的に新しい読み込み動作と互換性のある方法で、レガシーコレクションを定義してくれます。
  - Markdown コレクションエントリでは、特別な `layout` フィールドはサポートされていません。このプロパティは、`src/pages/` にあるスタンドアロンページファイルのみを対象としており、コレクションエントリには含まれていない可能性があります。ただし、このプロパティを使用していた場合は、ページスタイルを含む動的ルートを作成する必要があります。
  - 生成されたコレクションのソート順序は非決定的でプラットフォームに依存します。これは、`getCollection()` を呼び出すと、エントリが返される順序が以前と異なる場合があることを意味します。特定の順序が必要な場合は、コレクションエントリを自分でソートする必要があります。
  - `image().refine()` はサポートされていません。画像のプロパティを検証する必要がある場合は、ページまたはコンポーネントでの実行時に行う必要があります。
  - `getEntry(collection, key)` の `key` 引数は、すべてのエントリの型を持つのではなく、`string` として型指定されます。
  - 以前は、静的文字列をキーとして `getEntry(collection, key)` を呼び出すと、戻り値の型が `null` にはなりませんでした。型に `undefined` が含まれるようになったので、結果を使用する前にエントリーが定義されているかどうかをチェックしなければいけません。

##### `legacy.collections` フラグの有効化

<SourcePR number="11976" title="glob を使用してレガシーコレクションを実装する(EN)" />

既存のコレクションをまだ更新する準備ができていない場合は、[`legacy.collections`](/ja/reference/legacy-flags/) フラグを有効にすることで、以前と同じように機能し続けます。

## 非推奨の機能

以下の非推奨の機能はサポートされなくなり、ドキュメント化もされなくなりました。それに応じてプロジェクトを更新してください。

非推奨の機能の中には、完全に削除されるまで一時的に機能し続けるものがあります。また、何の効果もなかったり、コードを更新するよう促すエラーを返す場合もあります。

### 非推奨: `Astro.glob()`

<SourcePR number="11826" title="glob を非推奨にする(EN)"/>

Astro v4.x では、`.astro` コンポーネントで `Astro.glob()` を使用して、プロジェクト内の複数のファイルを照会できました。これにはいくつかの制限(使用可能な場所、パフォーマンスなど)があり、コンテンツコレクション APIからのクエリ関数やVite独自の `import.meta.glob()` を使用することで、より多くの機能と柔軟性が提供されました。

Astro 5.0 では、`Astro.glob()` が非推奨になり、 `getCollection()` を使用してコレクションを照会し、 `import.meta.glob()` を使用してプロジェクト内の他のソース・ファイルを照会するようになりました。

#### どうすればいいですか？

`Astro.glob()` の使用をすべて `import.meta.glob()` に置き換えます。`import.meta.glob()` は `Promise` を返さなくなったため、それに応じてコードを更新する必要がある場合があります。[glob パターン](/ja/guides/imports/#glob-patterns) を更新する必要はありません。

```astro title="src/pages/blog.astro" del={2} ins={3}
---
const posts = await Astro.glob('./posts/*.md');
const posts = Object.values(import.meta.glob('./posts/*.md', { eager: true }));
---

{posts.map((post) => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}
```

該当する場合は、[コンテンツコレクション](/ja/guides/content-collections/) を使用してコンテンツの整理を検討してください。これには、より新しく、よりパフォーマンスの高い独自のクエリ関数があります。

[`fast-glob`]([https://www.npmjs.com/package/fast-glob](https://www.npmjs.com/package/fast-glob)) などの NPM の glob パッケージを使用することもできます。

<ReadMore>`import.meta.glob` を使用した [ファイルのインポート](/ja/guides/imports/#importmetaglob) について詳しく学びましょう。</ReadMore>
 
### 非推奨: `functionPerRoute` (アダプター API)

<SourcePR number="11714" title="functionPerRoute オプションを削除する(EN)"/>

Astro v4.xでは、プロジェクトで定義されたルートごとに別々のファイルを作成し、ビルドフォルダーの `src/pages/` ディレクトリをミラーリングすることを選択できました。デフォルトでは、Astroは1つの `entry.mjs` ファイルを生成し、各リクエストでレンダリングされたページを生成する役割を担っていました。

Astro v5.0 では、オプトアウトする動作が標準搭載されたため、オプションから削除されました。設定はできません。

`adapterFeatures` 構成から `functionPerRoute` プロパティを削除します。これは使用できなくなりました。

```js title="my-adapter.mjs" del={10}
export default function createIntegration() {
  return {
    name: '@matthewp/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@matthewp/my-adapter',
          serverEntrypoint: '@matthewp/my-adapter/server.js',
          adapterFeatures: {
              functionPerRoute: true
          }
        });
      },
    },
  };
}

```

<ReadMore>アダプターインテグレーションを構築するための [アダプター API](/ja/reference/adapter-reference/) について詳しく学びましょう。</ReadMore>

### 非推奨: `astro:build:done` フックの `routes` (インテグレーション API)

<SourcePR number="12329" title="feat(next): astro:routes:resolved"/>

Astro v4.x では、インテグレーションは `astro:build:done` フックからルートにアクセスしていました。

Astro v5.0 では、このフックに渡される `routes` 配列は非推奨にされました。このフックは `astro:config:done` の前に実行され、開発中にルートが変更されるたびに新しい `astro:routes:resolved` フックを実行し公開します。非推奨の `routes` リストと同じプロパティを持ちますが、ビルド時にのみ利用できる `distURL` を除きます。

#### どうすればいいですか？

`astro:build:done` に渡される `routes` のインスタンスを削除し、新しい `astro:routes:resolved` フックに置き換えます。新しく公開された `assets` マップで `distURL` にアクセスします。

```js title="my-integration.mjs" ins={2,6-8,11,13-18} del={10}
const integration = () => {
    let routes
    return {
        name: 'my-integration',
        hooks: {
            'astro:routes:resolved': (params) => {
                routes = params.routes
            },
            'astro:build:done': ({
                routes
                assets
            }) => {
                for (const route of routes) {
                    const distURL = assets.get(route.pattern)
                    if (distURL) {
                        Object.assign(route, { distURL })
                    }
                }
                console.log(routes)
            }
        }
    }
}
```

<ReadMore>インテグレーションを構築するための [インテグレーション API の `astro:routes:resolved` フック](/ja/reference/integrations-reference/#astroroutesresolved) について詳しく学びましょう。</ReadMore>

## Removed

The following features have now been entirely removed from the code base and can no longer be used. Some of these features may have continued to work in your project even after deprecation. Others may have silently had no effect.

Projects now containing these removed features will be unable to build, and there will no longer be any supporting documentation prompting you to remove these features.

### Removed: The Lit integration

<SourcePR number="11680" title="Remove `@astrojs/lit`"/>

In Astro v4.x, [Lit](https://lit.dev/) was a core-maintained framework library through the `@astrojs/lit` package.

Astro v5.0 removes the integration and it will not receive further updates for compatibility with 5.x and above.


#### どうすればいいですか？

You can continue to use Lit for client components by adding a client-side script tag. For example:

```astro
<script>
  import "../components/MyTabs";
</script>

<my-tabs title="These are my tabs">...</my-tabs>
```

If you're interested in maintaining a Lit integration yourself, you may wish to use the [last published version of `@astrojs/lit`](https://github.com/withastro/astro/tree/astro%404.13.0/packages/integrations/lit) as a starting point and upgrade the relevant packages.

<ReadMore>Learn more about [Astro's official integrations](/en/guides/integrations-guide/).</ReadMore>

### Removed: `hybrid` rendering mode

<SourcePR number="11824" title="Merge output:hybrid and output:static" />

In Astro v4.x, Astro provided three rendering `output` rendering modes: `'static'`, `'hybrid'`, and `'server'`

Astro v5.0 merges the `output: 'hybrid'` and `output: 'static'` configurations into one single configuration (now called `'static'`) that works the same way as the previous hybrid option.

It is no longer necessary to specify `output: 'hybrid'` in your Astro config to use server-rendered pages. The new `output: 'static'` has this capability included.

Astro will now automatically allow you to opt out of prerendering in your static site with no change to your output configuration required. Any page route or endpoint can include `export const prerender = false` to be server-rendered on demand, while the rest of your site is statically generated.

#### どうすればいいですか？

If your project used hybrid rendering, you must now remove the `output: 'hybrid'` option from your Astro config as it no longer exists. However, no other changes to your project are required, and you should have no breaking changes. The previous `'hybrid'` behavior is now the default, under a new name `'static'`.

```js title="astro.config.mjs" del={4}
import { defineConfig } from "astro/config";

export default defineConfig({
  output: 'hybrid',
});
```

If you were using the `output: 'static'` (default) option, you can continue to use it as before. By default, all of your pages will continue to be prerendered and you will have a completely static site. You should have no breaking changes to your project.

An adapter is still required to deploy an Astro project with any server-rendered pages, no matter which `output` mode your project uses. Failure to include an adapter will result in a warning in development and an error at build time.

<ReadMore>Learn more about [on-demand rendering in Astro](/en/guides/on-demand-rendering/).</ReadMore>

### Removed: Squoosh image service

<SourcePR number="11770" title="remove the squoosh image service"/>

In Astro 4.x, you could configure `image.service: squooshImageService()` to use Squoosh to transform your images instead of Sharp. However, the underlying library `libsquoosh` is no longer maintained and has memory and performance issues.

Astro 5.0 removes the Squoosh image optimization service entirely.

#### どうすればいいですか？

To switch to the built-in Sharp image service, remove the `squooshImageService` import from your Astro config. By default, you will use Sharp for `astro:assets`.

```ts title="astro.config.mjs" del={1, 5-7}
import { squooshImageService } from "astro/config";
import { defineConfig } from "astro/config";

export default defineConfig({
 image: {
   service: squooshImageService()
 }
});
```

If you are using a strict package manager like `pnpm`, you may need to install the `sharp` package manually to use the Sharp image service, even though it is built into Astro by default.

If your adapter does not support Astro's built-in Sharp image optimization, you can [configure a no-op image service](/en/guides/images/#configure-no-op-passthrough-service) to allow you to use the `<Image />` and `<Picture />` components.

Alternatively, you may wish to consider [a community-maintained Squoosh image service](https://github.com/Princesseuh/astro-image-service-squoosh) if you are unable to use the Sharp image service.

##### For adapters

If your adapter previously precised its compatibility status with Squoosh, you should now remove this information from your adapter configuration.

```js title="my-adapter.mjs" del={2-4}
supportedAstroFeatures: {
  assets: {
    isSquooshCompatible: true
  }
}
```

<ReadMore>Read more about [configuring your default image service](/en/guides/images/#default-image-service).</ReadMore>

### Removed: some public-facing types

<SourcePR number="11715" title="Refactor/types"/>

In Astro v4.x, `@types/astro.ts` exposed all types publicly to users, whether or not they were still actively used or only intended for internal use.

Astro v5.0 refactors this file to remove outdated and internal types. This refactor brings improvements to your editor (e.g. faster completions, lower memory usage, and more relevant completion options). However, this refactor may cause errors in some projects that have been relying on types that are no longer available to the public.

#### どうすればいいですか？

Remove any types that now cause errors in your project as you no longer have access to them. These are mostly APIs that have previously been deprecated and removed, but may also include types that are now internal.

<ReadMore>See the [public types exposed for use](https://github.com/withastro/astro/tree/main/packages/astro/src/types/public).</ReadMore>

### Experimental Flags

The following experimental flags have been removed in Astro v5.0 and these features are available for use:

- `env`
- `serverIslands`


Additionally, the following experimental flags have been removed and **are now the default or recommended behavior in Astro v5.0**.

- `directRenderScript` (See below for breaking changes to [default `<script>` behavior](#script-tags-are-rendered-directly-as-declared).)
- `globalRoutePriority` (See below for breaking changes to [default route priority order](#route-priority-order-for-injected-routes-and-redirects).)
- `contentLayer` (See guidance for [upgrading existing content collections](#legacy-v20-content-collections-api) to the new, preferred Content Layer API.)

The following experimental flags have been removed and **their corresponding features are not part of Astro v5.0**.

- `contentCollectionsCache`

Remove these experimental flags if you were previously using them, and move your `env` configuration to the root of your Astro config:

```js del={5-12} ins={14-16} title="astro.config.mjs"
import { defineConfig } from 'astro/config';

export default defineConfig({
  experimental: {
    directRenderScript: true,
    globalRoutePriority: true,
    contentLayer: true,
    serverIslands: true,
    contentCollectionsCache: true,
    env: {
      schema: {...}
    }
  },
  env: {
      schema: {...}
  }
})
```

These features are all available by default in Astro v5.0.

<ReadMore>Read about these exciting features and more in [the v5.0 Blog post](https://astro.build/blog/astro-5/).</ReadMore>

## Changed Defaults

Some default behavior has changed in Astro v5.0 and your project code may need updating to account for these changes.

In most cases, the only action needed is to review your existing project's deployment and ensure that it continues to function as you expect, making updates to your code as necessary. In some cases, there may be a configuration setting to allow you to continue to use the previous default behavior.

### CSRF protection is now set by default

<SourcePR number="11788" title="change default value of checkOrigin"/>

In Astro v4.x, The default value of `security.checkOrigin` was `false`. Previously, you had to explicitly set this value to `true` to enable Cross-Site Request Forgery (CSRF) protection.

Astro v5.0 changes the default value of this option to `true`, and will automatically check that the "origin" header matches the URL sent by each request in on-demand rendered pages.

#### どうすればいいですか？

If you had previously configured `security.checkOrigin: true`, you no longer need this line in your Astro config. This is now the default.

To disable this behavior, you must explicitly set  `security.checkOrigin: false`.

```js title="astro.config.mjs" ins={3-5}
export default defineConfig({
  output: "server",
  security: {
    checkOrigin: false
  }
})
```

<ReadMore>Read more about [security configuration options](/en/reference/configuration-reference/#security)</ReadMore>

### Route priority order for injected routes and redirects

<SourcePR number="11798" title="Remove legacy route prioritization"/>

In Astro v4.x, `experimental.globalRoutePriority` was an optional flag that ensured that injected routes, file-based routes, and redirects were all prioritized using the [route priority order rules for all routes](/en/guides/routing/#route-priority-order). This allowed more control over routing in your project by not automatically prioritizing certain kinds of routes and standardizing the route priority order.

Astro v5.0 removes this experimental flag and makes this the new default behavior in Astro: redirects and injected routes are now prioritized equally alongside file-based project routes.

Note that this was already the default behavior in Starlight, and should not affect updated Starlight projects.

#### どうすればいいですか？

If your project includes injected routes or redirects, please check that your routes are building page URLs as expected. An example of the new expected behavior is shown below.

In a project containing the following routes:

- File-based route: `/blog/post/[pid]`
- File-based route: `/[page]`
- Injected route: `/blog/[...slug]`
- Redirect: `/blog/tags/[tag] -> /[tag]`
- Redirect: `/posts -> /blog`

The following URLs will be built (instead of following the route priority order of Astro v4.x):

- `/blog/tags/astro` is built by the redirect to `/tags/[tag]` (instead of the injected route `/blog/[...slug]`)
- `/blog/post/0` is built by the file-based route `/blog/post/[pid]` (instead of the injected route `/blog/[...slug]`)
- `/posts` is built by the redirect to `/blog` (instead of the file-based route `/[page]`)

In the event of route collisions, where two routes of equal route priority attempt to build the same URL, Astro will log a warning identifying the conflicting routes.

<ReadMore>Read more about the [route priority order rules](/en/guides/routing/#route-priority-order).</ReadMore>

### `<script>` tags are rendered directly as declared

<SourcePR number="11791" title="Make directRenderScript the default"/>

In Astro v4.x, `experimental.directRenderScript` was an optional flag to directly render `<scripts>` as declared in `.astro` files (including existing features like TypeScript, importing `node_modules`, and deduplicating scripts). This strategy prevented scripts from being executed in places where they were not used. Additionally, conditionally rendered scripts were previously implicitly inlined, as if an `is:inline` directive was automatically added to them.

Astro 5.0 removes this experimental flag and makes this the new default behavior in Astro: scripts are no longer hoisted to the `<head>`, multiple scripts on a page are no longer bundled together, and a `<script>` tag may interfere with CSS styling. Additionally, conditionally rendered scripts are no longer implicitly inlined.

#### どうすればいいですか？

Please review your `<script>` tags and ensure they behave as desired.

If you previously had conditionally rendered `<script>` tags, you will need to add an `is:inline` attribute to preserve the same behavior as before:

```astro title="src/components/MyComponent.astro" ins="is:inline"
---
type Props = {
  showAlert: boolean
}

const { showAlert } = Astro.props;
---
{
  showAlert && <script is:inline>alert("Some very important code!!")</script>
}
```

<ReadMore>Read more about [using `script` tags in Astro](/en/guides/client-side-scripts/#using-script-in-astro).</ReadMore>

## Breaking Changes

The following changes are considered breaking changes in Astro v5.0. Breaking changes may or may not provide temporary backwards compatibility. If you were using these features, you may have to update your code as recommended in each entry.

{/* If you need to refer to the documentation for a v4.x project, you can browse this [(unmaintained) snapshot of the docs from before v5.0 was released](https://docs-git-v3-docs-unmaintained-astrodotbuild.vercel.app/). */}

### Renamed: `<ViewTransitions />` component

<SourcePR number="11980" title="Rename the ViewTransitions component to ClientRouter"/>

In Astro 4.x, Astro's View Transitions API included a `<ViewTransitions />` router component to enable client-side routing, page transitions, and more.

Astro 5.0 renames this component to `<ClientRouter />` to clarify the role of the component within the API. This makes it more clear that the features you get from Astro's `<ClientRouter />` routing component are slightly different from the native CSS-based MPA router.

No functionality has changed. This component has only changed its name.

#### どうすればいいですか？

Replace all occurences of the `ViewTransitions` import and component with `ClientRouter`:

```astro title="src/layouts/MyLayout.astro" del={1,7} ins={2,8}
import { ViewTransitions } from 'astro:transitions';
import { ClientRouter } from 'astro:transitions';

<html>
  <head>
    ...
   <ViewTransitions />
   <ClientRouter />
  </head>
</html>
```

<ReadMore>Read more about [view transitions and client-side routing in Astro](/en/guides/view-transitions/).</ReadMore>


### Changed: TypeScript configuration

<SourcePR number="11859" title="better tsconfig"/>

In Astro v4.x, Astro relied on a `src/env.d.ts` file for type inferencing and defining modules for features that relied on generated types.

Astro 5.0 instead uses a `.astro/types.d.ts` file for type inferencing, and now recommends setting `include` and `exclude` in `tsconfig.json` to benefit from Astro types and avoid checking built files.

Running `astro sync` no longer creates, nor updates, `src/env.d.ts` as it is not required for type-checking standard Astro projects.

#### どうすればいいですか？

To update your project to Astro's recommended TypeScript settings, add the following `include` and `exclude` properties to your existing `tsconfig.json`:

```ts ins={3,4} title="tsconfig.json"
{
  "extends": "astro/tsconfigs/base",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"]
}
```

Note that `src/env.d.ts` is only necessary if you have added custom configurations, or if you're not using a `tsconfig.json` file.

<ReadMore>Read more about [TypeScript configuration in Astro](/en/guides/typescript/#setup).</ReadMore>

### Changed: Actions submitted by HTML forms no longer use cookie redirects

<SourcePR number="12373" title="Actions middleware"/>

In Astro 4.x, actions called from an HTML form would trigger a redirect with the result forwarded using cookies. This caused issues for large form errors and return values that exceeded the 4 KB limit of cookie-based storage.

Astro 5.0 now renders the result of an action as a POST result without any forwarding. This will introduce a "confirm form resubmission?" dialog when a user attempts to refresh the page, though it no longer imposes a 4 KB limit on action return value.

#### どうすればいいですか？

You should update handling for action results that relies on redirects, and optionally address the "confirm form resubmission?" dialog with middleware.

##### To redirect to the previous route on error

If your HTML form action is directed to a different route (i.e. `action={"/success-page" + actions.name}`), Astro will no longer redirect to the previous route on error. You can implement this behavior manually using redirects from your Astro component. This example instead redirects to a new route on success, and handles errors on the current page otherwise:

```astro title="src/pages/newsletter.astro" ins={4-9} del="'/confirmation' + "
---
import { actions } from 'astro:actions';

const result = Astro.getActionResult(actions.newsletter);
if (!result?.error) {
  // Embed relevant result data in the URL if needed
  // example: redirect(`/confirmation?email=${result.data.email}`);
  return redirect('/confirmation');
}
---

<form method="POST" action={'/confirmation' + actions.newsletter}>
  <label>E-mail <input required type="email" name="email" /></label>
  <button>Sign up</button>
</form>
```

##### (Optional) To remove the confirm dialog on refresh

To address the "confirm form resubmission?" dialog on refresh, or to preserve action results across sessions, you can now [customize action result handling from middleware](/en/guides/actions/#advanced-persist-action-results-with-a-session).

We recommend using a session storage provider [as described in our Netlify Blob example](/en/guides/actions/#advanced-persist-action-results-with-a-session). However, if you prefer the cookie forwarding behavior from 4.X and accept the 4 KB size limit, you can implement the pattern as shown in this sample snippet:

```ts title="src/middleware.ts"
import { defineMiddleware } from 'astro:middleware';
import { getActionContext } from 'astro:actions';

export const onRequest = defineMiddleware(async (context, next) => {
  // Skip requests for prerendered pages
  if (context.isPrerendered) return next();

	const { action, setActionResult, serializeActionResult } = getActionContext(context);

	// If an action result was forwarded as a cookie, set the result
	// to be accessible from `Astro.getActionResult()`
	const payload = context.cookies.get('ACTION_PAYLOAD');
	if (payload) {
		const { actionName, actionResult } = payload.json();
		setActionResult(actionName, actionResult);
		context.cookies.delete('ACTION_PAYLOAD');
		return next();
	}

	// If an action was called from an HTML form action,
	// call the action handler and redirect with the result as a cookie.
	if (action?.calledFrom === 'form') {
		const actionResult = await action.handler();

		context.cookies.set('ACTION_PAYLOAD', {
			actionName: action.name,
			actionResult: serializeActionResult(actionResult),
		});

		if (actionResult.error) {
		// Redirect back to the previous page on error
			const referer = context.request.headers.get('Referer');
			if (!referer) {
				throw new Error('Internal: Referer unexpectedly missing from Action POST request.');
			}
			return context.redirect(referer);
		}
		// Redirect to the destination page on success
		return context.redirect(context.originPathname);
	}

	return next();
})
```

### Changed: `compiledContent()` is now an async function

<SourcePR number="11782" title="Remove TLA by making compiledContent async"/>

In Astro 4.x, top level await was included in Markdown modules. This caused some issues with custom image services and images inside Markdown, causing Node to suddenly exit with no error message.

Astro 5.0 makes the `compiledContent()` property on Markdown import an async function, requiring an `await` to resolve the content.

#### どうすればいいですか？

Update your code to use `await` when calling `compiledContent()`.

```astro title="src/pages/post.astro" del={4} ins={5}
---
import * as myPost from "../blog/post.md";

const content = myPost.compiledContent();
const content = await myPost.compiledContent();
---

<Fragment set:html={content} />
```

<ReadMore>Read more about the [`compiledContent()` function](/en/guides/markdown-content/#importing-markdown) for returning compiled Markdown.</ReadMore>

### Changed: `astro:content` can no longer be used on the client

<SourcePR number="11827" title="Prevent usage of `astro:content` in the client "/>

In Astro 4.x, it was possible to access the `astro:content` module on the client.

Astro 5.0 removes this access as it was never intentionally exposed for client use. Using `astro:content` this way had limitations and bloated client bundles.

#### どうすればいいですか？

If you are currently using `astro:content` in the client, pass the data you need through props to your client components instead:

```astro title="src/pages/blog.astro"
---
import { getCollection } from 'astro:content';
import ClientComponent from '../components/ClientComponent';

const posts = await getCollection('blog');
const postsData = posts.map(post => post.data);
---

<ClientComponent posts={postsData} />
```

<ReadMore>Read more about [the `astro:content` API](/en/reference/modules/astro-content/).</ReadMore>

### Renamed: Shiki `css-variables` theme color token names

<SourcePR number="11661" title="Update to new shiki token names"/>

In Astro v4.x, the Shiki `css-variables` theme used the `--astro-code-color-text` and `--astro-code-color-background` tokens for styling the foreground and background colors of code blocks respectively.

Astro v5.0 renames them to `--astro-code-foreground` and `--astro-code-background` respectively to better align with the Shiki v1 defaults.

#### どうすればいいですか？

You can perform a global find and replace in your project to migrate to the new token names.

```css title="src/styles/global.css" del={2,3} ins={4,5}
:root {
  --astro-code-color-text: #000;
  --astro-code-color-background: #fff;
  --astro-code-foreground: #000;
  --astro-code-background: #fff;
}
```

<ReadMore>Read more about [syntax highlighting in Astro](/en/guides/syntax-highlighting/).</ReadMore>

### Changed: internal Shiki rehype plugin for highlighting code blocks

<SourcePR number="11825" title="Refactor createShikiHighlighter"/>

In Astro 4.x, Astro's internal Shiki rehype plugin highlighted code blocks as HTML.

Astro 5.0 updates this plugin to highlight code blocks as hast. This allows a more direct Markdown and MDX processing and improves the performance when building the project. However, this may cause issues with existing Shiki transformers.

#### どうすればいいですか？

If you are using Shiki transformers passed to `markdown.shikiConfig.transformers`, you must make sure they do not use the `postprocess` hook. This hook no longer runs on code blocks in `.md` and `.mdx` files. (See [the Shiki documentation on transformer hooks](https://shiki.style/guide/transformers#transformer-hooks) for more information).

Code blocks in `.mdoc` files and Astro's built-in `<Code />` component do not use the internal Shiki rehype plugin and are unaffected.

<ReadMore>Read more about [syntax highlighting in Astro](/en/guides/syntax-highlighting/).</ReadMore>

### Changed: Automatic `charset=utf-8` behavior for Markdown and MDX pages

<SourcePR number="12231" title="Unset charset=utf-8 content-type for md/mdx pages"/>

In Astro 4.0, Markdown and MDX pages (located in `src/pages/`) automatically responded with `charset=utf-8` in the `Content-Type` header, which allowed rendering non-ASCII characters in your pages.

Astro 5.0 updates the behaviour to add the `<meta charset="utf-8">` tag instead, and only for pages that do not use Astro's special `layout` frontmatter property. Similarly for MDX pages, Astro will only add the tag if the MDX content does not import a wrapping `Layout` component.

If your Markdown or MDX pages use the `layout` frontmatter property, or if the MDX page content imports a wrapping `Layout` component, then the HTML encoding will be handled by the designated layout component instead, and the `<meta charset="utf-8">` tag will not be added to your page by default.

#### どうすればいいですか？

If you require `charset=utf-8` to render your page correctly, make sure that your layout components contain the `<meta charset="utf-8">` tag. You may need to add this if you have not already done so.

<ReadMore>Read more about [Markdown layouts](/en/basics/layouts/#markdown-layouts).</ReadMore>

### Changed: Astro-specific metadata attached in remark and rehype plugins

<SourcePR number="11861" title="Clean up Astro metadata in vfile.data"/>

In Astro 4.x, the Astro-specific metadata attached to `vfile.data` in remark and rehype plugins was attached in different locations with inconsistent names.

Astro 5 cleans up the API and the metadata is now renamed as below:

 - `vfile.data.__astroHeadings` -> `vfile.data.astro.headings`
 - `vfile.data.imagePaths` -> `vfile.data.astro.imagePaths`

The types of `imagePaths` has also been updated from `Set<string>` to `string[]`. The `vfile.data.astro.frontmatter` metadata is left unchanged.

#### どうすればいいですか？

While we don't consider these APIs public, they can be accessed by remark and rehype plugins that want to re-use Astro's metadata. If you are using these APIs, make sure to access them in the new locations.

<ReadMore>Read more about [using Markdown plugins in Astro](/en/guides/markdown-content/#markdown-plugins).</ReadMore>

### Changed: image endpoint configuration

<SourcePR number="11908" title="Allow customising the route of the image endpoint"/>

In Astro 4.x, you could set an endpoint in your `image` configuration to use for image optimization.

Astro 5.0 allows you to customize a `route` and `entrypoint` of the `image.endpoint` config. This can be useful in niche situations where the default route `/_image` conflicts with an existing route or your local server setup.

#### どうすればいいですか？

If you had previously customized `image.endpoint`, move this endpoint to the new `endpoint.entrypoint` property. Optionally, you may customize a `route`:

```js title="astro.config.mjs" del={5} ins={6-9}
import { defineConfig } from "astro/config";

defineConfig({
  image: {
    endpoint: './src/image-endpoint.ts',
    endpoint: {
      route: "/image",
      entrypoint: "./src/image_endpoint.ts"
    }
  },
})
```

<ReadMore>Read more about [setting an endpoint to use for image optimization](/en/reference/configuration-reference/#imageendpoint).</ReadMore>

### Changed: `build.client` and `build.server` resolve behavior

<SourcePR number="11916" title="Fix build.client and build.server resolve behaviour" />

In Astro v4.x, the `build.client` and `build.server` options were documented to resolve relatively from the `outDir` option, but it didn't always work as expected.

Astro 5.0 fixes the behavior to correctly resolve from the `outDir` option. For example, if `outDir` is set to `./dist/nested/`, then by default:

- `build.client` will resolve to `<root>/dist/nested/client/`
- `build.server` will resolve to `<root>/dist/nested/server/`

Previously the values were incorrectly resolved:

- `build.client` was resolved to `<root>/dist/nested/dist/client/`
- `build.server` was resolved to `<root>/dist/nested/dist/server/`

#### どうすればいいですか？

If you were relying on the previous build paths, make sure that your project code is updated to the new build paths.

<ReadMore>Read more about [`build` configuration options in Astro](/en/reference/configuration-reference/#build-options).</ReadMore>

### Changed: JS dependencies in config file are no longer processed by Vite

<SourcePR number="11819" title="Set external: true when loading astro config"/>

In Astro 4.x, locally-linked JS dependencies (e.g. `npm link`, in a monorepo, etc) were able to use Vite features like `import.meta.glob` when imported by the Astro config file.

Astro 5 updates the Astro config loading flow to ignore processing locally-linked JS dependencies with Vite. Dependencies exporting raw TypeScript files are unaffected. Instead, these JS dependencies will be normally imported by the Node.js runtime the same way as other dependencies from `node_modules`.

This change was made as the previous behavior caused confusion among integration authors who tested against a package that worked locally, but not when published. It also restricted using CJS-only dependencies because Vite required the code to be ESM. While this change only affects JS dependencies, it's also recommended for packages to export JavaScript instead of raw TypeScript where possible to prevent accidental Vite-specific usage as it's an implementation detail of Astro's config loading flow.

#### どうすればいいですか？

Make sure your locally-linked JS dependencies are built before running your Astro project. Then, the config loading should work as before.

<ReadMore>Read more about [Vite configuration settings in Astro](/en/reference/configuration-reference/#vite).</ReadMore>

### Changed: URLs returned by `paginate()`

<SourcePR number="11253" title="Add base to paginate"/>

In Astro v4.x, the URL returned by `paginate()` (e.g. `page.url.next`, `page.url.first`, etc.) did not include the value set for `base` in your Astro config. You had to manually prepend your configured value for `base` to the URL path.

Astro 5.0 automatically includes the `base` value in `page.url`.

#### どうすればいいですか？

If you are using the `paginate()` function for these URLs, remove any existing `base` value as it is now added for you:

```astro del={16} ins={17}
---
export async function getStaticPaths({ paginate }) {
  const astronautPages = [{
    astronaut: 'Neil Armstrong',
  }, {
    astronaut: 'Buzz Aldrin',
  }, {
    astronaut: 'Sally Ride',
  }, {
    astronaut: 'John Glenn',
  }];
  return paginate(astronautPages, { pageSize: 1 });
}
const { page } = Astro.props;
// `base: /'docs'` configured in `astro.config.mjs`
const prev = "/docs" + page.url.prev;
const prev = page.url.prev;
---
<a id="prev" href={prev}>Back</a>
```

<ReadMore>Read more about [pagination in Astro](/en/guides/routing/#pagination).</ReadMore>

### Changed: non-boolean HTML attribute values

<SourcePR number="11660" title="Fix attribute rendering for boolean values (take 2)"/>

In Astro v4.x, non-[boolean HTML attributes](https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML) may not have included their values when rendered to HTML.

Astro v5.0 renders the values explicitly as `="true"` or `="false"`, matching proper attribute handling in browsers.

In the following `.astro` examples, only `allowfullscreen` is a boolean attribute:

```astro
<!-- src/pages/index.astro -->
<!-- `allowfullscreen` is a boolean attribute -->
<p allowfullscreen={true}></p>
<p allowfullscreen={false}></p>
<!-- `inherit` is *not* a boolean attribute -->
<p inherit={true}></p>
<p inherit={false}></p>
<!-- `data-*` attributes are not boolean attributes -->
<p data-light={true}></p>
<p data-light={false}></p>
```

Astro v5.0 now preserves the full data attribute with its value when rendering the HTML of non-boolean attributes:

```astro del={5,8,10} ins={6,9,11}
<p allowfullscreen></p>
<p></p>

<p inherit="true"></p>
<p inherit></p>
<p inherit="false"></p>

<p data-light></p>
<p data-light="true"></p>
<p></p>
<p data-light="false"></p>
```

#### どうすればいいですか？

If you rely on attribute values, for example, to locate elements or to conditionally render, update your code to match the new non-boolean attribute values:

```js del={1,4} ins={2,5}
el.getAttribute('inherit') === ''
el.getAttribute('inherit') === 'false'

el.hasAttribute('data-light')
el.dataset.light === 'true'
```

<ReadMore>Read more about [using HTML attributes in Astro](/en/reference/astro-syntax/#dynamic-attributes).</ReadMore>

### Changed: adding values to `context.locals`

<SourcePR number="11987" title="TODOs"/>

In Astro 4.x, it was possible to completely replace the entire `locals` object in middleware, API endpoints, and pages when adding new values.

Astro 5.0 requires you to append values to the existing `locals` object without deleting it. Locals in middleware, API endpoints, and pages, can no longer be completely overridden.

#### どうすればいいですか？

Where you previously were overwriting the object, you must now instead assign values to it:

```js title="src/middleware.js" del={1,5} ins={2,6}
ctx.locals = {
Object.assign(ctx.locals, {
  one: 1,
  two: 2
}
})
```

<ReadMore>See more about [storing data in `context.locals`](/en/guides/middleware/#storing-data-in-contextlocals).</ReadMore>

### Changed: `params` no longer decoded

<SourcePR number="12079" title="decode pathname early, don't decode params"/>

In Astro v4.x, `params` passed to `getStaticPath()` were automatically decoded using `decodeURIComponent`.

Astro v5.0 no longer decodes the value of `params` passed to `getStaticPaths`. You must manually decode them yourself if needed.

#### どうすればいいですか？

If you were previously relying on the automatic decoding, use `decodeURI` when passing `params`.


```astro title="src/pages/[id].astro" del={4} ins={5}
---
export function getStaticPaths() {
  return [
    { params: { id: "%5Bpage%5D" } },
    { params: { id: decodeURI("%5Bpage%5D") } },
  ]
}

const { id } = Astro.params;
---
```

Note that the use of [`decodeURIComponent`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent) is discouraged for `getStaticPaths` because it decodes more characters than it should, for example `/`, `?`, `#` and more.

<ReadMore>Read more about [creating dynamic routes with `params`](/en/guides/routing/#static-ssg-mode).</ReadMore>

### Changed: `RouteData` type replaced by `IntegrationsRouteData` (Integrations API)

<SourcePR number="11864" title="send `IntegrationRouteData` to integrations"/>

In Astro v4.x, the `entryPoints` type inside the `astro:build:ssr` and `astro:build:done` hooks was `RouteData`.

Astro v5.0 the `entryPoints` type is now `IntegrationRouteData`, which contains a subset of the `RouteData` type. The fields `isIndex` and `fallbackRoutes` were removed.

#### どうすればいいですか？

Update your adapter to change the type of `entryPoints` from `RouteData` to `IntegrationRouteData`.

```js del={1,4} ins={2,5}
import type {RouteData} from 'astro';
import type {IntegrationRouteData} from "astro"

function useRoute(route: RouteData) {
function useRoute(route: IntegrationRouteData) {
}
```

<ReadMore>See the [API reference for `IntegrationRouteData`](/en/reference/integrations-reference/#integrationroutedata-type-reference).</ReadMore>

### Changed: `distURL` is now an array (Integrations API)

<SourcePR number="11864" title="send `IntegrationRouteData` to integrations"/>

In Astro v4.x, `RouteData.distURL` was `undefined` or a `URL`.

Astro v5.0 updates the shape of `IntegrationRouteData.distURL` to be `undefined` or an array of `URL`s. This fixes a previous error because a route can generate multiple files on disk, especially when using dynamic routes such as `[slug]` or `[...slug]`.

#### どうすればいいですか？

Update your code to handle `IntegrationRouteData.distURL` as an array.

```js del={2-4} ins={5-9}
if (route.distURL) {
  if (route.distURL.endsWith('index.html')) {
    // do something
  }
  for (const url of route.distURL) {
    if (url.endsWith('index.html')) {
      // do something
    }
  }
}
```

<ReadMore>See the [API reference for `IntegrationRouteData`](/en/reference/integrations-reference/#integrationroutedata-type-reference).</ReadMore>

### Changed: Arguments passed to `app.render()` (Adapter API)

<SourcePR number="11987" title="TODOs"/>

In Astro 4.x, The Adapter API method `app.render()` could receive three arguments: a mandatory `request`, an object of options or a `routeData` object, and `locals`.

Astro 5.0 combines these last two arguments into a single options argument named `renderOptions`.

#### どうすればいいですか？

Pass an object as the second argument to `app.render()`, which can include `routeData` and `locals` as properties.

```js del={1} ins={2}
const response = await app.render(request, routeData, locals);
const response = await app.render(request, {routeData, locals});
```

<ReadMore>See the [Adapter API reference for `renderOptions`](/en/reference/adapter-reference/#renderoptions).</ReadMore>

### Changed: Properties on `supportedAstroFeatures` (Adapter API)

<SourcePR number="11806" title="rework supportedAstroFeatures"/>

In Astro 4.x, `supportedAstroFeatures`, which allows adapter authors to specify which features their integration supports, included an `assets` property to specify which of Astro's image services were supported.

Astro 5.0 replaces this property with a dedicated `sharpImageService` property, used to determine whether the adapter is compatible with the built-in sharp image service.

v5.0 also adds a new `limited` value for the different properties of `supportedAstroFeatures` for adapters, which indicates that the adapter is compatible with the feature, but with some limitations. This is useful for adapters that support a feature, but not in all cases or with all options.

Additionally, the value of the different properties on `supportedAstroFeatures` for adapters can now be objects, with `support` and `message` properties. The content of the `message` property will show a helpful message in the Astro CLI when the adapter is not compatible with a feature. This is notably useful with the new `limited` value, to explain to the user why support is limited.

#### どうすればいいですか？

If you were using the `assets` property, remove this as it is no longer available. To specify that your adapter supports the built-in sharp image service, replace this with `sharpImageService`.

You may also wish to update your supported features with the new `limited` option and include a message about your adapter's support.

```ts title="my-adapter.mjs" del={2-6} ins={7-10}
supportedAstroFeatures: {
  assets: {
    supportKind: "stable",
    isSharpCompatible: true,
    isSquooshCompatible: true,
  },
  sharpImageService: {
    support: "limited",
    message: 'This adapter supports the built-in sharp image service, but with some limitations.'
  }
}
```

<ReadMore>Read more about [specifying supported Astro features in an adapter](/en/reference/adapter-reference/#astro-features).</ReadMore>

### Removed: Deprecated definition shape for dev toolbar apps (Dev Toolbar API)

<SourcePR number="11987" title="Remove deprecated dev toolbar app shape"/>

In Astro 4.x, when building a dev toolbar app, it was still possible to use the previously deprecated `addDevToolbarApp(string);` signature. The `id`, `title`, and `icon` properties to define the app were then made available through the default export of the app's `entrypoint`.

Astro 5.0 completely removes this option entirely in favor of the current object shape when defining a dev toolbar app in an integration that's more intuitive and allows Astro to provide better errors when toolbar apps fail to load correctly.

#### どうすればいいですか？

If you were using the deprecated shape, update your dev toolbar app to use the new shape:

```js title="my-integration.mjs" del={1-2} ins={4-10}
// Old shape
addDevToolbarApp("./my-dev-toolbar-app.mjs");

// New shape
addDevToolbarApp({
  id: "my-app",
  name: "My App",
  icon: "<svg>...</svg>",
  entrypoint: "./my-dev-toolbar-app.mjs",
});
```

```js title="my-dev-toolbar-app.mjs" del={2-4}
export default {
  id: 'my-dev-toolbar-app',
  title: 'My Dev Toolbar App',
  icon: '🚀',
  init() {
    // ...
  }
}
```

<ReadMore>Read more about [developing a dev toolbar app for Astro using the Dev Toolbar API](/en/reference/dev-toolbar-app-reference/).</ReadMore>

### Removed: configuring Typescript during `create-astro`

<SourcePR number="12083" title="create-astro updates"/>

In Astro v4.x, it was possible to choose between Astro's three TypeScript settings when creating a new project using `create astro`, either by answering a question or by passing an associated `--typescript` flag with the desired TypeScript setting. 

Astro 5.0 updates the `create astro` CLI command to remove the TypeScript question and its associated `--typescript` flag. The "strict" preset is now the default for all new projects created with the command line and it is no longer possible to customize this at that time. However, the TypeScript template can still be changed manually in `tsconfig.json`.

#### どうすればいいですか？

If you were using the `--typescript` flag with `create-astro`, remove it from your command.

<PackageManagerTabs>
  <Fragment slot="npm">
  ```diff lang=shell
  -npm create astro@latest -- --template <example-name> --typescript strict
  +npm create astro@latest -- --template <example-name>
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```diff lang=shell
  -pnpm create astro@latest --template <example-name> --typescript strict
  +pnpm create astro@latest --template <example-name>
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```diff lang=shell
  -yarn create astro --template <example-name> --typescript strict
  +yarn create astro --template <example-name>
  ```
  </Fragment>
</PackageManagerTabs>

<ReadMore>See [all the available `create astro` command flags](https://github.com/withastro/astro/blob/main/packages/create-astro/README.md)</ReadMore>

## Community Resources

Know a good resource for Astro v5.0? [Edit this page](https://github.com/withastro/docs/edit/main/src/content/docs/en/guides/upgrade-to/v5.mdx) and add a link below!

## Known Issues

Please check [Astro's issues on GitHub](https://github.com/withastro/astro/issues/) for any reported issues, or to file an issue yourself.
