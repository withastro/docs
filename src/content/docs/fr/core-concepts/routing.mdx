---
title: Routage
description: Une introduction √† l'utilisation du routage avec Astro.
i18nReady: true
---
import FileTree from '~/components/FileTree.astro'
import RecipeLinks from "~/components/RecipeLinks.astro"
import Since from '~/components/Since.astro'

Astro utilise un **routage bas√© sur les fichiers** pour g√©n√©rer vos URLs de construction en fonctionde la disposition des fichiers dans le r√©pertoire `src/pages/` de votre projet. Lorsqu'un fichier est ajout√© au r√©pertoire `src/pages` de votre projet, il est automatiquement disponible en tant que route bas√©e sur son nom de fichier.

## Naviguer entre les pages

Astro utilise des √©l√©ments HTML standard [`<a>` elements](https://developer.mozilla.org/fr-FR/docs/Web/HTML/Element/a) pour naviguer entre les itin√©raires. Il n'y a pas de composant `<Link>` sp√©cifique au cadre de travail.

```astro title="src/pages/index.astro"
<p>En savoir plus <a href="/about/">a propos</a> d'Astro!</p>
```

## Routes Statiques

Les composants Astro (`.astro`) et les fichiers Markdown (`.md`) dans le r√©pertoire `src/pages` **deviendront automatiquement des pages de votre site web**. La route de chaque page correspond √† son chemin et √† son nom de fichier dans le r√©pertoire `src/pages`.

```diff
# Exemple: Routes Statiques
src/pages/index.astro        -> mysite.com/
src/pages/about.astro        -> mysite.com/about
src/pages/about/index.astro  -> mysite.com/about
src/pages/about/me.astro     -> mysite.com/about/me
src/pages/posts/1.md         -> mysite.com/posts/1
```

:::tip
Il n'y a pas de "configuration de routage" s√©par√©e √† maintenir dans un projet Astro ! Lorsque vous ajoutez un fichier au r√©pertoire `/src/pages`, une nouvelle route est automatiquement cr√©√©e pour vous. Dans les constructions statiques, vous pouvez personnaliser le format de sortie du fichier en utilisant l'option de configuration [`build.format`](/fr/reference/configuration-reference/#buildformat).
:::

## Routes Dynamiques

Un fichier de page Astro peut sp√©cifier des param√®tres de route dynamiques dans son nom de fichier pour g√©n√©rer des pages correspondantes. Par exemple, vous pouvez cr√©er un fichier `authors/[author].astro` qui g√©n√®re une page de biographie pour chaque auteur de votre blog. `author` devient un _param√®tre_ accessible depuis l'int√©rieur de la page.

Dans le mode statique par d√©faut d'Astro, ces pages sont g√©n√©r√©es au moment de la construction, et vous devez donc pr√©d√©terminer la liste des `author` qui obtiendront un fichier correspondant. En mode SSR, une page sera g√©n√©r√©e sur demande pour toute route correspondante.

### Mode Statique (SSG)

Parce que toutes les routes doivent √™tre d√©termin√©es au moment de la construction, une route dynamique doit exporter une fonction `getStaticPaths()` qui renvoie un tableau d'objets avec une propri√©t√© `params`. Chacun de ces objets g√©n√©rera une route correspondante.

`[dog].astro` d√©finit le param√®tre dynamique `dog` dans son nom de fichier, donc les objets retourn√©s par `getStaticPaths()` doivent inclure `dog` dans leurs `params`. La page peut alors acc√©der √† ce param√®tre en utilisant `Astro.params`.

```astro title="src/pages/dogs/[dog].astro"
---
export function getStaticPaths() {
  return [
    {params: {dog: 'clifford'}},
    {params: {dog: 'rover'}},
    {params: {dog: 'spot'}},
  ];
}

const { dog } = Astro.params;
---
<div>Bon chien, {dog} !</div>
```

Cela va g√©n√©rer trois pages : `/dogs/clifford`, `/dogs/rover`, et `/dogs/spot`, chacune affichant le nom du chien correspondant.

Le nom du fichier peut inclure plusieurs param√®tres, qui doivent tous √™tre inclus dans les objets `params` de `getStaticPaths()` :

```astro title="src/pages/[lang]-[version]/info.astro"
---
export function getStaticPaths () {
 return [
    {params: {lang: 'en', version: 'v1'}},
    {params: {lang: 'fr', version: 'v2'}},
  ];
}

const { lang, version } = Astro.params;
---
...
```

Cela va g√©n√©rer `/en-v1/info` et `/fr-v2/info`.

Les param√®tres peuvent √™tre inclus dans des parties s√©par√©es du chemin, ainsi nous pourrions utiliser `src/pages/[lang]/[version]/info.astro` avec le m√™me `getStaticPaths` pour g√©n√©rer `/en/v1/info` et `/fr/v2/info`.

üìö En savoir plus sur [`getStaticPaths()`](/fr/reference/api-reference/#getstaticpaths).

<RecipeLinks slugs={["en/recipes/i18n"]} />

### Param√®tres REST

Si vous avez besoin de plus de flexibilit√© dans le routage de vos URL, vous pouvez utiliser un [param√®tre REST](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Functions/rest_parameters) (`[...path]`) dans votre nom de fichier `.astro` pour correspondre √† des chemins de fichiers de n'importe quelle profondeur :

```astro title="src/pages/sequences/[...path].astro"
---
export function getStaticPaths() {
  return [
    {params: {path: 'one/two/three'}},
    {params: {path: 'four'}},
    {params: {path: undefined }}
  ]
}

const { path } = Astro.params;
---
...
```

Cela g√©n√©rera `/sequences/one/two/three`, `/sequences/four`, et `/sequences`. (D√©finir le param√®tre REST √† `undefined` lui permet de correspondre √† la page de premier niveau).

Les param√®tres REST peuvent √™tre utilis√©s avec **d'autres param√®tres nomm√©s**. Par exemple, nous pourrions repr√©senter la visionneuse de fichiers de GitHub avec une route dynamique comme celle-ci :

```
/[org]/[repo]/tree/[branch]/[...file]
```
Dans cet exemple, une requ√™te pour `/withastro/astro/tree/main/docs/public/favicon.svg` serait divis√©e en param√®tres nomm√©s suivants :

```js
{
	org: 'withastro',
	repo: 'astro',
	branch: 'main',
	file: 'docs/public/favicon.svg'
}
```

#### Exemple : Pages dynamiques √† plusieurs niveaux

Ici, nous utilisons un param√®tre REST (`[...slug]`) et la fonctionnalit√© [`props`](/fr/reference/api-reference/#data-passing-with-props) de `getStaticPaths()` pour g√©n√©rer des pages pour des slugs de diff√©rentes profondeurs.

```astro title="src/pages/[...slug].astro"
---
export async function getStaticPaths() {
  const pages = [
    {
      slug: undefined,
      title: "Magasin Astro",
      text: "Bienvenue dans le magasin Astro!",
    },
    {
      slug: "products",
      title: "Produits Astro",
      text: "Nous avons beaucoup de produits pour vous",
    },
    {
      slug: "products/astro-handbook",
      title: "L'ultime manuel d'Astro",
      text: "Si vous voulez apprendre Astro, vous devez lire ce livre.",
    },
  ];
  return pages.map(({ slug, title, text }) => {
    return {
      params: { slug },
      props: { title, text },
    };
  });
}

const { title, text } = Astro.props;
---
<html>
  <head>
    <title>{title}</title>
  </head>
  <body>
    <h1>{title}</h1>
    <p>{text}</p>
  </body>
</html>
```

### Mode serveur (SSR)
En [mode SSR](/fr/guides/server-side-rendering/), les routes dynamiques sont d√©finies de la m√™me mani√®re : incluez des crochets `[param]` ou `[...path]` dans vos noms de fichiers pour faire correspondre des cha√Ænes ou des chemins arbitraires. Mais comme les routes ne sont plus construites √† l'avance, la page sera servie √† toute route correspondante. Comme il ne s'agit pas de routes "statiques", `getStaticPaths` ne doit pas √™tre utilis√©.

```astro title="src/pages/resources/[resource]/[id].astro"
---
const { resource, id } = Astro.params;
---
<h1>{resource}: {id}</h1>
```
Cette page sera servie pour toute valeur de `resource` et `id` : `resources/users/1`, `resources/colors/blue`, etc.

#### Modification de l'exemple `[...slug]` pour le mode SSR

Comme les pages SSR ne peuvent pas utiliser `getStaticPaths`, elles ne peuvent pas recevoir de props. Ici, nous modifions notre [exemple pr√©c√©dent](#exemple--pages-dynamiques-√†-plusieurs-niveaux) pour qu'il fonctionne en SSR en cherchant la valeur du param√®tre `slug` dans un objet. Si la route est √† la racine ("/"), le param√®tre slug sera `undefined`. Si la valeur n'existe pas dans l'objet, nous redirigeons vers une page 404.


```astro title="src/pages/[...slug].astro"
---
const pages = [
	{
		slug: undefined,
		title: 'Magasin Astro',
		text: 'Bienvenue dans le magasin Astro !',
	},
	{
		slug: 'products',
		title: 'Produits Astro',
		text: 'Nous avons beaucoup de produits pour vous',
	},
	{
		slug: 'products/astro-handbook',
		title: "L'ultime manuel d'Astro",
		text: 'Si vous voulez apprendre Astro, vous devez lire ce livre.',
	}
];

const { slug } = Astro.params;
const page = pages.find((page) => page.slug === slug);
if (!page) return Astro.redirect("/404");
const { title, text } = page;
---
<html>
<head>
  <title>{title}</title>
</head>
<body>
  <h1>{title}</h1>
  <p>{text}</p>
</body>
</html>
```
## Redirections

Parfois, vous devrez rediriger vos lecteurs vers une nouvelle page, soit de mani√®re permanente parce que la structure de votre site a chang√©, soit en r√©ponse √† une action telle que la connexion √† une route authentifi√©e.

Vous pouvez d√©finir des r√®gles pour [rediriger les utilisateurs vers des pages d√©plac√©es de fa√ßon permanente](#redirections-configur√©es) dans votre configuration Astro. Ou [rediriger les utilisateurs dynamiquement](#redirections-dynamiques) au fur et √† mesure qu'ils utilisent votre site.

### Redirections configur√©es
<Since v="2.9.0" />

Vous pouvez sp√©cifier une correspondance de redirections permanentes dans votre configuration Astro avec la valeur `redirects`. Pour la plupart des redirections, il s'agit d'une correspondance entre l'ancienne et la nouvelle route :

```js title="astro.config.mjs" {4-6}
import { defineConfig } from 'astro/config';

export default defineConfig({
  redirects: {
    '/ancienne-page': '/nouvelle-page'
  }
});
```

Ces redirections suivent les m√™mes r√®gles que les routes bas√©es sur des fichiers. Les routes dynamiques sont autoris√©es tant que les nouvelles et les anciennes routes contiennent les m√™mes param√®tres, par exemple :

```js
{
  "/blog/[...slug]": "/articles/[...slug]"
}
```

En utilisant SSR ou un adaptateur statique, vous pouvez √©galement fournir un objet comme valeur, ce qui vous permet de sp√©cifier le code `status` en plus de la nouvelle `destination` :

```js title="astro.config.mjs" {5-8}
import { defineConfig } from 'astro/config';

export default defineConfig({
  redirects: {
    '/ancienne-page': {
      status: 302,
      destination: '/nouvelle-page'
    }
  }
});
```

Lors de l'ex√©cution de `astro build`, Astro produira des fichiers HTML avec la balise [meta refresh](https://developer.mozilla.org/fr-FR/docs/Web/HTML/Element/meta#examples) par d√©faut. Les adaptateurs support√©s √©criront √† la place le fichier de configuration de l'h√¥te avec les redirections.

Le code de statut est `301` par d√©faut. Si l'on construit des fichiers HTML, le code de statut n'est pas utilis√© par le serveur.

### Redirections Dynamiques

Globalement sur `Astro`, la m√©thode `Astro.redirect` vous permet de rediriger vers une autre page dynamiquement. Vous pouvez le faire apr√®s avoir v√©rifi√© que l'utilisateur est connect√© en r√©cup√©rant sa session √† partir d'un cookie.

```astro title="src/pages/account.astro" {8}
---
import { isLoggedIn } from '../utils';

const cookie = Astro.request.headers.get('cookie');

// Si l'utilisateur n'est pas connect√©, le rediriger vers la page de connexion.
if (!isLoggedIn(cookie)) {
  return Astro.redirect('/login');
}
---
<html>
  <!-- Page ici... -->
</html>
```

## Ordre de Priorit√© des Routes

Il est possible que plusieurs routes correspondent au m√™me chemin URL. Par exemple, chacune de ces routes correspondrait √† `/posts/create` :

<FileTree>
- src/pages/
  - posts/
    - create.astro
    - [pid].astro
    - [...slug].astro
</FileTree>

Astro a besoin de savoir quelle route doit √™tre utilis√©e pour construire la page. Pour ce faire, il les trie selon les r√®gles suivantes :

- Les routes statiques sans param√®tres de chemin sont prioritaires sur toutes les autres routes.
- Les routes dynamiques utilisant des param√®tres nomm√©s sont prioritaires par rapport aux param√®tres REST.
- Les routes dynamiques pr√©-rendues sont prioritaires sur les routes dynamiques du serveur.
- Les param√®tres REST ont la priorit√© la plus basse.
- Les points de terminaison ont toujours la priorit√© sur les pages.
- Les √©galit√©s sont r√©solues par ordre alphab√©tique.

Dans l'exemple ci-dessus, voici quelques exemples de la mani√®re dont les r√®gles feront correspondre une URL demand√©e √† la route utilis√©e pour construire le code HTML ::

- `pages/post/create.astro` - Correspondra au chemin `/post/create`
- `pages/post/[pid].astro` - Correspondra au chemin `/post/1`, `/post/abc`, etc. Mais pas √† `/post/create`
- `pages/post/[...slug].astro` - Correspondra au chemin `/post/1/2`, `/post/a/b/c`, etc. Mais pas √† `/post/create`, `/post/1`, `/post/abc`

Les redirections suivent √©galement les m√™mes r√®gles, mais sont prioritaires *en dernier* ; s'il existe une route bas√©e sur les fichiers et une redirection avec le m√™me niveau de priorit√© de route, la route bas√©e sur les fichiers est choisie.

## Pagination

Astro prend en charge la pagination int√©gr√©e pour les grandes collections de donn√©es qui doivent √™tre divis√©es en plusieurs pages. Astro g√©n√®re les propri√©t√©s de pagination courantes, y compris les URL des pages pr√©c√©dentes/suivantes, le nombre total de pages, etc.

Les noms des routes pagin√©es doivent utiliser la m√™me syntaxe de `[crochets]` que les routes dynamiques standard. Par exemple, le nom de fichier `/astronauts/[page].astro` g√©n√©rera des routes pour `/astronauts/1`, `/astronauts/2`, etc, l√† o√π `[page]` est le num√©ro de la page g√©n√©r√©e.

Vous pouvez utiliser la fonction `paginate()` pour g√©n√©rer ces pages pour un tableau de valeurs comme ceci :

```astro /{ (paginate) }/ /paginate\\(.*\\)/ /(?<=const.*)(page)/ /page\\.[a-zA-Z]+/
---
// src/pages/astronauts/[page].astro
export async function getStaticPaths({ paginate }) {
  const astronautPages = [{
    astronaut: 'Neil Armstrong',
  }, {
    astronaut: 'Buzz Aldrin',
  }, {
    astronaut: 'Jean-Loup Chr√©tien',
  }, {
    astronaut: 'Thomas Pesquet',
  }];
  // G√©n√®re des pages √† partir de notre tableau d'astronautes, avec 2 par page
  return paginate(astronautPages, { pageSize: 2 });
}
// Toutes les donn√©es pagin√©es sont pass√©es dans la propri√©t√© "page"
const { page } = Astro.props;
---

<!-- Affiche le num√©ro de la page actuelle. Astro.params.page peut aussi √™tre utilis√© ! -->
<h1>Page {page.currentPage}</h1>
<ul>
  <!-- Fait la liste de notre tableau d'astronautes -->
  {page.data.map(({ astronaut }) => <li>{astronaut}</li>)}
</ul>
```

Cela g√©n√®re les pages suivantes, avec deux √©l√©ments par page :
- `/astronauts/1` - Page 1: Affiche "Neil Armstrong" et "Buzz Aldrin"
- `/astronauts/2` - Page 2: Affiche "Jean-Loup Chr√©tien" et "Thomas Pesquet"


### La Propri√©t√© (props) `page`

Lorsque vous utilisez la fonction `paginate()`, chaque page re√ßoit ses donn√©es via une propri√©t√© `page`. La propri√©t√© `page` a beaucoup de propri√©t√©s utiles, mais voici les principales :
- **`page.data`** - Tableau contenant la portion de donn√©es de page que vous avez pass√© dans la fonction `paginate()`
- **`page.url.next`** - Lien vers la page suivante dans la collection
- **`page.url.prev`** - Lien vers la page pr√©c√©dente dans la collection

```astro /(?<=const.*)(page)/ /page\\.[a-zA-Z]+(?:\\.(?:prev|next))?/
---
// src/pages/astronauts/[page].astro
// Paginons la m√™me liste d'objets { astronaut } que l'exemple pr√©c√©dent
export async function getStaticPaths({ paginate }) { /* ... */ }
const { page } = Astro.props;
---
<h1>Page {page.currentPage}</h1>
<ul>
  {page.data.map(({ astronaut }) => <li>{astronaut}</li>)}
</ul>
{page.url.prev ? <a href={page.url.prev}>Pr√©c√©dent</a> : null}
{page.url.next ? <a href={page.url.next}>Suivant</a> : null}
```


#### R√©f√©rence Compl√®te de l'API

```ts
interface Page<T = any> {
	/** R√©sultat */
	data: T[];
	/** M√©tadonn√©es */
	/** Nombre du premier √©l√©ment de la page, √† partir de 0 */
	start: number;
	/** Nombre du dernier √©l√©ment de la page, √† partir de 0 */
	end: number;
	/** Nombre total de r√©sultats */
	total: number;
	/** Num√©ro de la page actuelle, √† partir de 1 */
	currentPage: number;
	/** Nombre d'√©l√©ments par page (par d√©faut : 25) */
	size: number;
	/** Nombre de la derni√®re page */
	lastPage: number;
	url: {
		/** URL de la page actuelle */
		current: string;
		/** URL de la page pr√©c√©dente (si il y en a une) */
		prev: string | undefined;
		/** URL de la page suivante (si il y en a une) */
		next: string | undefined;
	};
}
```

### Pagination Imbriqu√©e

Un cas d'utilisation plus avanc√© de la pagination est la **pagination imbriqu√©e**, c'est-√†-dire lorsque la pagination est combin√©e avec d'autres param√®tres d'itin√©raires dynamiques. Vous pouvez utiliser la pagination imbriqu√©e pour regrouper votre collection pagin√©e en fonction d'une propri√©t√© ou d'une balise.

Par exemple, si vous voulez grouper vos posts Markdown pagin√©s par une balise, vous utiliserez la pagination imbriqu√©e en cr√©ant une page `/src/pages/[tag]/[page].astro` qui correspondra aux URLS suivantes :

- `/red/1` (tag=red)
- `/red/2` (tag=red)
- `/blue/1` (tag=blue)
- `/green/1` (tag=green)

La pagination imbriqu√©e fonctionne en renvoyant un tableau de r√©sultats `paginate()` de `getStaticPaths()`, un pour chaque groupe.

Dans l'exemple suivant, nous allons impl√©menter la pagination imbriqu√©e pour construire les URLs list√©es ci-dessus :

```astro /(?:[(]|=== )(tag)/ "params: { tag }" /const [{ ]*(page|params)/
---
// Exemple: /src/pages/[tag]/[page].astro
export function getStaticPaths({paginate}) {
  const allTags = ['red', 'blue', 'green'];
  const allPosts = await Astro.glob('../../posts/*.md');
  // Pour chaque tag, retourne un r√©sultat paginate().
  // Assurez-vous que vous passez "{params: {tag}}" √† la fonction "paginate()"
  // Assurez-vous qu'Astro conna√Æt les tags du r√©sultat
  return allTags.map((tag) => {
    const filteredPosts = allPosts.filter((post) => post.frontmatter.tag === tag);
    return paginate(filteredPosts, {
      params: { tag },
      pageSize: 10
    });
  });
}
const { page } = Astro.props;
const params = Astro.params;
```

## Exclure des pages

Vous pouvez exclure des pages, ou m√™me des r√©pertoires entiers, de la construction en pr√©fixant leur nom par un trait de soulignement (`_`).

Cela vous permet de cr√©er des pages priv√©es, et aussi de placer les tests, les utilitaires et les composants dans les pages correspondantes, en les emp√™chant d'√™tre construits dans des fichiers `.html` et plac√©s dans le r√©pertoire `dist/`.

Dans cet exemple, seuls `src/pages/index.astro` et `src/pages/posts/post1.md` seront construits comme routes de pages et fichiers HTML.

<FileTree>
- src/pages/
  - _r√©pertoire-cach√©/
    - page1.md
    - page2.md
  - _page-cach√©e.astro
  - **index.astro**
  - posts/
    - _SomeComponent.astro
    - _utils.js
    - **post1.md**
</FileTree>
