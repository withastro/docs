---
title: Partage d'√âtat
description: Apprenez √† partager l'√©tat entre les composants du framework avec les Nano Stores.
i18nReady: true
type: recipe
---

import UIFrameworkTabs from '~/components/tabs/UIFrameworkTabs.astro'
import LoopingVideo from '~/components/LoopingVideo.astro'
import JavascriptFlavorTabs from '~/components/tabs/JavascriptFlavorTabs.astro'
import RecipeLinks from "~/components/RecipeLinks.astro"

Lors de la construction d'un site web Astro avec l'[architecture isol√©e / hydratation partielle](/fr/concepts/islands/), vous avez peut-√™tre rencontr√© ce probl√®me : **Je veux partager l'√©tat entre mes composants.**

Les frameworks d'interface utilisateur tels que React ou Vue peuvent encourager l'utilisation de [fournisseurs de "contexte"](https://fr.reactjs.org/docs/context.html) pour que d'autres composants puissent les consommer. Mais lorsque vous [hydratez partiellement des composants](/fr/core-concepts/framework-components/#hydratation-des-composants-interactifs) dans Astro ou Markdown, vous ne pouvez pas utiliser ces enveloppes contextuelles.

Astro recommande une solution diff√©rente pour le stockage partag√© c√¥t√© client : les [**Nano Stores**](https://github.com/nanostores/nanostores).

<RecipeLinks slugs={["fr/recipes/sharing-state"]} />

## Pourquoi Nano Stores ?

La biblioth√®que [Nano Stores](https://github.com/nanostores/nanostores) vous permet de cr√©er des stores avec lesquels n'importe quel composant peut interagir. Nous recommandons Nano Stores pour les raisons suivantes :
- **Ils sont l√©gers.** Nano Stores contient le strict minimum de JS dont vous aurez besoin (moins de 1 Ko) sans aucune d√©pendance.
- **Ils sont agnostiques.** Cela signifie que le partage d'√©tat entre les frameworks sera fera de mani√®re transparent ! Astro est bas√© sur la flexibilit√©, c'est pourquoi nous aimons les solutions qui offrent une exp√©rience de d√©veloppement similaire, quelle que soit votre pr√©f√©rence.

Il existe n√©anmoins un certain nombre d'alternatives que vous pouvez explorer. En voici quelques-unes :
- Les [Stores int√©gr√©s de Svelte](https://svelte.dev/tutorial/writable-stores)
- [Les signaux de SolidJS](https://www.solidjs.com/docs/latest) en dehors du contexte d'un composant
- [API de r√©activit√© de Vue](https://vuejs.org/guide/scaling-up/state-management.html#simple-state-management-with-reactivity-api)
- [L'envoi d'√©v√©nements de navigateur personnalis√©s](https://developer.mozilla.org/fr/docs/Web/Events/Creating_and_triggering_events) entre les composants

:::note[FAQ]

<details>
<summary>**üôã Puis-je utiliser Nano Stores dans des fichiers `.astro` ou d'autres composants c√¥t√© serveur ?**</summary>

Nano Stores _peut_ √™tre import√©, √©crit et lu dans les composants c√¥t√© serveur, **mais nous ne le recommandons pas !** Ceci est d√ª √† quelques restrictions :
- L'√©criture d'un store √† partir d'un fichier `.astro` ou [composant non hydrat√©](/fr/core-concepts/framework-components/#hydratation-des-composants-interactifs) n'affectera *pas* la valeur re√ßue par les [composants c√¥t√© client](/fr/reference/directives-reference/#directives-client).
- Vous ne pouvez pas transmettre un Nano Store en tant que `prop` aux composants c√¥t√© client.
- Vous ne pouvez pas vous abonner aux mises √† jour du store √† partir d'un fichier `.astro`, puisque les composants Astro ne se rafra√Æchissent pas. 

Si vous comprenez ces restrictions et que vous trouvez toujours un cas d'utilisation, vous pouvez essayer Nano Stores ! N'oubliez pas que les Nano Stores sont con√ßus pour √™tre r√©actifs aux changements sur le **client** sp√©cifiquement.

</details>

<details>
<summary>**üôã En quoi les Stores de Svelte sont-ils diff√©rents de Nano Stores ?**</summary>

**Nano Stores et les [Svelte Stores](https://svelte.dev/tutorial/writable-stores) sont tr√®s similaires !** En effet, [Nano Stores vous permettent d'utiliser le m√™me raccourci `$`](https://github.com/nanostores/nanostores#svelte) pour les abonnements que vous pourriez utiliser avec Svelte stores.

Si vous voulez √©viter les biblioth√®ques tierces, les [Svelte Stores](https://svelte.dev/tutorial/writable-stores) constituent √† eux seuls un excellent outil de communication inter-√Æles. N√©anmoins, vous pouvez pr√©f√©rerer Nano Stores si :
1. Vous aimez leurs modules compl√©mentaires pour [les objets](https://github.com/nanostores/nanostores#maps) et [l'√©tat asynchrone](https://github.com/nanostores/nanostores#lazy-stores).
2. Ou si vous souhaitez communiquer entre Svelte et d'autres frameworks d'interface utilisateur comme Preact ou Vue.
</details>

<details>
<summary>**üôã Comment Solid signals est-il diff√©rent de Nano Stores ?**</summary>

Si vous utilisez Solid depuis un certain temps, vous avez peut-√™tre essay√© de d√©placer les ["signals"](https://www.solidjs.com/docs/latest#createsignal) ou [stores](https://www.solidjs.com/docs/latest#createstore) en dehors de vos composants. C'est un excellent moyen de partager l'√©tat entre les √Æles de composants Solid ! Essayez d'exporter des "signals" √† partir d'un fichier partag√© :

```js
// sharedStore.js
import { createSignal } from 'solid-js';

export const sharedCount = createSignal(0);
```
...et tous les composants important `sharedCount` partageront le m√™me √©tat. Bien que cela fonctionne bien, vous pr√©f√©rerez peut-√™tre Nano Stores si a) vous aimez leurs modules compl√©mentaires pour
 ["objects"](https://github.com/nanostores/nanostores#maps) et [async state](https://github.com/nanostores/nanostores#lazy-stores), ou b) vous souhaitez communiquer entre Solid et d'autres frameworks d'interface utilisateur comme Preact ou Vue.

</details>
:::

## Installer Nano Stores

Pour commencer, installez Nano Stores avec son package d'assistance pour votre framework d'interface utilisateur pr√©f√©r√© :

<UIFrameworkTabs>
  <Fragment slot="preact">
  ```shell
  npm install nanostores @nanostores/preact
  ```
  </Fragment>
  <Fragment slot="react">
  ```shell
  npm install nanostores @nanostores/react
  ```
  </Fragment>
  <Fragment slot="solid">
  ```shell
  npm install nanostores @nanostores/solid
  ```
  </Fragment>
  <Fragment slot="svelte">
  ```shell
  npm install nanostores
  ```
  :::note
  Pas de package d'assistance ici ! Nano Stores peuvent √™tre utilis√©s comme Svelte stores standard

  :::
  </Fragment>
  <Fragment slot="vue">
  ```shell
  npm install nanostores @nanostores/vue
  ```
  </Fragment>
</UIFrameworkTabs>

Vous pouvez aller directement dans le [guide d'utilisation de Nano Stores](https://github.com/nanostores/nanostores#guide) √† partir d'ici, ou suivez notre exemple ci-dessous !

## Exemple d'utilisation - Menu d√©roulant pour un panier de e-commerce

Disons que nous construisons une interface de e-commerce simple avec trois √©l√©ments interactifs :
- Un formulaire de soumission "ajouter au panier"
- Un menu d√©roulant du panier pour afficher les articles ajout√©s
- Une bascule de chariot

<LoopingVideo sources={[{ src: '/videos/stores-example.mp4', type: 'video/mp4' }]} />

_[**Essayez l'exemple compl√©t√©**](https://github.com/withastro/astro/tree/main/examples/with-nanostores) sur votre machine ou en ligne via Stackblitz._

Votre fichier Astro de base peut ressembler √† ceci :

```astro
---
// Example: src/pages/index.astro
import CartFlyoutToggle from '../components/CartFlyoutToggle';
import CartFlyout from '../components/CartFlyout';
import AddToCartForm from '../components/AddToCartForm';
---

<!DOCTYPE html>
<html lang="en">
<head>...</head>
<body>
  <header>
    <nav>
      <a href="/">Vitrine Astro</a>
      <CartFlyoutToggle client:load />
    </nav>
  </header>
  <main>
    <AddToCartForm client:load>
    <!-- ... -->
    </AddToCartForm>
  </main>
  <CartFlyout client:load />
</body>
</html>
```

### Utilisation des "atoms"

Commen√ßons par ouvrir notre `CartFlyout` chaque fois que `CartFlyoutToggle` est cliqu√©. 

Tout d'abord, cr√©ez un nouveau fichier JS ou TS pour contenir notre store. Nous utiliserons un
 ["atom"](https://github.com/nanostores/nanostores#atoms) pour cela :

```js
// src/cartStore.js
import { atom } from 'nanostores';

export const isCartOpen = atom(false);
```

Maintenant, nous pouvons importer ce store dans n'importe quel fichier qui doit le lire ou y √©crire. Nous allons commencer par c√¢bler notre `CartFlyoutToggle` :

<UIFrameworkTabs>
<Fragment slot="preact">
```jsx
// src/components/CartFlyoutToggle.jsx
import { useStore } from '@nanostores/preact';
import { isCartOpen } from '../cartStore';

export default function CartButton() {
  // lire la valeur du store avec le hook `useStore`
  const $isCartOpen = useStore(isCartOpen);
  // write to the imported store using `.set`
  return (
    <button onClick={() => isCartOpen.set(!$isCartOpen)}>Cart</button>
  )
}
```
</Fragment>
<Fragment slot="react">
```jsx
// src/components/CartFlyoutToggle.jsx
import { useStore } from '@nanostores/react';
import { isCartOpen } from '../cartStore';

export default function CartButton() {
  // read the store value with the `useStore` hook
  const $isCartOpen = useStore(isCartOpen);
  // write to the imported store using `.set`
  return (
    <button onClick={() => isCartOpen.set(!$isCartOpen)}>Cart</button>
  )
}
```
</Fragment>
<Fragment slot="solid">
```jsx
// src/components/CartFlyoutToggle.jsx
import { useStore } from '@nanostores/solid';
import { isCartOpen } from '../cartStore';

export default function CartButton() {
  // read the store value with the `useStore` hook
  const $isCartOpen = useStore(isCartOpen);
  // write to the imported store using `.set`
  return (
    <button onClick={() => isCartOpen.set(!$isCartOpen())}>Cart</button>
  )
}
```
</Fragment>
<Fragment slot="svelte">
```svelte
<!--src/components/CartFlyoutToggle.svelte-->
<script>
  import { isCartOpen } from '../cartStore';
</script>

<!--use "$" to read the store value-->
<button on:click={() => isCartOpen.set(!$isCartOpen)}>Cart</button>
```
</Fragment>
<Fragment slot="vue">
```vue
<!--src/components/CartFlyoutToggle.vue-->
<template>
  <!--write to the imported store using `.set`-->
  <button @click="isCartOpen.set(!$isCartOpen)">Cart</button>
</template>

<script setup>
  import { isCartOpen } from '../cartStore';
  import { useStore } from '@nanostores/vue';

  // read the store value with the `useStore` hook
  const $isCartOpen = useStore(isCartOpen);
</script>
```
</Fragment>
<Fragment slot="lit">
```ts
// src/components/CartFlyoutToggle.ts
import { LitElement, html } from 'lit';
import { isCartOpen } from '../cartStore';

export class CartFlyoutToggle extends LitElement {
  handleClick() {
    isCartOpen.set(!isCartOpen.get());
  }

  render() {
    return html`
      <button @click="${this.handleClick}">Cart</button>
    `;
  }
}

customElements.define('cart-flyout-toggle', CartFlyoutToggle);
```
</Fragment>
</UIFrameworkTabs>

Ensuite, nous pouvons lire `isCartOpen` √† partir de notre composant `CartFlyout` :

<UIFrameworkTabs>
<Fragment slot="preact">
```jsx
// src/components/CartFlyout.jsx
import { useStore } from '@nanostores/preact';
import { isCartOpen } from '../cartStore';

export default function CartFlyout() {
  const $isCartOpen = useStore(isCartOpen);

  return $isCartOpen ? <aside>...</aside> : null;
}
```
</Fragment>
<Fragment slot="react">
```jsx
// src/components/CartFlyout.jsx
import { useStore } from '@nanostores/react';
import { isCartOpen } from '../cartStore';

export default function CartFlyout() {
  const $isCartOpen = useStore(isCartOpen);

  return $isCartOpen ? <aside>...</aside> : null;
}
```
</Fragment>
<Fragment slot="solid">
```jsx
// src/components/CartFlyout.jsx
import { useStore } from '@nanostores/solid';
import { isCartOpen } from '../cartStore';

export default function CartFlyout() {
  const $isCartOpen = useStore(isCartOpen);

  return $isCartOpen() ? <aside>...</aside> : null;
}
```
</Fragment>
<Fragment slot="svelte">
```svelte
<!--src/components/CartFlyout.svelte-->
<script>
  import { isCartOpen } from '../cartStore';
</script>

{#if $isCartOpen}
<aside>...</aside>
{/if}
```
</Fragment>
<Fragment slot="vue">
```vue
<!--src/components/CartFlyout.vue-->
<template>
  <aside v-if="$isCartOpen">...</aside>
</template>

<script setup>
  import { isCartOpen } from '../cartStore';
  import { useStore } from '@nanostores/vue';

  const $isCartOpen = useStore(isCartOpen);
</script>
```
</Fragment>
<Fragment slot="lit">
```ts
// src/components/CartFlyout.ts
import { isCartOpen } from '../cartStore';
import { LitElement, html } from 'lit';
import { StoreController } from '@nanostores/lit';

export class CartFlyout extends LitElement {
  private cartOpen = new StoreController(this, isCartOpen);

  render() {
    return this.cartOpen.value ? html`<aside>...</aside>` : null;
  }
}

customElements.define('cart-flyout', CartFlyout);

```
</Fragment>
</UIFrameworkTabs>

### Utilisation des "maps"

:::tip
**[Maps](https://github.com/nanostores/nanostores#maps) sont un excellent choix pour les objets sur lesquels vous √©crivez r√©guli√®rement !** En plus des aides standard `get()` et `set()` fournies par `atom`, vous aurez √©galement une fonction `.setKey()` pour mettre √† jour efficacement cl√©s d'objet individuelles.
:::

Maintenant, gardons une trace des articles dans votre panier. Pour √©viter les doublons et garder une trace de la "quantit√©", nous pouvons stocker votre panier en tant qu'objet avec l'ID de l'article comme cl√©. Nous utiliserons une [Map](https://github.com/nanostores/nanostores#maps) pour √ßa.

Ajoutons un magasin `cartItem` √† notre `cartStore.js` de plus t√¥t. Vous pouvez √©galement passer √† un fichier TypeScript pour d√©finir la forme si vous le souhaitez.

<JavascriptFlavorTabs>
  <Fragment slot="js">
  ```js
  // src/cartStore.js
  import { atom, map } from 'nanostores';

  export const isCartOpen = atom(false);

  /**
   * @typedef {Object} CartItem
   * @property {string} id
   * @property {string} name
   * @property {string} imageSrc
   * @property {number} quantity
   */

  /** @type {import('nanostores').MapStore<Record<string, CartItem>>} */
  export const cartItems = map({});

  ```
  </Fragment>
  <Fragment slot="ts">
  ```ts
  // src/cartStore.ts
  import { atom, map } from 'nanostores';

  export const isCartOpen = atom(false);

  export type CartItem = {
    id: string;
    name: string;
    imageSrc: string;
    quantity: number;
  }

  export const cartItems = map<Record<string, CartItem>>({});
  ```
  </Fragment>
</JavascriptFlavorTabs>

Maintenant, exportons un assistant `addCartItem` pour que nos composants l'utilisent.
- **Si cet article n'existe pas dans votre panier**, ajoutez l'article avec une quantit√© de d√©part de 1.
- **Si cet article _existe_ d√©j√†**, augmentez la quantit√© de 1.

<JavascriptFlavorTabs>
  <Fragment slot="js">
  ```js
  // src/cartStore.js
  ...
  export function addCartItem({ id, name, imageSrc }) {
    const existingEntry = cartItems.get()[id];
    if (existingEntry) {
      cartItems.setKey(id, {
        ...existingEntry,
        quantity: existingEntry.quantity + 1,
      })
    } else {
      cartItems.setKey(
        id,
        { id, name, imageSrc, quantity: 1 }
      );
    }
  }
  ```
  </Fragment>
  <Fragment slot="ts">
  ```ts
  // src/cartStore.ts
  ...
  type ItemDisplayInfo = Pick<CartItem, 'id' | 'name' | 'imageSrc'>;
  export function addCartItem({ id, name, imageSrc }: ItemDisplayInfo) {
    const existingEntry = cartItems.get()[id];
    if (existingEntry) {
      cartItems.setKey(id, {
        ...existingEntry,
        quantity: existingEntry.quantity + 1,
      });
    } else {
      cartItems.setKey(
        id,
        { id, name, imageSrc, quantity: 1 }
      );
    }
  }
  ```
  </Fragment>
</JavascriptFlavorTabs>

:::note
<details>

<summary>**üôã Pourquoi utiliser `.get()` ici au lieu d'un assistant `useStore` ?**</summary>

Vous avez peut-√™tre remarqu√© que nous appelons `cartItems.get()` ici, au lieu de r√©cup√©rer cet assistant `useStore` de nos exemples React / Preact / Solid / Vue. En effet, **useStore est destin√© √† d√©clencher de nouveaux rendus de composants.** En d'autres termes, `useStore` doit √™tre utilis√© chaque fois que la valeur du store est restitu√©e √† l'interface utilisateur. Puisque nous lisons la valeur lorsqu'un **√©v√©nement** est d√©clench√© (`addToCart` dans ce cas), et que nous n'essayons pas d'effectuer un rendu de cette valeur, nous n'avons pas besoin de `useStore` ici.
</details>
:::

Avec notre store en place, nous pouvons appeler cette fonction dans notre `AddToCartForm` chaque fois que ce formulaire est soumis. Nous ouvrirons √©galement le menu d√©roulant du panier afin que vous puissiez voir un r√©sum√© complet du panier.

<UIFrameworkTabs>
<Fragment slot="preact">
```jsx
// src/components/AddToCartForm.jsx
import { addCartItem, isCartOpen } from '../cartStore';

export default function AddToCartForm({ children }) {
  // we'll hardcode the item info for simplicity!
  const hardcodedItemInfo = {
    id: 'astronaut-figurine',
    name: 'Astronaut Figurine',
    imageSrc: '/images/astronaut-figurine.png',
  }

  function addToCart(e) {
    e.preventDefault();
    isCartOpen.set(true);
    addCartItem(hardcodedItemInfo);
  }

  return (
    <form onSubmit={addToCart}>
      {children}
    </form>
  )
}
```
</Fragment>
<Fragment slot="react">
```jsx
// src/components/AddToCartForm.jsx
import { addCartItem, isCartOpen } from '../cartStore';

export default function AddToCartForm({ children }) {
  // we'll hardcode the item info for simplicity!
  const hardcodedItemInfo = {
    id: 'astronaut-figurine',
    name: 'Astronaut Figurine',
    imageSrc: '/images/astronaut-figurine.png',
  }

  function addToCart(e) {
    e.preventDefault();
    isCartOpen.set(true);
    addCartItem(hardcodedItemInfo);
  }

  return (
    <form onSubmit={addToCart}>
      {children}
    </form>
  )
}
```
</Fragment>
<Fragment slot="solid">
```jsx
// src/components/AddToCartForm.jsx
import { addCartItem, isCartOpen } from '../cartStore';

export default function AddToCartForm({ children }) {
  // we'll hardcode the item info for simplicity!
  const hardcodedItemInfo = {
    id: 'astronaut-figurine',
    name: 'Astronaut Figurine',
    imageSrc: '/images/astronaut-figurine.png',
  }

  function addToCart(e) {
    e.preventDefault();
    isCartOpen.set(true);
    addCartItem(hardcodedItemInfo);
  }

  return (
    <form onSubmit={addToCart}>
      {children}
    </form>
  )
}
```
</Fragment>
<Fragment slot="svelte">
```svelte
<!--src/components/AddToCartForm.svelte-->
<form on:submit|preventDefault={addToCart}>
  <slot></slot>
</form>

<script>
  import { addCartItem, isCartOpen } from '../cartStore';

  // we'll hardcode the item info for simplicity!
  const hardcodedItemInfo = {
    id: 'astronaut-figurine',
    name: 'Astronaut Figurine',
    imageSrc: '/images/astronaut-figurine.png',
  }

  function addToCart() {
    isCartOpen.set(true);
    addCartItem(hardcodedItemInfo);
  }
</script>
```
</Fragment>
<Fragment slot="vue">
```vue
<!--src/components/AddToCartForm.vue-->
<template>
  <form @submit="addToCart">
    <slot></slot>
  </form>
</template>

<script setup>
  import { addCartItem, isCartOpen } from '../cartStore';

  // we'll hardcode the item info for simplicity!
  const hardcodedItemInfo = {
    id: 'astronaut-figurine',
    name: 'Astronaut Figurine',
    imageSrc: '/images/astronaut-figurine.png',
  }

  function addToCart(e) {
    e.preventDefault();
    isCartOpen.set(true);
    addCartItem(hardcodedItemInfo);
  }
</script>
```
</Fragment>
<Fragment slot="lit">
```ts
// src/components/AddToCartForm.ts
import { LitElement, html } from 'lit';
import { isCartOpen, addCartItem } from '../cartStore';

export class AddToCartForm extends LitElement {
  static get properties() {
    return {
      item: { type: Object },
    };
  }

  constructor() {
    super();
    this.item = {};
  }

  addToCart(e) {
    e.preventDefault();
    isCartOpen.set(true);
    addCartItem(this.item);
  }

  render() {
    return html`
      <form @submit="${this.addToCart}">
        <slot></slot>
      </form>
    `;
  }
}
customElements.define('add-to-cart-form', AddToCartForm);
```
</Fragment>
</UIFrameworkTabs>

Enfin, nous afficherons ces √©l√©ments de panier dans notre `CartFlyout` :

<UIFrameworkTabs>
<Fragment slot="preact">
```jsx
// src/components/CartFlyout.jsx
import { useStore } from '@nanostores/preact';
import { isCartOpen, cartItems } from '../cartStore';

export default function CartFlyout() {
  const $isCartOpen = useStore(isCartOpen);
  const $cartItems = useStore(cartItems);

  return $isCartOpen ? (
    <aside>
      {Object.values($cartItems).length ? (
        <ul>
          {Object.values($cartItems).map(cartItem => (
            <li>
              <img src={cartItem.imageSrc} alt={cartItem.name} />
              <h3>{cartItem.name}</h3>
              <p>Quantity: {cartItem.quantity}</p>
            </li>
          ))}
        </ul>
      ) : <p>Your cart is empty!</p>}
    </aside>
  ) : null;
}
```
</Fragment>
<Fragment slot="react">
```jsx
// src/components/CartFlyout.jsx
import { useStore } from '@nanostores/react';
import { isCartOpen, cartItems } from '../cartStore';

export default function CartFlyout() {
  const $isCartOpen = useStore(isCartOpen);
  const $cartItems = useStore(cartItems);

  return $isCartOpen ? (
    <aside>
      {Object.values($cartItems).length ? (
        <ul>
          {Object.values($cartItems).map(cartItem => (
            <li>
              <img src={cartItem.imageSrc} alt={cartItem.name} />
              <h3>{cartItem.name}</h3>
              <p>Quantity: {cartItem.quantity}</p>
            </li>
          ))}
        </ul>
      ) : <p>Your cart is empty!</p>}
    </aside>
  ) : null;
}
```
</Fragment>
<Fragment slot="solid">
```jsx
// src/components/CartFlyout.jsx
import { useStore } from '@nanostores/solid';
import { isCartOpen, cartItems } from '../cartStore';

export default function CartFlyout() {
  const $isCartOpen = useStore(isCartOpen);
  const $cartItems = useStore(cartItems);

  return $isCartOpen() ? (
    <aside>
      {Object.values($cartItems()).length ? (
        <ul>
          {Object.values($cartItems()).map(cartItem => (
            <li>
              <img src={cartItem.imageSrc} alt={cartItem.name} />
              <h3>{cartItem.name}</h3>
              <p>Quantity: {cartItem.quantity}</p>
            </li>
          ))}
        </ul>
      ) : <p>Your cart is empty!</p>}
    </aside>
  ) : null;
}
```
</Fragment>
<Fragment slot="svelte">
```svelte
<!--src/components/CartFlyout.svelte-->
<script>
  import { isCartOpen, cartItems } from '../cartStore';
</script>

{#if $isCartOpen}
  {#if Object.values($cartItems).length}
    <aside>
      {#each Object.values($cartItems) as cartItem}
      <li>
        <img src={cartItem.imageSrc} alt={cartItem.name} />
        <h3>{cartItem.name}</h3>
        <p>Quantity: {cartItem.quantity}</p>
      </li>
      {/each}
    </aside>
  {#else}
    <p>Your cart is empty!</p>
  {/if}
{/if}
```
</Fragment>
<Fragment slot="vue">
```vue
<!--src/components/CartFlyout.vue-->
<template>
  <aside v-if="$isCartOpen">
    <ul v-if="Object.values($cartItems).length">
      <li v-for="cartItem in Object.values($cartItems)" v-bind:key="cartItem.name">
        <img :src=cartItem.imageSrc :alt=cartItem.name />
        <h3>{{cartItem.name}}</h3>
        <p>Quantity: {{cartItem.quantity}}</p>
      </li>
    </ul>
    <p v-else>Your cart is empty!</p>
  </aside>
</template>

<script setup>
  import { cartItems, isCartOpen } from '../cartStore';
  import { useStore } from '@nanostores/vue';

  const $isCartOpen = useStore(isCartOpen);
  const $cartItems = useStore(cartItems);
</script>
```
</Fragment>
<Fragment slot="lit">
```ts
// src/components/CartFlyout.ts
import { LitElement, html } from 'lit';
import { isCartOpen, cartItems } from '../cartStore';
import { StoreController } from '@nanostores/lit';

export class CartFlyoutLit extends LitElement {
  private cartOpen = new StoreController(this, isCartOpen);
  private getCartItems = new StoreController(this, cartItems);

  renderCartItem(cartItem) {
    return html`
      <li>
        <img src="${cartItem.imageSrc}" alt="${cartItem.name}" />
        <h3>${cartItem.name}</h3>
        <p>Quantity: ${cartItem.quantity}</p>
      </li>
    `;
  }

  render() {
    return this.cartOpen.value
      ? html`
          <aside>
            ${
              Object.values(this.getCartItems.value).length
                ? html`
                  <ul>
                    ${Object.values(this.getCartItems.value).map((cartItem) =>
                      this.renderCartItem(cartItem)
                    )}
                  </ul>
                `
                : html`<p>Your cart is empty!</p>`
            }
          </aside>
        `
      : null;
  }
}

customElements.define('cart-flyout', CartFlyoutLit);
```
</Fragment>
</UIFrameworkTabs>

Maintenant, vous devriez avoir un exemple de e-commerce enti√®rement interactif avec le plus petit bundle de JS de la galaxie
 üöÄ

[**Essayez l'exemple compl√©t√©**](https://github.com/withastro/astro/tree/main/examples/with-nanostores) sur votre machine ou en ligne via Stackblitz !
