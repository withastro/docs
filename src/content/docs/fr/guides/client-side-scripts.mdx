---
title: Scripts et gestion d'√©v√®nements.
description: >-
  Comment ajouter de l'interactivit√© c√¥t√© client aux composants Astro en utilisant les 
  API JavaScript natives du navigateur.
i18nReady: true
---

Vous pouvez ajouter de l'interactivit√© √† vos composants Astro sans [utiliser un framework UI](/fr/core-concepts/framework-components/) comme React, Svelte, Vue, etc, en utilisant les balises HTML `<script>` standard. Cela vous permet d'ex√©cuter du JavaScript dans le navigateur et d'ajouter des fonctionnalit√©s √† vos composants Astro.

## Client-Side Scripts

Les scripts peuvent √™tre utilis√©s pour √©couter des √©v√©nements envoyer des donn√©es analytiques, jouer des animations et tout ce que JavaScript permet de faire sur le web.

```astro
<!-- src/components/ConfettiButton.astro -->
<button data-confetti-button>Celebrate!</button>

<script>
  // Import le module NPM.
  import confetti from 'canvas-confetti';

  // Trouver le composant DOM dans la page.
  const buttons = document.querySelectorAll('[data-confetti-button]');

  // Ajouter l'√©couteur d'√©v√©nemnt pour d√©clencher des confettis lorsqu'un bouton est cliqu√©.
  buttons.forEach((button) => {
    button.addEventListener('click', () => confetti());
  });
</script>
```

Par d√©faut, Astro traite et regroupe les balises `<script>`, ce qui permet d'importer des modules npm, d'√©crire du TypeScript, etc.

## Utilisation du `<script>` dans Astro.

Dans les fichiers `.astro`, vous pouvez ajouter du JavaScript c√¥t√© client en ajoutant une (ou plusieurs) balises `<script>`.

Dans cet example, l'ajout du composant `<Hello />` √† un page enregistrera un message dans la console du navigateur.

```astro title="src/compnonents/Hello.astro"
<h1>Bienvenue, le monde !</h1>

<script>
  console.log('Bienvenue, console du navigateur !');
</script>
```

### Regroupement de script

Par d√©faut, les balises `<script>` sont optimis√©es par Astro.

- Toutes les importations seront regroup√©es, ce qui vous permettra d'importer des fichiers locaux ou des modules Node.
- Le script optimis√© sera inject√© dans le `<head>` de votre page HTML avec [`type="module"`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Modules).
- TypeScript est enti√®rement support√©, y compris l'import de fichiers TypeScript.
- Si votre composant est utilis√© plusieurs fois sur un page, le script ne sera inclus qu'une seule fois.

```astro title="src/components/Example.astro"
<script>
  // Optimis√© ! Regroup√© ! TypeScript support√© !
  // L'importation de fichiers locaux et de modules Node est support√©e.
<script>
```

Pour √©viter le regroupement de script, vous pouvez utiliser la directive `is:inline`.

```astro title:"src/components/InlineScript.astro" "is:inline"
<script is:inline>
  // Sera rendu dans le HTML exactement comme √©crit.
  // Les imports locales ne seront pas r√©solues et ne fonctionneront pas.
  // S'il se trouve dans un composant, il se r√©p√®te chaque fois que le composant est utilis√©.
</script>
```

:::note
Le comportement de regroupement par d√©faut d'Astro sera d√©sactiv√© dans certaines situations. En particulier, l'ajout de `type="module"` ou de tout autre attribut que `src` √† une balise `<script>` am√®nera Astro √† traiter la balise comme si elle avait une directive `is:inline`. Il en va de m√™me lorsque le script est √©crit dans une expression JSX.
:::

üìö Consultez notre page [r√©f√©rence des directives](/fr/reference/directives-reference/#directives-de-script-et-de-style) pour plus d'informations sur les directives disponibles des balises `<script>`.

### Chargement de script

Vous pouvez vouloir √©crire vos scripts comme des fichiers `.js`/`.ts` s√©par√©s ou avoir besoin de r√©f√©rencer un script externe sur un autre serveur. Vous pouvez le faire en les r√©f√©ren√ßant dans l'attribut `src' d'une balise `<script>`.

### Importer des scripts locaux

**Quand l'utiliser :** Si votre script se trouve dans `src/`.

Astro construira, optimisera et ajoutera ces scripts √† la page pour vous, en suivant ses [r√®gles de regroupement des scripts](#regroupement-de-script)

```astro title="src/components/LocalScripts.astro"
<!-- chemin relatif du script dans `src/scripts/local.js` -->
<script src="../scripts/local.js"></script>

<!-- fonctionne √©galement pour les fichiers TypeScript locaux -->
<script src="./script-with-types.ts"></script>
```

#### Charger des scripts externes

**Quand l'utiliser :** Si votre fichier JavaScript se trouve √† l'int√©rieur du dossier `public/` ou sur un CDN.

Pour charger des scripts en dehors du dossier `src/` de votre projet, incluez la directive `is:inline`. Cette approche permet d'√©viter le traitement JavaScript, le regroupement et l'optimisation du JavaScript qui sont fournis par Astro lorsque vous importez des scripts comme d√©crit ci-dessus.

```astro title="src/components/ExternalScripts.astro" "is:inline"
<!-- chemin absolu du script √† `public/my-script.js` -->
<script is:inline src="/my-script.js"></script>

<!-- URL compl√®te vers un script sur un serveur distant -->
<script is:inline src="https://my-analytics.com/script.js"></script>
```

## Mod√®les communs de script

### G√©rer le `onclick` et d'autres √©v√®nements

Certains frameworks d'interface utilisateur utilisent une syntaxe personnalis√©e pour la gestion des √©v√©nements comme `onClick={...}` (React/Preact) ou `@click="..."` (Vue). Astro suit au plus pr√®s le HTML standard et n‚Äôutilise pas de syntaxe personnalis√©e pour les √©v√®nements.

Au lieu de cela, vous pouvez utiliser [`addEventListener`](https://developer.mozilla.org/fr/docs/Web/API/EventTarget/addEventListener) dans une balise `<script>` pour g√©rer les interactions avec l'utilisateur.

```astro title="src/components/AlertButton.astro"
<button class="alert">Cliquez-moi !</button>

<script>
  // Trouver tous les boutons avec la classe `alert` sur la page.
  const buttons = document.querySelectorAll('button.alert');

  // G√©rer les clics sur chaque bouton.
  buttons.forEach((button) => {
    button.addEventListener('click', () => {
      alert('Button was clicked !');
    });
  });
</script>
```

:::note
Si vous avez plusieurs composants `<AlertButton />` sur une page, Astro n'ex√©cutera pas le script plusieurs fois. Les scripts sont regroup√©s et ne sont inclus qu'une seul fois par page. L'utilisation de `querySelectorAll` garantit que ce script attache l'√©couteur d'√©v√®nement √† chaque bouton de la classe `alert` pr√©sent sur la page.
:::

### Composants Web avec des √©l√©ments personnalis√©s

Vous pouvez cr√©er vos propres √©l√©ments HTML avec un comportement personnalis√© en utilisant le standard Web Components. La d√©finition d'un [√©l√©ment personnalis√©] (https://developer.mozilla.org/fr/docs/Web/API/Web_components/Using_custom_elements) dans un composant `.astro` vous permet de cr√©er des composants interactifs sans avoir besoin d'une biblioth√®que de Framwork utilisateur.

Dans cet exemple, nous d√©finissons un nouvel √©l√©ment HTML `<astro-heart>` qui enregistre le nombre de fois que vous cliquez sur le bouton "c≈ìur" et met √† jour l'√©l√©ment `<span>` avec le dernier d√©compte.

```astro title="src/components/AstroHeart.astro"
<!-- Enveloppez les √©l√©ments du composant dans notre √©l√©ment personnalis√© "astro-heart" -->
<astro-heart>
  <button aria-label="Heart">üíú</button> √ó <span>0</span>
</astro-heart>

<script>
  // D√©finir le comportement de notre nouveau type d'√©l√©ment HTML.
  class AstroHeart extends HTMLElement {
    constructor() {
			super();
      let count = 0;

      const heartButton = this.querySelector('button');
      const countSpan = this.querySelector('span');

      // √Ä chaque fois que le bouton est cliqu√©, on met √† jour le compte.
			heartButton.addEventListener('click', () => {
        count++;
        countSpan.textContent = count;
      });
		}
  }

  // Dites au navigateur d'utiliser notre classe AstroHeart pour les √©l√©ments <astro-heart>.
  customElements.define('astro-heart', AstroHeart);
</script>
```

L'utilisation d'un √©l√©ment personnalis√© pr√©sente deux avantages :

1. Au lieu de chercher dans toute la page en utilisant `document.querySelector()`, vous pouvez utiliser `this.querySelector()`, qui ne recherche que dans l'instance courante de l'√©l√©ment personnalis√©. Cela permet de travailler plus facilement avec les enfants d'une seule instance de composant √† la fois.

2. Bien qu'un `<script>` ne s'ex√©cute qu'une seule fois, le navigateur ex√©cutera la m√©thode `constructor()` de notre √©l√©ment personnalis√© chaque fois qu'il trouvera `<astro-heart>` sur la page.  Cela signifie que vous pouvez √©crire en toute s√©curit√© du code pour un seul composant √† la fois, m√™me si vous avez l'intention d'utiliser ce composant plusieurs fois sur une page.

üìö Pour en savoir plus sur les √©l√©ments personnalis√©s, consultez [le guide des composants Web r√©utilisables de web.dev (EN)](https://web.dev/custom-elements-v1/) et [l'introduction aux √©l√©ments personnalis√©s de MDN](https://developer.mozilla.org/fr/docs/Web/API/Web_components/Using_custom_elements).

### Passer les variables frontmatter aux scripts

Dans les composants Astro, le code dans [le frontmatter](/fr/core-concepts/astro-components/#le-script-du-composant) entre les codes barres ‚Äú---‚Äù s'ex√©cute sur le serveur et n'est pas disponible dans le navigateur. Pour envoyer des variables du serveur au client, nous avons besoin d'un moyen de stocker nos variables et de les lire lorsque le JavaScript s'ex√©cute dans le navigateur.

Une fa√ßon d'y parvenir est d'utiliser les attributs [`data-*`](https://developer.mozilla.org/fr/docs/Learn/HTML/Howto/Use_data_attributes) pour stocker la valeur des variables dans votre sortie HTML. Les scripts, y compris les √©l√©ments personnalis√©s, peuvent alors lire ces attributs en utilisant la propri√©t√© `dataset` d'un √©l√©ment une fois que votre HTML se charge dans le navigateur.

Dans cet exemple de composant, une variable `message` est stock√©e dans un attribut `data-message`, de sorte que l'√©l√©ment personnalis√© puisse lire `this.dataset.message` et obtenir la valeur de la variable dans le navigateur.

```astro title="src/components/AstroGreet.astro" {2} /data-message={.+}/ "this.dataset.message"
---
const { message = 'Bienvenue, le monde!' } = Astro.props;
---

<!-- Stocker la propri√©t√© de message comme attribut de donn√©es. -->
<astro-greet data-message={message}>
  <button>Saluer!</button>
</astro-greet>

<script>
  class AstroGreet extends HTMLElement {
    constructor() {
			super();

      // Lisez le message de l‚Äôattribut data.
      const message = this.dataset.message;
      const button = this.querySelector('button');
      button.addEventListener('click', () => {
        alert(message);
      });
		}
  }

  customElements.define('astro-greet', AstroGreet);
</script>
```

Nous pouvons maintenant utiliser notre composant plusieurs fois et √™tre accueillis par un message diff√©rent √† chaque fois.

```astro title="src/pages/example.astro"
---
import AstroGreet from '../components/AstroGreet.astro';
---

<!-- Utilisez le message par d√©faut: "Bienvenue, monde!" -->
<AstroGreet />

<!-- Utiliser des messages personnalis√©s pass√©s comme prop. -->
<AstroGreet message="Belle journ√©e pour construire des composants !" />
<AstroGreet message="Content que tu sois l√† ! üëã" />
```

:::tip[Le saviez-vous?]
C'est en fait ce qu'Astro fait dans les coulisses lorsque vous passez des props √† un composant √©crit avec un framework UI comme React ! Pour les composants avec une directive `client:*`, Astro cr√©e un √©l√©ment personnalis√© `<astro-island>` avec un attribut `props` qui stocke vos props c√¥t√© serveur dans la sortie HTML.
:::
