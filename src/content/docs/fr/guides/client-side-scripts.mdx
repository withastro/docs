---
title: Scripts et gestion d'√©v√®nements
description: >-
  Comment ajouter de l'interactivit√© c√¥t√© client aux composants Astro en utilisant les 
  API JavaScript natives du navigateur.
i18nReady: true
---
import ReadMore from '~/components/ReadMore.astro'

Vous pouvez envoyer du JavaScript au navigateur et ajouter des fonctionnalit√©s √† vos composants Astro en utilisant les balises `<script>` dans le mod√®le de composant.

Les scripts ajoutent de l'interactivit√© √† votre site, comme la gestion des √©v√©nements ou la mise √† jour du contenu de mani√®re dynamique, sans avoir besoin d'un [framework d'interface utilisateur](/fr/guides/framework-components/) comme React, Svelte ou Vue. Cela √©vite les frais li√©s √† l'envoi de JavaScript par le framework et ne n√©cessite aucune connaissance d'un framework suppl√©mentaire pour cr√©er un site web ou une application compl√®te.

## Scripts c√¥t√© client

Les scripts peuvent √™tre utilis√©s pour ajouter des √©couteurs d'√©v√©nements, envoyer des donn√©es analytiques, lire des animations et tout ce que JavaScript permet de faire sur le web.

Astro am√©liore automatiquement la balise HTML standard `<script>` avec le regroupement, TypeScript et plus encore. R√©f√©rez-vous √† [comment Astro traite les scripts](#traitement-des-scripts) pour plus de d√©tails.

```astro title="src/components/ConfettiButton.astro"
<button data-confetti-button>C√©l√©brer !</button>

<script>
  // Importer depuis le paquet npm.
  import confetti from 'canvas-confetti';

  // Trouver le DOM de notre composant dans la page.
  const buttons = document.querySelectorAll('[data-confetti-button]');

  // Ajouter l'√©couteur d'√©v√©nement pour d√©clencher des confettis lorsqu'un bouton est cliqu√©.
  buttons.forEach((button) => {
    button.addEventListener('click', () => confetti());
  });
</script>
```

<ReadMore>Consultez [quand vos scripts ne seront pas trait√©s](#scripts-non-trait√©s) pour r√©soudre les probl√®mes de comportement des scripts ou pour savoir comment d√©sactiver intentionnellement ce traitement.</ReadMore>


### Traitement des scripts

Par d√©faut, Astro traite les balises `<script>` qui ne contiennent aucun attribut (autre que `src`) de la mani√®re suivante¬†:

- **Prise en charge de TypeScript¬†:** Tous les scripts utilisent TypeScript par d√©faut.
- **Regroupement des importations¬†:** Importez des fichiers locaux ou des modules npm, qui seront regroup√©s.
- **Type Module¬†:** Les scripts trait√©s utilisent [`type="module"`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Modules) automatiquement.
- **D√©duplication¬†:** Si un composant contenant un `<script>` est utilis√© plusieurs fois sur une page, le script ne sera inclus qu'une seule fois.
- **Incorporation automatique¬†:** Si le script est suffisamment petit, Astro l'int√©grera directement dans le HTML pour r√©duire le nombre de requ√™tes.
```astro title="src/components/Example.astro"
<script>
  // Optimis√© ! Regroup√© ! TypeScript !
  // L'importation de scripts locaux et de paquets npm fonctionne.
</script>
```

### Scripts non trait√©s

Astro ne traitera pas une balise `<script>` si elle poss√®de un attribut autre que `src`.

Vous pouvez ajouter la directive [`is:inline`](/fr/reference/directives-reference/#isinline) pour d√©sactiver intentionnellement le traitement d'un script.

```astro title="src/components/InlineScript.astro" "is:inline"
<script is:inline>
  // Sera rendu dans le code HTML exactement comme il est √©crit !
  // Non transform√© : pas de TypeScript et pas de r√©solution d'importation par Astro.
  // S'il est utilis√© √† l'int√©rieur d'un composant, ce code est dupliqu√© pour chaque instance.
</script>
```

### Inclure des fichiers JavaScript dans la page

Vous pouvez vouloir √©crire vos scripts comme des fichiers `.js`/`.ts` s√©par√©s ou avoir besoin de r√©f√©rencer un script externe sur un autre serveur. Vous pouvez le faire en les r√©f√©ren√ßant dans l'attribut `src` d'une balise `<script>`.

#### Importer des scripts locaux

**Quand l'utiliser :** Si votre script se trouve dans `src/`.

Astro traitera ces scripts conform√©ment aux [r√®gles de traitement des scripts](#traitement-des-scripts).

```astro title="src/components/LocalScripts.astro"
<!-- chemin relatif du script dans `src/scripts/local.js` -->
<script src="../scripts/local.js"></script>

<!-- fonctionne √©galement pour les fichiers TypeScript locaux -->
<script src="./script-with-types.ts"></script>
```

#### Charger des scripts externes

**Quand l'utiliser :** Si votre fichier JavaScript se trouve √† l'int√©rieur du dossier `public/` ou sur un CDN.

Pour charger des scripts en dehors du dossier `src/` de votre projet, incluez la directive `is:inline`. Cette approche permet d'√©viter le traitement JavaScript, le regroupement et l'optimisation du JavaScript qui sont fournis par Astro lorsque vous importez des scripts comme d√©crit ci-dessus.

```astro title="src/components/ExternalScripts.astro" "is:inline"
<!-- chemin absolu du script √† `public/my-script.js` -->
<script is:inline src="/my-script.js"></script>

<!-- URL compl√®te vers un script sur un serveur distant -->
<script is:inline src="https://my-analytics.com/script.js"></script>
```

## Mod√®les communs de script

### G√©rer le `onclick` et d'autres √©v√®nements

Certains frameworks d'interface utilisateur utilisent une syntaxe personnalis√©e pour la gestion des √©v√©nements comme `onClick={...}` (React/Preact) ou `@click="..."` (Vue). Astro suit au plus pr√®s le HTML standard et n‚Äôutilise pas de syntaxe personnalis√©e pour les √©v√®nements.

Au lieu de cela, vous pouvez utiliser [`addEventListener`](https://developer.mozilla.org/fr/docs/Web/API/EventTarget/addEventListener) dans une balise `<script>` pour g√©rer les interactions avec l'utilisateur.

```astro title="src/components/AlertButton.astro"
<button class="alert">Cliquez-moi !</button>

<script>
  // Trouver tous les boutons avec la classe `alert` sur la page.
  const buttons = document.querySelectorAll('button.alert');

  // G√©rer les clics sur chaque bouton.
  buttons.forEach((button) => {
    button.addEventListener('click', () => {
      alert('Le bouton a √©t√© cliqu√© !');
    });
  });
</script>
```

Si vous avez plusieurs composants `<AlertButton />` sur une page, Astro n'ex√©cutera pas le script plusieurs fois. Les scripts sont regroup√©s et ne sont inclus qu'une seule fois par page. L'utilisation de `querySelectorAll` garantit que ce script attache l'√©couteur d'√©v√®nements √† chaque bouton poss√©dant la classe `alert` pr√©sent sur la page.


### Composants Web avec des √©l√©ments personnalis√©s

Vous pouvez cr√©er vos propres √©l√©ments HTML avec un comportement personnalis√© en utilisant la norme Web Components. La d√©finition d'un [√©l√©ment personnalis√©](https://developer.mozilla.org/fr/docs/Web/API/Web_components/Using_custom_elements) dans un composant `.astro` vous permet de cr√©er des composants interactifs sans avoir besoin d'une biblioth√®que de framework UI.

Dans cet exemple, nous d√©finissons un nouvel √©l√©ment HTML `<astro-heart>` qui enregistre le nombre de fois que vous cliquez sur le bouton en forme de c≈ìur et met √† jour l'√©l√©ment `<span>` avec le dernier d√©compte.

```astro title="src/components/AstroHeart.astro"
<!-- Enveloppez les √©l√©ments du composant dans notre √©l√©ment personnalis√© "astro-heart" -->
<astro-heart>
  <button aria-label="Heart">üíú</button> √ó <span>0</span>
</astro-heart>

<script>
  // D√©finir le comportement de notre nouveau type d'√©l√©ment HTML.
  class AstroHeart extends HTMLElement {
    connectedCallback() {
      let count = 0;

      const heartButton = this.querySelector('button');
      const countSpan = this.querySelector('span');

      // √Ä chaque fois que le bouton est cliqu√©, on met √† jour le compte.
			heartButton.addEventListener('click', () => {
        count++;
        countSpan.textContent = count;
      });
		}
  }

  // Dites au navigateur d'utiliser notre classe AstroHeart pour les √©l√©ments <astro-heart>.
  customElements.define('astro-heart', AstroHeart);
</script>
```

L'utilisation d'un √©l√©ment personnalis√© pr√©sente deux avantages :

1. Au lieu de chercher dans toute la page en utilisant `document.querySelector()`, vous pouvez utiliser `this.querySelector()`, qui ne recherche que dans l'instance courante de l'√©l√©ment personnalis√©. Cela permet de travailler plus facilement avec les enfants d'une seule instance de composant √† la fois.

2. Bien qu'un `<script>` ne s'ex√©cute qu'une seule fois, le navigateur ex√©cutera la m√©thode `connectedCallback()` de notre √©l√©ment personnalis√© chaque fois qu'il trouvera `<astro-heart>` sur la page.  Cela signifie que vous pouvez √©crire en toute s√©curit√© du code pour un seul composant √† la fois, m√™me si vous avez l'intention d'utiliser ce composant plusieurs fois sur une page.

<ReadMore>Pour en savoir plus sur les √©l√©ments personnalis√©s, consultez [le guide des composants Web r√©utilisables de web.dev (Anglais)](https://web.dev/custom-elements-v1/) et [l'introduction aux √©l√©ments personnalis√©s de MDN](https://developer.mozilla.org/fr/docs/Web/API/Web_components/Using_custom_elements).</ReadMore>


### Transmettre les variables du frontmatter aux scripts

Dans les composants Astro, le code dans [le frontmatter](/fr/basics/astro-components/#le-script-du-composant) (entre les d√©limiteurs `---`) s'ex√©cute sur le serveur et n'est pas disponible dans le navigateur.

Pour transmettre des variables c√¥t√© serveur aux scripts c√¥t√© client, d√©finissez-les dans des [attributs `data-*`](https://developer.mozilla.org/fr/docs/Web/HTML/How_to/Use_data_attributes) sur les √©l√©ments HTML. Les scripts peuvent ensuite acc√©der √† ces valeurs gr√¢ce √† la propri√©t√© `dataset`.

Dans cet exemple de composant, une propri√©t√© `message` est stock√©e dans un attribut `data-message`, de sorte que l'√©l√©ment personnalis√© puisse lire `this.dataset.message` et obtenir la valeur de la propri√©t√© dans le navigateur.

```astro title="src/components/AstroGreet.astro" {2} /data-message={.+}/ "this.dataset.message"
---
const { message = 'Bienvenue, le monde !' } = Astro.props;
---

<!-- Stocker la propri√©t√© message comme attribut de donn√©es. -->
<astro-greet data-message={message}>
  <button>Saluer !</button>
</astro-greet>

<script>
  class AstroGreet extends HTMLElement {
    connectedCallback() {
      // Lisez le message de l‚Äôattribut data.
      const message = this.dataset.message;
      const button = this.querySelector('button');
      button.addEventListener('click', () => {
        alert(message);
      });
		}
  }

  customElements.define('astro-greet', AstroGreet);
</script>
```

Nous pouvons maintenant utiliser notre composant plusieurs fois et √™tre accueillis par un message diff√©rent √† chaque fois.

```astro title="src/pages/example.astro"
---
import AstroGreet from '../components/AstroGreet.astro';
---

<!-- Utilisez le message par d√©faut: "Bienvenue, le monde !" -->
<AstroGreet />

<!-- Utiliser des messages personnalis√©s pass√©s comme props. -->
<AstroGreet message="Belle journ√©e pour cr√©er des composants !" />
<AstroGreet message="Content que tu sois l√† ! üëã" />
```

:::tip[Le saviez-vous ?]
C'est en fait ce qu'Astro fait dans les coulisses lorsque vous passez des props √† un composant √©crit avec un framework d'interface utilisateur comme React ! Pour les composants avec une directive `client:*`, Astro cr√©e un √©l√©ment personnalis√© `<astro-island>` avec un attribut `props` qui stocke vos param√®tres c√¥t√© serveur dans la sortie HTML.
:::

### Combinaison de scripts et de frameworks UI

Les √©l√©ments rendus par un framework UI peuvent ne pas √™tre disponibles au moment de l'ex√©cution d'une balise `<script>`. Si votre script doit √©galement g√©rer les [composants d'un framework UI](/fr/guides/framework-components/), il est recommand√© d'utiliser un √©l√©ment personnalis√©.
