---
title: R√©f√©rence des directives de mod√®le
i18nReady: true
---

Les **directives de mod√®le** sont un type sp√©cial d'attribut HTML disponible dans n'importe quel mod√®le de composant Astro (fichiers `.astro`). Certains peuvent √©galement √™tre utilis√©s dans les fichiers `.mdx`.

Les directives de mod√®le sont utilis√©es pour contr√¥ler le comportement d'un √©l√©ment ou d'un composant d'une certaine mani√®re. Une directive de mod√®le peut activer certaines fonctionnalit√©s du compilateur qui vous facilitent la vie (comme l'utilisation de `class:list` au lieu de `class`). Ou, une directive pourrait dire au compilateur d'Astro de faire quelque chose de sp√©cial avec un composant (comme l'hydratation avec `client:load`).

Cette page d√©crit toutes les directives de mod√®le disponibles dans Astro et leur fonctionnement.
## R√®gles

Pour qu'une directive de mod√®le soit valide, il faut :

- Inclure un deux-points `:` dans son nom, en utilisant la forme `X:Y` (ex : `client:load`).
- √ätre visible pour le compilateur (ex : `<X {...attr}>` ne fonctionnerait pas si `attr` contenait une directive).

Certaines directives de mod√®le, mais pas toutes, peuvent prendre une valeur personnalis√©e :
- `<X client:load />` (ne prend aucune valeur)
- `<X class:list={['une-class-css']} />` (prend un tableau)

Une directive de mod√®le n'est jamais incluse directement dans la sortie HTML finale d'un composant.

##  Directives Communes
### `class:list`

`class:list={...}` prend un tableau de classe et les convertit en une cha√Æne de caract√®res contenant les classes. Ceci est inspir√© de la populaire biblioth√®que d'assistance [clsx](https://github.com/lukeed/clsx) de @lukeed, mais int√©gr√©e directement dans Astro lui-m√™me.

`class:list` prend un tableau de plusieurs types de valeurs possibles :
- `string` : ajout√© √† l'√©l√©ment `class`
- `Object` : toutes les cl√©s truthy sont ajout√©es √† l'√©l√©ment `class`
- `Array` : aplati
- `Set` : aplati

```astro
<!-- Ceci -->
<span class:list={[ 'bonjour salut', { bonjour: true, monde: true }, new Set([ 'bonjour', 'ami' ]) ]} />
<!-- Devient -->
<span class="bonjour salut monde ami"></span>
```

Les valeurs en double sont supprim√©es automatiquement.

### `set:html`

`set:html={string}` injecte une cha√Æne de caract√®res HTML dans un √©l√©ment, similaire √† la propri√©t√© `el.innerHTML`.

**La valeur n'est pas automatiquement √©chapp√©e par Astro !** Assurez-vous que vous faites confiance √† la valeur ou que vous l'avez √©chapp√©e manuellement avant de la transmettre au mod√®le. Oublier de le faire vous exposera aux [attaques de type Cross Site Scripting (XSS).](https://owasp.org/www-community/attacks/xss/)

```astro
---
const rawHTMLString = "Hello <strong>World</strong>"
---
<h1>{rawHTMLString}</h1>
  <!-- Sortie: <h1>Hello &lt;strong&gt;World&lt;/strong&gt;</h1> -->
<h1 set:html={rawHTMLString} />
  <!-- Sortie: <h1>Hello <strong>World</strong></h1> -->
```

Vous pouvez √©galement utiliser `set:html` sur un `<Fragment>` pour √©viter d'ajouter un √©l√©ment d'enveloppe inutile. Cela peut √™tre particuli√®rement utile lors de la r√©cup√©ration de code HTML √† partir d'un CMS.

```astro
---
const cmsContent = await fetchHTMLFromMyCMS();
---
<Fragment set:html={cmsContent}>
```

`set:html={Promise<string>}` injecte une cha√Æne de caract√®res HTML dans un √©l√©ment qui est envelopp√© dans une Promise.

Cela peut √™tre utilis√© pour injecter du HTML stock√© en externe, comme dans une base de donn√©es.

```astro
---
import API from '../db/api.js';
---
<article set:html={api.getArticle(Astro.props.id)}></article>
```

`set:html={Promise<Response>}` injecte une [Response](https://developer.mozilla.org/fr/docs/Web/API/Response) dans un √©l√©ment.

Ceci est particuli√®rement utile lors de l'utilisation de `fetch()`. Par exemple, r√©cup√©rer d'anciens posts √† partir d'un pr√©c√©dent g√©n√©rateur de site statique.

```astro
<article set:html={fetch('http://example/old-posts/making-soup.html')}></article>
```

`set:html` peut √™tre utilis√© sur n'importe quelle balise et n'a pas besoin d'inclure de HTML. Par exemple, vous pouvez l'utiliser avec [`JSON.stringify()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) sur une balise `<script>` pour ajouter un sch√©ma [JSON-LD](https://json-ld.org/) √† votre page.

```astro
<script type="application/ld+json" set:html={JSON.stringify({
  "@context": "https://schema.org/",
  "@type": "Person",
  name: "Houston",
  hasOccupation: {
    "@type": "Occupation",
    name: "Astronaut"
  }
})}/>
```

### `set:text`

`set:text={string}` injecte une cha√Æne de caract√®res dans un √©l√©ment, similaire √† la propri√©t√© `el.innerText`. Contrairement √† `set:html`, la valeur `string` transmise est automatiquement √©chapp√©e par Astro.

Cela √©quivaut √† passer directement une variable dans une expression de mod√®le (ex : `<div>{someText}</div>`) et, par cons√©quent, cette directive n'est pas couramment utilis√©e.
## Directives Client

Ces directives contr√¥lent la fa√ßon dont les [composants de Framework UI](/fr/core-concepts/framework-components/) sont hydrat√©s sur la page.

Par d√©faut, un composant de Framework UI n'est pas hydrat√© c√¥t√© client. Si aucune directive `client:*` n'est fournie, son HTML est rendu sur la page sans JavaScript.

Une directive client ne peut √™tre utilis√©e que sur un composant de Framework UI directement import√© dans un composant `.astro`. Les directives d'hydratation ne sont pas prises en charge lors de l'utilisation de [balises dynamiques](/fr/core-concepts/astro-syntax/#balises-dynamiques) et de [composants personnalis√©s transmis via la prop `components`](/fr/guides/markdown-content/#composants-personnalis√©s-avec-du-mdx-import√©).

### `client:load`

- **Priorit√© :** √âlev√©e
- **Utile pour :** Les √©l√©ments UI imm√©diatement visibles qui doivent √™tre interactifs le plus t√¥t possible.

Charge et hydrate le composant JavaScript imm√©diatement au chargement de la page.

```astro
<BuyButton client:load />
```
### `client:idle`

- **Priorit√© :** Moyenne
- **Utile pour :** Les √©l√©ments UI de priorit√© moindre qui n'ont pas besoin d'√™tre imm√©diatement interactifs.

Charge et hydrate le composant JavaScript une fois que le chargement initial de la page est termin√© et que l'√©v√©nement `requestIdleCallback` s'est d√©clench√©. Si vous utilisez un navigateur qui ne prend pas en charge [`requestIdleCallback`](https://developer.mozilla.org/fr/docs/Web/API/Window/requestIdleCallback), alors l'√©venement [`load`](https://developer.mozilla.org/fr/docs/Web/API/Window/load_event) est utilis√©.

```astro
<ShowHideButton client:idle />
```
### `client:visible`

- **Priorit√© :** Faible
- **Utile pour :** Les √©l√©ments UI de faible priorit√© qui sont soit loin en bas de page ("sous la ligne de flottaison") ou qui consomment tellement de ressources que vous pr√©f√©reriez ne pas les charger du tout si l'utilisateur ne voit jamais ces √©l√©ments.

Charge et hydrate le JavaScript du composant une fois que le celui-ci est entr√© dans la fen√™tre d'affichage de l'utilisateur. Ceci utilise un `IntersectionObserver` en interne pour garder une trace de la visibilit√©.

```astro
<HeavyImageCarousel client:visible />
```

### `client:media`

- **Priorit√© :** Faible
- **Utile pour :** Les barres lat√©rales ou autres √©l√©ments qui ne peuvent √™tre visibles que sur certaines tailles d'√©cran.

`client:media={string}` charge et hydrate le composant JavaScript une fois qu'une certaine requ√™te m√©dia CSS est satisfaite.

:::note
Si le composant est d√©j√† masqu√© et affich√© par une requ√™te multim√©dia dans votre CSS, il peut √™tre plus simple d'utiliser simplement `client: visible` et de ne pas passer cette m√™me requ√™te multim√©dia dans la directive.
:::

```astro
<SidebarToggle client:media="(max-width: 50em)" />
```
### `client:only`

`client:only={string}` **ignore** le rendu HTML c√¥t√© serveur et s'affiche uniquement c√¥t√© client. Cette directive agit de la m√™me mani√®re que `client:load` dans le o√π elle charge, rend et hydrate le composant imm√©diatement au chargement de la page.

**Vous devez transmettre le bon Framework du composant en tant que valeur !** Parce qu'Astro n'ex√©cute le composant ni pendant le Build ni sur le serveur, Astro ne sait pas quel framework votre composant utilise √† moins que vous ne lui disiez explicitement.

```astro
<SomeReactComponent client:only="react" />
<SomePreactComponent client:only="preact" />
<SomeSvelteComponent client:only="svelte" />
<SomeVueComponent client:only="vue" />
<SomeSolidComponent client:only="solid-js" />
```

### Directives Client personnalis√©es

Depuis Astro 2.6.0, les int√©grations peuvent √©galement ajouter des directives `client:*` personnalis√©es pour modifier comment et quand les composants doivent √™tre hydrat√©s.

Visitez la page [API `addClientDirective`](/fr/reference/integrations-reference/#addclientdirective-option) pour en savoir plus sur la cr√©ation d'une directive client personnalis√©e.

## Directives de Script et de Style

Ces directives ne peuvent √™tre utilis√©es que sur les balises HTML `<script>` et `<style>` pour contr√¥ler la fa√ßon dont votre JavaScript c√¥t√© client et votre CSS sont g√©r√©s sur la page.
### `is:global`

Par d√©faut, Astro limite automatiquement la port√©e des r√®gles CSS du `<style>` au composant. Vous pouvez d√©sactiver ce comportement avec la directive `is:global`.

`is:global` fait en sorte que le contenu d'une balise `<style>` s'applique globalement sur la page lorsque le composant est inclus. Cela d√©sactive le syst√®me de port√©e des r√®gles CSS d'Astro. Cela √©quivaut √† envelopper tous les s√©lecteurs dans la balise `<style>` avec `:global()`.

Vous pouvez combiner `<style>` et `<style is:global>` ensemble dans le m√™me composant pour cr√©er des r√®gles de style globales tout en limitant la port√©e de la plupart des r√®gles CSS de votre composant.

üìö Consultez la page [CSS et Stylisation](/fr/guides/styling/#global-styles) pour plus de d√©tails sur le fonctionnement des styles globaux.

```astro
<style is:global>
  body a { color: red; }
</style>
```

### `is:inline`

Par d√©faut, Astro traitera, optimisera et regroupera toutes les balises `<script>` et `<style>` qu'il voit sur la page. Vous pouvez d√©sactiver ce comportement avec la directive `is:inline`.

`is:inline` indique √† Astro de laisser la balise `<script>` ou `<style>` telle quelle dans la sortie HTML finale. Le contenu ne sera ni trait√©, ni optimis√© ni regroup√©. Cela limite certaines fonctionnalit√©s d'Astro, comme l'importation d'un paquet npm ou l'utilisation d'un langage de compilation vers CSS comme Sass.

La directive `is:inline` signifie que les balises `<style>` et `<script>` :

- Ne seront pas regroup√©es dans un fichier externe. Cela signifie que les [attributs comme `defer`](https://javascript.info/script-async-defer) qui contr√¥lent le chargement d'un fichier externe n'auront aucun effet.
- Ne seront pas d√©dupliqu√©es : l'√©l√©ment appara√Ætra autant de fois qu'il sera rendu.
- Les r√©f√©rences `import`/`@import`/`url()` ne seront pas r√©solues relativement au fichier `.astro`.
- Seront rendues dans le HTML de la sortie final exactement l√† o√π elles ont √©t√© cr√©√©es.
- Les styles seront globaux et non limit√©s au composant.

:::caution
La directive `is:inline` est implicite chaque fois qu'un attribut autre que `src` est utilis√© sur une balise `<script>` ou `<style>`.
:::

```astro
<style is:inline>
  /* inline: les imports relatifs et de paquets npm ne sont pas support√©s */
  @import '/assets/some-public-styles.css';
  span { color: green; }
</style>

<script is:inline>
   /* inline: les imports relatifs et de paquets npm ne sont pas support√©s */
  console.log('Je suis en ligne ici dans le HTMl de sortie final.');
</script>
```

üìö D√©couvrez comment les [scripts c√¥t√© client](/fr/guides/client-side-scripts/) fonctionnent dans les composants Astro.

### `define:vars`

`define:vars={...}` peut passer des variables c√¥t√© serveur du frontmatter de votre composant dans les balises client `<script>` ou `<style>`. Toute variable du frontmatter s√©rialisable en JSON est support√©e, y compris les "props" transmis √† votre composant via `Astro.props`. Les valeurs sont s√©rialis√©es avec [`JSON.stringify()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify).

```astro
---
const foregroundColor = "rgb(221 243 228)";
const backgroundColor = "rgb(24 121 78)";
const message = "Astro est g√©nial !";
---
<style define:vars={{ textColor: foregroundColor, backgroundColor }}>
  h1 {
    background-color: var(--backgroundColor);
    color: var(--textColor);
  }
</style>

<script define:vars={{ message }}>
  alert(message);
</script>
```

:::caution
L'utilisation de `define:vars` sur une balise `<script>` implique la [directive `is:inline`](#isinline), ce qui signifie que vos scripts ne seront pas regroup√©s et seront int√©gr√©s directement dans le code HTML.

En effet, lorsque Astro regroupe un script, il inclut et ex√©cute le script une seule fois m√™me si vous incluez le composant contenant le script plusieurs fois sur une m√™me page. `define:vars` n√©cessite qu'un script soit r√©ex√©cut√© avec chaque ensemble de valeurs, donc Astro cr√©e un script en ligne √† la place.

Pour les scripts, essayez plut√¥t de [transmettre les variables aux scripts manuellement](/fr/guides/client-side-scripts/#passer-les-variables-frontmatter-aux-scripts).
:::

## Directives Avanc√©es
### `is:raw`

`is:raw` indique au compilateur d'Astro de traiter tous les enfants de cet √©l√©ment comme du texte. Cela signifie que toute syntaxe sp√©ciale de template Astro sera ignor√©e √† l'int√©rieur de ce composant.

Par exemple, si vous aviez un composant Katex personnalis√© qui convertit du texte en HTML, vous pourriez demander aux utilisateurs de faire ceci :

```astro
---
import Katex from '../components/Katex.astro' ;
---
<Katex is:raw>Certaines {syntaxes} contradictoires ici</Katex>
```
