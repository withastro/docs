---
title: Astro 适配器 API
sidebar:
  label: 适配器 API
---

import ReadMore from '~/components/ReadMore.astro';
import Since from '~/components/Since.astro';
import { FileTree } from '@astrojs/starlight/components';

Astro 可以轻松部署到任何云托管平台，以实现按需渲染，也叫做服务端渲染（SSR）。该能力由**适配器**[集成](/zh-cn/reference/integrations-reference/)提供，请参阅 [按需渲染指南](/zh-cn/guides/on-demand-rendering/) 了解如何使用现有的适配器。

## 什么是适配器？

适配器是一种特殊类型的[集成](/zh-cn/reference/integrations-reference/)，它为请求时的服务器渲染提供了入口。适配器可以访问完整的集成 API，并执行两项操作：

- 实现托管平台的 API，以处理请求。
- 根据托管平台的约定配置构建过程。

## 构建适配器

创建一个集成并在 [`astro:config:done`](/zh-cn/reference/integrations-reference/#astroconfigdone) 钩子中调用 `setAdapter()` 函数。这允许你定义服务器入口点以及适配器支持的功能。

以下示例创建了一个具有服务器入口点并对 Astro 静态输出提供稳定支持的适配器：

```js title="my-adapter.mjs" {5-13} "setAdapter"
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            staticOutput: 'stable'
          }
        });
      },
    },
  };
}
```

`setAdapter()` 函数接受一个包含以下属性的对象：

### `name`

<p>

**类型：** `string`
</p>

Defines a unique name for your adapter. This will be used for logging.

### `serverEntrypoint`

<p>

**类型：** `string | URL`
</p>

Defines the entrypoint for on-demand rendering.

<ReadMore>Learn more about [building a server entrypoint](#building-a-server-entrypoint).</ReadMore>

### `supportedAstroFeatures`

<p>

**类型：** `AstroAdapterFeatureMap`<br />
<Since v="3.0.0" />
</p>

A map of Astro's built-in features supported by the adapter. This allows Astro to determine which features an adapter supports, so appropriate error messages can be provided.

<ReadMore>Discover the [available Astro features](#astro-features) that an adapter can configure.</ReadMore>

### `adapterFeatures`

<p>

**类型：** `AstroAdapterFeatures`<br />
<Since v="3.0.0" />
</p>

An object that specifies which [adapter features that change the build output](#adapter-features) are supported by the adapter.

### `args`

<p>

**类型：** `any`
</p>

A JSON-serializable value that will be passed to the adapter's server entrypoint at runtime. This is useful to pass an object containing build-time configuration (e.g. paths, secrets) to your server runtime code.

The following example defines an `args` object with a property that identifies where assets generated by Astro are located:

```js title="my-adapter.mjs" {9-11}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          args: {
            assets: config.build.assets
          }
        });
      },
    },
  };
}
```

### `client`

<p>

**类型：** `{ internalFetchHeaders?: Record<string, string> | () => Record<string, string>; assetQueryParams?: URLSearchParams; }`<br />
<Since v="5.15.0" />
</p>

A configuration object for Astro's client-side code.

#### `internalFetchHeaders`

<p>

**类型：** `Record<string, string> | () => Record<string, string>`
</p>

Defines the headers to inject into Astro's internal fetch calls (e.g. Actions, View Transitions, Server Islands, Prefetch). This can be an object of headers or a function that returns headers.

The following example retrieves a `DEPLOY_ID` from the environment variables and, if provided, returns an object with the header name as key and the deploy id as value:

```js title="my-adapter.mjs" {9-14}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          client: {
            internalFetchHeaders: () => {
              const deployId = process.env.DEPLOY_ID;
              return deployId ? { 'Your-Header-ID': deployId } : {};
            },
          },
        });
      },
    },
  };
}
```

#### `assetQueryParams`

<p>

**类型：** `URLSearchParams`
</p>

Defines the query parameters to append to all asset URLs (e.g. images, stylesheets, scripts). This is useful for adapters that need to track deployment versions or other metadata.

The following example retrieves a `DEPLOY_ID` from the environment variables and, if provided, returns an object with a custom search parameter name as key and the deploy id as value:

```js title="my-adapter.mjs" {9-13}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          client: {
            assetQueryParams: process.env.DEPLOY_ID
              ? new URLSearchParams({ yourParam: process.env.DEPLOY_ID })
              : undefined,
          },
        });
      },
    },
  };
}
```

### `exports`

<p>

**类型：** `string[]`
</p>

Defines an array of named exports to use in conjunction with the [`createExports()` function](#createexports) of your server entrypoint.

The following example assumes that `createExports()` provides an export named `handler`:

```js title="my-adapter.mjs" {9}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          exports: ['handler']
        });
      },
    },
  };
}
```

### `previewEntrypoint`

<p>

**类型：** `string | URL`<br />
<Since v="1.5.0" />
</p>

Defines the path or ID of a module in the adapter's package that is responsible for starting up the built server when `astro preview` is run.

```js title="my-adapter.mjs" {9}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ config, setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          previewEntrypoint: '@example/my-adapter/preview.js',
        });
      },
    },
  };
}
```

## Building a server entrypoint

You will need to create a file that executes during server-side requests to enable on-demand rendering with your particular host. Astro's adapter API attempts to work with any type of host and gives a flexible way to conform to the host APIs.

### `createExports()`

<p>

**类型：** <code>(manifest: <a href="/zh-cn/reference/integrations-reference/#ssrmanifest">SSRManifest</a>, options: any) => Record\<string, any\></code>
</p>

  An exported function that takes an SSR manifest as its first argument and an object containing your adapter [`args`](#args) as its second argument. This should provide the exports required by your host.

For example, some serverless hosts expect you to export an `handler()` function. With the adapter API, you achieve this by implementing `createExports()` in your server entrypoint:

```js title="my-adapter/server.js"
import { App } from 'astro/app';

export function createExports(manifest) {
  const app = new App(manifest);

  const handler = (event, context) => {
    // ...
  };

  return { handler };
}
```

And then in your integration, where you call `setAdapter()`, provide this name in [`exports`](#exports):

```js title="my-adapter.mjs" ins={9}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          exports: ['handler'],
        });
      },
    },
  };
}
```

You can access the [`args`](#args) defined by your adapter through the second argument of `createExports()`. This can be useful when you need to access build-time configuration in your server entrypoint. For example, your server might need to identify where assets generated by Astro are located:


```js title="my-adapter/server.js" {4} "args"
import { App } from 'astro/app';

export function createExports(manifest, args) {
  const assetsPath = args.assets;

  const handler = (event, context) => {
    // ...
  };

  return { handler };
}
```

### `start()`

<p>

**类型：** <code>(manifest: <a href="/zh-cn/reference/integrations-reference/#ssrmanifest">SSRManifest</a>, options: any) => Record\<string, any\></code>
</p>

An exported function that takes an SSR manifest as its first argument and an object containing your adapter [`args`](#args) as its second argument.

Some hosts expect you to *start* the server yourselves, for example, by listening to a port. For these types of hosts, the adapter API allows you to export a `start()` function, which will be called when the bundle script is run.

```js title="my-adapter/server.js"
import { App } from 'astro/app';

export function start(manifest) {
  const app = new App(manifest);

  addEventListener('fetch', event => {
    // ...
  });
}
```

### `astro/app`

该模块用于渲染已通过 `astro build` 命令预构建的页面。Astro 使用标准的 [`Request`](https://developer.mozilla.org/zh-CN/docs/Web/API/Request) 和 [`Response`](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 对象。如果托管方使用不同格式的请求/响应 API，需要在适配器中进行转换处理。

The `App` constructor accepts a required SSR manifest argument, and optionally an argument to enable or disable streaming, defaulting to `true`.

```js
import { App } from 'astro/app';
import http from 'http';

export function start(manifest) {
  const app = new App(manifest);

  addEventListener('fetch', event => {
    event.respondWith(
      app.render(event.request)
    );
  });
}
```

该模块提供以下几个方法：

#### `app.render()`

<p>

**类型：** `(request: Request, options?: RenderOptions) => Promise<Response>`
</p>

A method that accepts a required `request` argument and an optional `RenderOptions` object。此方法用于匹配符合请求的 Astro 页面，并返回一个 Promise 对象给 [Response](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 。该方法对于不渲染页面的 API 路由同样适用。

```js
const response = await app.render(request);
```

##### `RenderOptions`

<p>

**类型：** `{addCookieHeader?: boolean; clientAddress?: string; locals?: object; prerenderedErrorPageFetch?: (url: ErrorPagePath) => Promise<Response>; routeData?: RouteData;}`
</p>

An object that controls the rendering and contains the following properties:

###### `addCookieHeader`

<p>

**类型：** `boolean`<br />
**默认值：** `false`
</p>


是否自动将 `Astro.cookie.set()` 写入的所有 cookie 添加到响应头中。

当设置为 `true` 时，它们将作为逗号分隔的键值对添加到响应的 `Set-Cookie` 头中。你可以使用标准的 `response.headers.getSetCookie()` API 来单独读取它们。
当设置为 `false`（默认值）时，这些 cookie 只能从 [`App.getSetCookieFromResponse(response)`](#appgetsetcookiefromresponse) 中获取。

```js
const response = await app.render(request, { addCookieHeader: true });
```

###### `clientAddress`

<p>

**类型：** `string`<br />
**默认值：** `request[Symbol.for("astro.clientAddress")]`
</p>

该客户端 IP 地址将作为 [`Astro.clientAddress`](/zh-cn/reference/api-reference/#clientaddress) 在页面中可用，并作为 API 路由和中间件中的 `ctx.clientAddress`。

下面的示例读取 `x-forwarded-for` 头，并将其作为 `clientAddress` 传递。该值将作为 `Astro.clientAddress` 提供给用户。

```js "clientAddress"
const clientAddress = request.headers.get("x-forwarded-for");
const response = await app.render(request, { clientAddress });
```

###### `locals`

<p>

**类型：** `object`
</p>

[`context.locals` 对象](/zh-cn/reference/api-reference/#locals) 用于在请求的生命周期中存储和访问信息。

下面的示例读取名为 `x-private-header` 的头，并尝试将其解析为对象并将其传递给 `locals`，然后可以将其传递给任何 [中间件函数](/zh-cn/guides/middleware/)。

```js "locals"
const privateHeader = request.headers.get("x-private-header");
let locals = {};
try {
  if (privateHeader) {
    locals = JSON.parse(privateHeader);
  }
} finally {
  const response = await app.render(request, { locals });
}
```

###### `prerenderedErrorPageFetch()`

<p>

**类型：** `(url: ErrorPagePath) => Promise<Response>`<br />
**默认值：** `fetch`<br />
<Since v="5.6.0" />
</p>

该函数允许你提供自定义的实现过程，用以获取预渲染的报错页面。

这可用于覆盖默认的 `fetch()` 行为，例如：当 `fetch()` 不可用时，又或是当你无法自行调用服务器时。

以下示例读取了磁盘中的 `500.html` 和 `404.html`，而不是执行 HTTP 调用：

```ts "prerenderedErrorPageFetch"
return app.render(request, {
  prerenderedErrorPageFetch: async (url: string): Promise<Response> => {
    if (url.includes("/500")) {
      const content = await fs.promises.readFile("500.html", "utf-8");
      return new Response(content, {
        status: 500,
        headers: { "Content-Type": "text/html" },
      });
    }

    const content = await fs.promises.readFile("404.html", "utf-8");
    return new Response(content, {
      status: 404,
      headers: { "Content-Type": "text/html" },
    });
  }
});
```

如果未提供，Astro 将回退至其默认行为，以获取报错页面。

###### `routeData`

<p>

**类型：** [`RouteData`](/zh-cn/reference/integrations-reference/#routedata)<br />
**默认值：** `app.match(request)`
</p>

定义路由信息。如果你已经知道要渲染的路由，这将非常有用。这样做将绕过内部调用 [`app.match()`](#appmatch) 来确定要渲染的路由。

```js "routeData"
const routeData = app.match(request);
if (routeData) {
  return app.render(request, { routeData });
} else {
  /* 特定于适配器的 404 响应 */
  return new Response(..., { status: 404 });
}
```

#### `app.match()`

<p>

**类型：** `(request: Request, allowPrerenderedRoutes = false) => RouteData | undefined`
</p>

判断请求是否匹配 Astro 应用的路由规则。

```js
if(app.match(request)) {
  const response = await app.render(request);
}
```

通常可以在不使用 `.match` 的情况下调用 `app.render(request)`。因为当配置了 `404.astro` 文件后，Astro 就会自动处理 404 的情况。如果想要自定义处理规则，请使用 `app.match(request)`。

By default, prerendered routes aren't returned, even if they are matched. You can change this behavior by using `true` as the second argument.

#### `app.getAdapterLogger()`

<p>

**类型：** `() => AstroIntegrationLogger`<br />
<Since v="v3.0.0" />
</p>

Returns an [instance of the Astro logger](/en/reference/integrations-reference/#astrointegrationlogger) available to the adapter's runtime environment.

```js "logger"
const logger = app.getAdapterLogger();
try {
  /* Some logic that can throw */
} catch {
  logger.error("Your custom error message using Astro logger.");
}
```

#### `app.getAllowedDomains()`

<p>

**类型：** `() => Partial<RemotePattern>[] | undefined`<br />
<Since v="5.14.2" />
</p>

Returns a list of permitted host patterns for incoming requests when using on-demand rendering [as defined in the user configuration](/en/reference/configuration-reference/#securityalloweddomains).

#### `app.removeBase()`

<p>

**类型：** `(pathname: string) => string`<br />
<Since v="1.6.4" />
</p>

Removes the base from the given path. This is useful when you need to look up assets from the filesystem.

#### `app.setCookieHeaders()`

<p>

**类型：** `(response: Response) => Generator<string, string[], any>`<br />
<Since v="1.4.0" />
</p>

Returns a generator that yields individual cookie header values from a `Response` object. This is used to properly handle multiple cookies that may have been set during request processing.

The following example appends a `Set-Cookie` header for each header obtained from a response:

```js
for (const setCookieHeader of app.setCookieHeaders(response)) {
  response.headers.append('Set-Cookie', setCookieHeader);
}
```

#### `App.getSetCookieFromResponse()`

<p>

**类型：** `(response: Response) => Generator<string, string[]>`<br />
<Since v="4.2.0" />
</p>

Returns a generator that yields individual cookie header values from a `Response` object. This works in the same way as [`app.setCookieHeaders()`](#appsetcookieheaders), but can be used at any time as it is a static method.

The following example appends a `Set-Cookie` header for each header obtained from a response:

```js
for (const cookie of App.getSetCookieFromResponse(response)) {
  response.headers.append('Set-Cookie', cookie);
}
```

#### `App.validateForwardedHost()`

<p>

**类型：** `(forwardedHost: string, allowedDomains?: Partial<RemotePattern>[], protocol?: string = 'https') => boolean`<br />
<Since v="5.14.2" />
</p>

Checks whether a `forwardedHost` matches any of the given [`allowedDomains`](/en/reference/configuration-reference/#securityalloweddomains). This static method accepts a third argument that allows you to override the host protocol, defaulting to `https`.

The following example retrieves the `forwardedHost` from the headers and checks if the host matches an allowed domain:

```js {4-6}
export function start(manifest) {
  addEventListener('fetch', (event) => {
    const forwardedHost = event.request.headers.get('X-Forwarded-Host');
    if (App.validateForwardedHost(forwardedHost, manifest.allowedDomains)) {
      /* do something */
    }
  });
}
```

#### `App.sanitizeHost()`

<p>

**类型：** `(hostname: string | undefined) => string | undefined`<br />
<Since v="5.15.5" />
</p>

Validates a hostname by rejecting any name containing path separators. When a hostname is invalid, this static method will return `undefined`.

The following example retrieves the `forwardedHost` from the headers and sanitizes it:

```js {4}
export function start(manifest) {
  addEventListener('fetch', (event) => {
    const forwardedHost = event.request.headers.get('X-Forwarded-Host');
    const sanitized = App.sanitizeHost(forwardedHost);
  });
}
```

#### `App.validateForwardedHeaders()`

<p>

**类型：** `(forwardedProtocol?: string, forwardedHost?: string, forwardedPort?: string, allowedDomains?: Partial<RemotePattern>[]) => { protocol?: string; host?: string; port?: string }`<br />
<Since v="5.15.5" />
</p>

Validates the forwarded protocol, host, and port against the `allowedDomains`. This static method returns validated values or `undefined` for rejected headers.

The following example validates the forwarded headers against the authorized domains defined in the received manifest:

```js {3-8}
export function start(manifest) {
  addEventListener('fetch', (event) => {
    const validated = App.validateForwardedHeaders(
      request.headers.get('X-Forwarded-Proto') ?? undefined,
      request.headers.get('X-Forwarded-Host') ?? undefined,
      request.headers.get('X-Forwarded-Port') ?? undefined,
      manifest.allowedDomains,
    );
  });
}
```

### `astro/app/node`

Just like [`astro/app`](#astroapp), this module is used for rendering pages that have been prebuilt through `astro build`. This allows you to create a `NodeApp` providing all the methods available from `App` and additional methods useful for Node environments.

The `NodeApp` constructor accepts a required SSR manifest argument, and optionally an argument to enable or disable streaming, defaulting to `true`.

```js
import { NodeApp } from 'astro/app/node';
import http from 'http';

export function start(manifest) {
  const nodeApp = new NodeApp(manifest);

  addEventListener('fetch', event => {
    event.respondWith(
      nodeApp.render(event.request)
    );
  });
}
```

The following additional methods are provided:

#### `nodeApp.render()`

<p>

**类型：** `(request: NodeRequest | Request, options?: RenderOptions) => Promise<Response>`<br />
<Since v="4.0.0" />
</p>

Extends [`app.render()`](#apprender) to also accept [Node.js `IncomingMessage`](https://nodejs.org/api/http.html#class-httpincomingmessage) objects in addition to standard `Request` objects as the first argument. The second argument is an optional object allowing you to [control the rendering](#renderoptions).

```js
const response = await nodeApp.render(request);
```

#### `nodeApp.match()`

<p>

**类型：** `(req: NodeRequest | Request, allowPrerenderedRoutes?: boolean) => RouteData | undefined`
</p>

Extends [`app.match()`](#appmatch) to also accept [Node.js `IncomingMessage`](https://nodejs.org/api/http.html#class-httpincomingmessage) objects in addition to standard `Request` objects.

```js
if(nodeApp.match(request)) {
  const response = await nodeApp.render(request);
}
```

#### `nodeApp.headersMap`

<p>

**类型：** `NodeAppHeadersJson | undefined`<br />
**Default:** `undefined`<br />
<Since v="5.11.0" />
</p>

An array containing the headers configuration. Each entry maps a pathname to a list of headers that should be applied for that route. This is useful for applying headers such as CSP directives to prerendered routes.

#### `nodeApp.setHeadersMap()`

<p>

**类型：** `(headers: NodeAppHeadersJson) => void`<br />
<Since v="5.11.0" />
</p>

Loads [headers configuration](#nodeappheadersmap) into the `NodeApp` instance. 

```js
nodeApp.setHeadersMap([
  {
    pathname: "/blog",
    headers: [
      { key: "Content-Security-Policy", value: "default-src 'self'" },
    ]
  }
]);
```

#### `NodeApp.createRequest()`

<p>

**类型：** `(req: NodeRequest, options?: { skipBody?: boolean; allowedDomains?: Partial<RemotePattern>[]; }) => Request`<br />
<Since v="4.2.0" />
</p>

Converts a NodeJS `IncomingMessage` into a standard `Request` object. This static method accepts an optional object as the second argument, allowing you to define if the body should be ignored, defaulting to `false`, and the [`allowedDomains`](/en/reference/configuration-reference/#securityalloweddomains).

The following example creates a `Request` and passes it to `app.render()`:

```js {5}
import { NodeApp } from 'astro/app/node';
import { createServer } from 'node:http';

const server = createServer(async (req, res) => {
  const request = NodeApp.createRequest(req);
  const response = await app.render(request);
})
```

#### `NodeApp.writeResponse()`

<p>

**类型：** `(source: Response, destination: ServerResponse) => Promise<ServerResponse<IncomingMessage> | undefined>`<br />
<Since v="4.2.0" />
</p>

Streams a web-standard `Response` into a NodeJS server response. This static method takes a `Response` object and the initial `ServerResponse` before returning a promise of a `ServerResponse` object.

The following example creates a `Request`, passes it to `app.render()`, and writes the response:

```js {7}
import { NodeApp } from 'astro/app/node';
import { createServer } from 'node:http';

const server = createServer(async (req, res) => {
  const request = NodeApp.createRequest(req);
  const response = await app.render(request);
  await NodeApp.writeResponse(response, res);
})
```

## Astro features

Astro features are a way for an adapter to tell Astro whether they are able to support a feature, and also the adapter’s level of support.

When using these properties, Astro will:
- run specific validation; 
- emit contextual information to the logs;

These operations are run based on the features supported or not supported, their level of support, the [desired amount of logging](#suppress), and the user's own configuration.

The following configuration tells Astro that this adapter has experimental support for the Sharp-powered built-in image service:

```js title="my-adapter.mjs" ins={9-11}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            sharpImageService: 'experimental'
          } 
        });
      },
    },
  };
}
```

If the Sharp image service is used, Astro will log a warning and error to the terminal based on your adapter's support:

```
[@example/my-adapter] The feature is experimental and subject to issues or changes.

[@example/my-adapter] The currently selected adapter `@example/my-adapter` is not compatible with the service "Sharp". Your project will NOT be able to build.
```

A message can additionally be provided to give more context to the user:

```js title="my-adapter.mjs" ins={9-14}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            sharpImageService: {
              support: 'limited',
              message: 'This adapter has limited support for Sharp. Certain features may not work as expected.'
            }
          } 
        });
      },
    },
  };
}
```

This object contains the following configurable features:

### `staticOutput`

<p>

**类型：** [`AdapterSupport`](#adaptersupport)
</p>

Defines whether the adapter is able to serve static pages.

### `hybridOutput`

<p>

**类型：** [`AdapterSupport`](#adaptersupport)
</p>

Defines whether the adapter is able to serve sites that include a mix of static and on-demand rendered pages.

### `serverOutput`

<p>

**类型：** [`AdapterSupport`](#adaptersupport)
</p>

Defines whether the adapter is able to serve on-demand rendered pages.

### `i18nDomains`

<p>

**类型：** [`AdapterSupport`](#adaptersupport)<br />
<Since v="4.3.0" />
</p>

Defines whether the adapter is able to support i18n domains.

### `envGetSecret`

<p>

**类型：** [`AdapterSupport`](#adaptersupport)<br />
<Since v="4.10.0" />
</p>

Defines whether the adapter is able to support `getSecret()` exported from [`astro:env/server`](/en/reference/modules/astro-env/). When enabled, this feature allows your adapter to retrieve secrets configured by users in `env.schema`.

The following example enables the feature by passing [a valid `AdapterSupportsKind` value](#adaptersupportskind) to the adapter:

```js title="my-adapter.mjs" ins={9-11}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            envGetSecret: 'stable'
          } 
        });
      },
    },
  };
}
```

`astro/env/setup` 模块允许你为 `getSecret()` 提供一个实现。在 [你的服务器入口](#building-a-server-entrypoint) 中，尽早调用 `setGetEnv()`：

```js ins={2,4}
import { App } from 'astro/app';
import { setGetEnv } from "astro/env/setup"

setGetEnv((key) => process.env[key])

export function createExports(manifest) {
  const app = new App(manifest);

  const handler = (event, context) => {
    // ...
  };

  return { handler };
}
```

如果适配器支持密钥，请确保在环境变量与请求绑定时，先调用 `setGetEnv()`，再调用 `getSecret()`：

```js ins={3,14}
import type { SSRManifest } from 'astro';
import { App } from 'astro/app';
import { setGetEnv } from 'astro/env/setup';
import { createGetEnv } from '../utils/env.js';

type Env = {
	[key: string]: unknown;
};

export function createExports(manifest: SSRManifest) {
	const app = new App(manifest);

	const fetch = async (request: Request, env: Env) => {
		setGetEnv(createGetEnv(env));

		const response = await app.render(request);

		return response;
	};

	return { default: { fetch } };
}
```

### `sharpImageService`

<p>

**类型：** [`AdapterSupport`](#adaptersupport)<br />
<Since v="5.0.0" />
</p>

Defines whether the adapter supports image transformation using the built-in Sharp image service.

## Adapter features

A set of features that changes the output of the emitted files. When an adapter opts in to these features, they will get additional information inside specific hooks and must implement the proper logic to handle the different output.

### `edgeMiddleware`

<p>

**类型：** `boolean`
</p>

Defines whether any on-demand rendering middleware code will be bundled when built.

When enabled, this prevents middleware code from being bundled and imported by all pages during the build:

```js title="my-adapter.mjs" ins={9-11}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          adapterFeatures: {
            edgeMiddleware: true
          } 
        });
      },
    },
  };
}
```

Then, consume the hook [`astro:build:ssr`](/en/reference/integrations-reference/#astrobuildssr), which will give you a `middlewareEntryPoint`, an `URL` to the physical file on the file system.

```js title="my-adapter.mjs" ins={15-20}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          adapterFeatures: {
            edgeMiddleware: true
          } 
        });
      },

      'astro:build:ssr': ({ middlewareEntryPoint }) => {
        // remember to check if this property exits, it will be `undefined` if the adapter doesn't opt in to the feature
        if (middlewareEntryPoint) {
          createEdgeMiddleware(middlewareEntryPoint)
        }
      }  
    },
  };
}

function createEdgeMiddleware(middlewareEntryPoint) {
  // emit a new physical file using your bundler
}
```

### `buildOutput`

<p>

**类型：** `"static" | "server"`<br />
**Default:** `"server"`<br />
<Since v="5.0.0" />
</p>

Allows you to force a specific output shape for the build. This can be useful for adapters that only work with a specific output type. For example, your adapter might expect a static website, but uses an adapter to create host-specific files. Defaults to `server` if not specified.

```js title="my-adapter.mjs" ins={9-11}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          adapterFeatures: {
            buildOutput: 'static'
          } 
        });
      },
    },
  };
}
```

### `experimentalStaticHeaders`

<p>

**类型：** `boolean`<br />
<Since v="5.9.3" />
</p>

Whether or not the adapter provides experimental support for setting response headers for static pages. When this feature is enabled, Astro will return a map of the `Headers` emitted by the static pages. This map `experimentalRouteToHeaders` is available in the [`astro:build:generated` hook](/en/reference/integrations-reference/#astrobuildgenerated) for generating files such as a `_headers` that allows you to make changes to the default HTTP header.

```js title="my-adapter.mjs" ins={9-11}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          adapterFeatures: {
            experimentalStaticHeaders: true,
          },
        });
      },
      'astro:build:generated': ({ experimentalRouteToHeaders }) => {
        // use `experimentalRouteToHeaders` to generate a configuration file
        // for your virtual host of choice
      },
    },
  };
}
```

The value of the headers might change based on the features enabled/used by the application. For example, if [CSP is enabled](/en/reference/experimental-flags/csp/), the `<meta http-equiv="content-security-policy">` element is not added to the static page. Instead, its `content` is available in the `experimentalRouteToHeaders` map. 

## Adapter types reference

### `AdapterSupport`

<p>

**类型：** <code><a href="#adaptersupport">AdapterSupportsKind</a> | <a href="#adaptersupportwithmessage">AdapterSupportWithMessage</a></code><br />
<Since v="5.0.0" />
</p>

A union of valid formats to describe the support level for a feature.

### `AdapterSupportsKind`

<p>

**类型：** `"deprecated" | "experimental" | "limited" | "stable" | "unsupported"`
</p>

Defines the level of support for a feature by your adapter:
* Use `"deprecated"` when your adapter deprecates support for a feature before removing it completely in a future version.
* Use `"experimental"` when your adapter adds support for a feature, but issues or breaking changes are expected.
* Use `"limited"` when your adapter only supports a subset of the full feature.
* Use `"stable"` when the feature is fully supported by your adapter.
* Use `"unsupported"` to warn users that they may encounter build issues in their project, as this feature is not supported by your adapter.

### `AdapterSupportWithMessage`

<p>

<Since v="5.0.0" />
</p>

An object that allows you to define a support level for a feature and a message to be logged in the user console. This object contains the following properties:

#### `support`

<p>

**类型：** <code>Exclude\<<a href="#adaptersupportskind">AdapterSupportsKind</a>, "stable"\></code>
</p>

Defines the level of support for a feature by your adapter.

#### `message`

<p>

**类型：** `string`
</p>

Defines a custom message to log regarding the support of a feature by your adapter.

#### `suppress`

<p>

**类型：** `"default" | "all"`<br />
<Since v="5.9.0" />
</p>

An option to prevent showing some or all logged messages about an adapter's support for a feature.

If Astro's default log message is redundant, or confusing to the user in combination with your [custom `message`](#message), you can use `suppress: "default"` to suppress the default message and only log your message:

```js title="my-adapter.mjs" ins={13}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            sharpImageService: {
              support: 'limited',
              message: 'The adapter has limited support for Sharp. It will be used for images during build time, but will not work at runtime.',
              suppress: 'default' // custom message is more detailed than the default
            }
          } 
        });
      },
    },
  };
}
```

You can also use `suppress: "all"` to suppress all messages about support for the feature. This is useful when these messages are unhelpful to users in a specific context, such as when they have a configuration setting that means they are not using that feature. For example, you can choose to prevent logging any messages about Sharp support from your adapter:

```js title="my-adapter.mjs" ins={13}
export default function createIntegration() {
  return {
    name: '@example/my-adapter',
    hooks: {
      'astro:config:done': ({ setAdapter }) => {
        setAdapter({
          name: '@example/my-adapter',
          serverEntrypoint: '@example/my-adapter/server.js',
          supportedAstroFeatures: {
            sharpImageService: {
              support: 'limited',
              message: 'This adapter has limited support for Sharp. Certain features may not work as expected.',
              suppress: 'all'
            }
          } 
        });
      },
    },
  };
}
```

## Allow installation via `astro add`

[The `astro add` command](/en/reference/cli-reference/#astro-add) allows users to easily add integrations and adapters to their project.  To allow your adapter to be installed with this command, **add `astro-adapter` to the `keywords` field in your `package.json`**:

```json
{
  "name": "example",
  "keywords": ["astro-adapter"],
}
```

Once you [publish your adapter to npm](https://docs.npmjs.com/cli/v8/commands/npm-publish), running `astro add example` will install your package with any peer dependencies specified in your `package.json` and instruct users to update their project config manually.
